{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"RType","text":"<p>A GAME ENGINE THAT ROARS !</p> RType Client Client side part of the RType project. Entity Component System While not a required part of the project, the Entity Component System (or ECS) is quite important. Flint A custom implementation of the Flint library Network Custom classes handeling all the networking. Server As important as all of the other parts (if not more), the server is the masterchief of the orchestra. ECS Network RType <p> Code Coverage</p>"},{"location":"#types","title":"Types","text":"Name Description ComponentStorageBase ComponentStorage Interface ComponentStorage Stores all of the components of a same type wrapped in a std::shared_ptr  <code>Component</code> :    Struct of the component."},{"location":"ComponentStorage/","title":"ComponentStorage","text":"<p>template &lt;typename Component&gt; class ComponentStorage : public ComponentStorageBase</p> <p>Stores all of the components of a same type wrapped in a std::shared_ptr</p> <code>Component</code> Struct of the component."},{"location":"ComponentStorage/#functions","title":"Functions","text":"Name Description get Get component wrapped in a std::optional  <code>id</code> :    Entity ID. add Add a component for an entity  <code>id</code> :    Entity ID. remove Remove component from an entity  <code>id</code> :    Entity ID."},{"location":"ComponentStorage/#function-details","title":"Function Details","text":""},{"location":"ComponentStorage/#get","title":"get","text":"<p>std::optional&lt;std::shared_ptr&lt;Component&gt;&gt; get(ECS::entity_id id)</p> <p>Get component wrapped in a std::optional</p> <code>id</code> Entity ID."},{"location":"ComponentStorage/#add","title":"add","text":"<p>void add(ECS::entity_id id, std::shared_ptr&lt;Component&gt; component)</p> <p>Add a component for an entity</p> <code>id</code> Entity ID."},{"location":"ComponentStorage/#remove","title":"remove","text":"<p>void remove(ECS::entity_id id)</p> <p>Remove component from an entity</p> <code>id</code> Entity ID."},{"location":"ComponentStorageBase/","title":"ComponentStorageBase","text":"<p>class ComponentStorageBase</p> <p>ComponentStorage Interface</p>"},{"location":"ECS/","title":"ECS","text":"Component"},{"location":"ECS/#types","title":"Types","text":"Name Description AScript Default abstract of IScript, only global functions are defined. IScript Interface for script classes"},{"location":"ECS/AScript/","title":"AScript","text":"<p>class AScript : public ECS::IScript</p> <p>Default abstract of IScript, only global functions are defined.</p> <p>This script's methods will be called by the engine in specific moments, they cannot be called elsewhere</p> <p>Classes that inherit from this (the scripts you will create) can have their own private variables or component pointers (see example scripts in the ScriptSource folder for example)</p> <code>Game</code> Pointer to access the engine class's content <code>_selfID</code> ID of the script's entity"},{"location":"ECS/AScript/#functions","title":"Functions","text":"Name Description onStart Called on Entity's first frame of existence, usefull for getting all components once onUpdate Called every frame onCollision Called when an entity collides with another, they need a hitbox component to be activatable  <code>id</code> :    ID of the entity who collided the script's owner onClick Called when mouse clicks on the entity, they need to have an hitbox setEcsManager Called when Script is assigned to an entity so that they can manipulate the engine  <code>ecsManager</code> :    Pointer to ECSManager Class (the engine). setEntityID Defines the script's user ID  <code>id</code> :    Entity ID. spawnPrefabAt Automatically spawn a prefab at (x, y), useful for spawning decor or temporary animation elements !!! warning NOT RECOMMENDED, MODIFYING ENTITIES CREATED BY THIS METHOD MAY CAUSE CRASH  <code>prefabName</code> :    Prefab name.  <code>x</code> :    X position  <code>y</code> :    Y position"},{"location":"ECS/AScript/#function-details","title":"Function Details","text":""},{"location":"ECS/AScript/#onstart","title":"onStart","text":"<p>void onStart()</p> <p>Called on Entity's first frame of existence, usefull for getting all components once</p>"},{"location":"ECS/AScript/#onupdate","title":"onUpdate","text":"<p>void onUpdate()</p> <p>Called every frame</p>"},{"location":"ECS/AScript/#oncollision","title":"onCollision","text":"<p>void onCollision(ECS::entity_id id)</p> <p>Called when an entity collides with another, they need a hitbox component to be activatable</p> <code>id</code> ID of the entity who collided the script's owner"},{"location":"ECS/AScript/#onclick","title":"onClick","text":"<p>void onClick()</p> <p>Called when mouse clicks on the entity, they need to have an hitbox</p>"},{"location":"ECS/AScript/#setecsmanager","title":"setEcsManager","text":"<p>void setEcsManager(ECS::ECSManager* ecsManager)</p> <p>Called when Script is assigned to an entity so that they can manipulate the engine</p> <code>ecsManager</code> Pointer to ECSManager Class (the engine)."},{"location":"ECS/AScript/#setentityid","title":"setEntityID","text":"<p>void setEntityID(ECS::entity_id id)</p> <p>Defines the script's user ID</p> <code>id</code> Entity ID."},{"location":"ECS/AScript/#spawnprefabat","title":"spawnPrefabAt","text":"<p>ECS::entity_id spawnPrefabAt(std::string prefabName, int x, int y)</p> <p>Automatically spawn a prefab at (x, y), useful for spawning decor or temporary animation elements</p> <p>Warning</p> <p>NOT RECOMMENDED, MODIFYING ENTITIES CREATED BY THIS METHOD MAY CAUSE CRASH</p> <code>prefabName</code> Prefab name. <code>x</code> X position <code>y</code> Y position"},{"location":"ECS/IScript/","title":"IScript","text":"<p>class IScript</p> <p>Interface for script classes</p>"},{"location":"ECS/Component/","title":"Component","text":""},{"location":"ECS/Component/#types","title":"Types","text":"Name Description Acceleration Acceleration of entity  <code>x</code> :    X acceleration.  <code>y</code> :    Y acceleration. !!! warning THIS COMPONENT IS NOT IMPLEMENTED Animation Animation rect of entity  <code>rect</code> :    Frame for sprite.  <code>fps</code> :    Frame per second.  <code>destroyAtEnt</code> :    If true, the entity will automatically be destroyed at the end of the animation, perfect for particles Drawable Visual for entity  <code>sprite</code> :    Sprite.  <code>center</code> :    If true, the sprite will be centered based on it's position Health Health information for component  <code>health</code> :    Health value Hitbox Rectangle box for collisions/zone/etc...  <code>x</code> :    X outset.  <code>y</code> :    Y outset.  <code>w</code> :    width.  <code>h</code> :    height. Parallax Parallax movement for entity  <code>speed</code> :    Speed of parallax, goes backwards if negative value. !!! warning Float values can sometimes not work, for onsistency, only use int values PlayerInput Used for debugging local inputs  <code>up,</code> :    down, left, right, action Action value. Position Position inside world space  <code>x</code> :    X position.  <code>y</code> :    Y position. Script Scripting on entity  <code>name</code> :    Script name. SpriteSheet Spritesheet info for selecting Sprite part on One line  <code>nbrOfState</code> :    nbr of different states avaliable.  <code>state</code> :    state selected. !!! warning THIS COMPONENT IS NOT IMPLEMENTED OR FUNCTIONAL State State value usable for StateMachine or simply indicating a state  <code>name</code> :    State name. Tag Tag value usable for entity labeling/categorisation Usefull for entity differentiation when colliding for example  <code>name</code> :    State name. Velocity Velocity of entity  <code>x</code> :    X speed.  <code>y</code> :    Y speed."},{"location":"ECS/Component/Acceleration/","title":"Acceleration","text":"<p>struct Acceleration</p> <p>Acceleration of entity</p> <code>x</code> X acceleration. <code>y</code> Y acceleration. <p>Warning</p> <p>THIS COMPONENT IS NOT IMPLEMENTED</p>"},{"location":"ECS/Component/Animation/","title":"Animation","text":"<p>struct Animation</p> <p>Animation rect of entity</p> <code>rect</code> Frame for sprite. <code>fps</code> Frame per second. <code>destroyAtEnt</code> If true, the entity will automatically be destroyed at the end of the animation, perfect for particles"},{"location":"ECS/Component/Drawable/","title":"Drawable","text":"<p>struct Drawable</p> <p>Visual for entity</p> <code>sprite</code> Sprite. <code>center</code> If true, the sprite will be centered based on it's position"},{"location":"ECS/Component/Health/","title":"Health","text":"<p>struct Health</p> <p>Health information for component</p> <code>health</code> Health value"},{"location":"ECS/Component/Hitbox/","title":"Hitbox","text":"<p>struct Hitbox</p> <p>Rectangle box for collisions/zone/etc...</p> <code>x</code> X outset. <code>y</code> Y outset. <code>w</code> width. <code>h</code> height."},{"location":"ECS/Component/Parallax/","title":"Parallax","text":"<p>struct Parallax</p> <p>Parallax movement for entity</p> <code>speed</code> Speed of parallax, goes backwards if negative value. <p>Warning</p> <p>Float values can sometimes not work, for onsistency, only use int values</p>"},{"location":"ECS/Component/PlayerInput/","title":"PlayerInput","text":"<p>struct PlayerInput</p> <p>Used for debugging local inputs</p> <code>up,</code> down, left, right, action Action value."},{"location":"ECS/Component/Position/","title":"Position","text":"<p>struct Position</p> <p>Position inside world space</p> <code>x</code> X position. <code>y</code> Y position."},{"location":"ECS/Component/Script/","title":"Script","text":"<p>struct Script</p> <p>Scripting on entity</p> <code>name</code> Script name."},{"location":"ECS/Component/SpriteSheet/","title":"SpriteSheet","text":"<p>struct SpriteSheet</p> <p>Spritesheet info for selecting Sprite part on One line</p> <code>nbrOfState</code> nbr of different states avaliable. <code>state</code> state selected. <p>Warning</p> <p>THIS COMPONENT IS NOT IMPLEMENTED OR FUNCTIONAL</p>"},{"location":"ECS/Component/State/","title":"State","text":"<p>struct State</p> <p>State value usable for StateMachine or simply indicating a state</p> <code>name</code> State name."},{"location":"ECS/Component/Tag/","title":"Tag","text":"<p>struct Tag</p> <p>Tag value usable for entity labeling/categorisation     Usefull for entity differentiation when colliding for example</p> <code>name</code> State name."},{"location":"ECS/Component/Velocity/","title":"Velocity","text":"<p>struct Velocity</p> <p>Velocity of entity</p> <code>x</code> X speed. <code>y</code> Y speed."},{"location":"Network/","title":"Network","text":"Serialized"},{"location":"Network/Serialized/","title":"Serialized","text":""},{"location":"Network/Serialized/#types","title":"Types","text":"Name Description PlayerPosition"},{"location":"Network/Serialized/PlayerPosition/","title":"PlayerPosition","text":"<p>class PlayerPosition: public Flint::Inspection&lt;PlayerPosition&gt;</p>"},{"location":"Network/Serialized/PlayerPosition/#functions","title":"Functions","text":"Name Description str This class being a child of Flint::Inspection, overriding the str function also override the operator&lt;&lt;. This is done for debugging purposes."},{"location":"Network/Serialized/PlayerPosition/#function-details","title":"Function Details","text":""},{"location":"Network/Serialized/PlayerPosition/#str","title":"str","text":"<p>std::string str() const override</p> <p>This class being a child of Flint::Inspection, overriding the str function also override the operator&lt;&lt;. This is done for debugging purposes.</p>"},{"location":"RType/","title":"RType","text":"GUI"},{"location":"RType/GUI/","title":"GUI","text":""},{"location":"RType/GUI/#variables","title":"Variables","text":"Name Description font ///////////////////////////////// FONTS /////////////////////////////////////// music ///////////////////////////////// MUSIC /////////////////////////////////////// soundBuffer ///////////////////////////////// SOUNDS /////////////////////////////////////// texture ///////////////////////////////// TEXTURES ////////////////////////////////////"},{"location":"RType/GUI/#variable-details","title":"Variable Details","text":""},{"location":"RType/GUI/#font","title":"font","text":"<p>sf::Font font</p> <p>///////////////////////////////// FONTS ///////////////////////////////////////</p>"},{"location":"RType/GUI/#music","title":"music","text":"<p>auto music</p> <p>///////////////////////////////// MUSIC ///////////////////////////////////////</p>"},{"location":"RType/GUI/#soundbuffer","title":"soundBuffer","text":"<p>sf::SoundBuffer soundBuffer</p> <p>///////////////////////////////// SOUNDS ///////////////////////////////////////</p>"},{"location":"RType/GUI/#texture","title":"texture","text":"<p>sf::Texture texture</p> <p>///////////////////////////////// TEXTURES ////////////////////////////////////</p>"},{"location":"client/","title":"RType Client","text":"<p>Client side part of the RType project. Runs using SFML and connect to the server in order to play.</p>"},{"location":"coverage/","title":"Code Coverage","text":"Name Lines Covered Uncovered Coverage client 504 0 504 0.0% src 504 0 504 0.0% Game 29 0 29 0.0% Game.cpp 27 0 27 0.0% Game.hpp 2 0 2 0.0% Objets 222 0 222 0.0% Abstract 17 0 17 0.0% AObjet 17 0 17 0.0% AObjet.cpp 12 0 12 0.0% AObjet.hpp 5 0 5 0.0% IObjet 0 0 0 100.0% IObjet.hpp 0 0 0 100.0% Background 9 0 9 0.0% background.cpp 9 0 9 0.0% background.hpp 0 0 0 100.0% Button 179 0 179 0.0% CostumButton 36 0 36 0.0% costumButton.cpp 31 0 31 0.0% costumButton.hpp 5 0 5 0.0% GeneriqueButton 13 0 13 0.0% generiqueButton.cpp 12 0 12 0.0% generiqueButton.hpp 1 0 1 0.0% JoinRoomButton 40 0 40 0.0% joinRoomButton.cpp 36 0 36 0.0% joinRoomButton.hpp 4 0 4 0.0% SliderVolume 38 0 38 0.0% sliderVolume.cpp 36 0 36 0.0% sliderVolume.hpp 2 0 2 0.0% SpriteButton 22 0 22 0.0% spriteButton.cpp 19 0 19 0.0% spriteButton.hpp 3 0 3 0.0% TextButton 30 0 30 0.0% textButton.cpp 26 0 26 0.0% textButton.hpp 4 0 4 0.0% Text 17 0 17 0.0% text.cpp 12 0 12 0.0% text.hpp 5 0 5 0.0% RessourcesManager 89 0 89 0.0% ressourcesManager.cpp 87 0 87 0.0% ressourcesManager.hpp 2 0 2 0.0% Scene 164 0 164 0.0% Credit_scene 26 0 26 0.0% credit_s.cpp 26 0 26 0.0% credit_s.hpp 0 0 0 100.0% HostGame_scene 22 0 22 0.0% hostGame_s.cpp 22 0 22 0.0% hostGame_s.hpp 0 0 0 100.0% JoinGame_scene 25 0 25 0.0% joinGame_s.cpp 25 0 25 0.0% joinGame_s.hpp 0 0 0 100.0% Menu_scene 33 0 33 0.0% menu_s.cpp 33 0 33 0.0% menu_s.hpp 0 0 0 100.0% SceneManager 14 0 14 0.0% SceneManager.cpp 14 0 14 0.0% SceneManager.hpp 0 0 0 100.0% Setting_scene 44 0 44 0.0% setting_s.cpp 44 0 44 0.0% setting_s.hpp 0 0 0 100.0% IScene.hpp 0 0 0 100.0% ecs 41 0 41 0.0% src 41 0 41 0.0% Component 33 0 33 0.0% ComponentStorage.hpp 9 0 9 0.0% Components.hpp 24 0 24 0.0% Script 8 0 8 0.0% AScript.hpp 8 0 8 0.0% IScript.hpp 0 0 0 100.0% flint 101 44 57 43.6% src 101 44 57 43.6% Colors 0 0 0 100.0% Colors.cpp 0 0 0 100.0% Colors.hpp 0 0 0 100.0% CxxABI 34 26 8 76.5% CxxABI.cpp 34 26 8 76.5% CxxABI.hpp 0 0 0 100.0% Exceptions 44 17 27 38.6% Exceptions.cpp 43 17 26 39.5% Exceptions.hpp 1 0 1 0.0% Init 6 1 5 16.7% Init.cpp 6 1 5 16.7% Init.hpp 0 0 0 100.0% Logging 9 0 9 0.0% Logging.cpp 8 0 8 0.0% Logging.hpp 1 0 1 0.0% hpp 8 0 8 0.0% Inspection.hpp 8 0 8 0.0% Preprocessor.hpp 0 0 0 100.0% network 91 0 91 0.0% src 91 0 91 0.0% Client 0 0 0 100.0% UDP 0 0 0 100.0% UDPClient.cpp 0 0 0 100.0% UDPClient.hpp 0 0 0 100.0% Security 71 0 71 0.0% DecodeError.hpp 3 0 3 0.0% GaloisField.cpp 8 0 8 0.0% GaloisField.hpp 1 0 1 0.0% HammingCodes.cpp 55 0 55 0.0% HammingCodes.hpp 1 0 1 0.0% ReedSolomon.cpp 2 0 2 0.0% ReedSolomon.hpp 1 0 1 0.0% Serialized 4 0 4 0.0% PlayerPosition.cpp 4 0 4 0.0% PlayerPosition.hpp 0 0 0 100.0% Server 16 0 16 0.0% UDP 16 0 16 0.0% UDPServer.cpp 16 0 16 0.0% UDPServer.hpp 0 0 0 100.0% Summary 29 0 29 0.0% Summary 17 0 17 0.0% Summary 0 0 0 100.0% Summary 17 0 17 0.0% Summary 9 0 9 0.0% Summary 36 0 36 0.0% Summary 13 0 13 0.0% Summary 40 0 40 0.0% Summary 38 0 38 0.0% Summary 22 0 22 0.0% Summary 30 0 30 0.0% Summary 179 0 179 0.0% Summary 17 0 17 0.0% Summary 222 0 222 0.0% Summary 89 0 89 0.0% Summary 26 0 26 0.0% Summary 22 0 22 0.0% Summary 25 0 25 0.0% Summary 33 0 33 0.0% Summary 14 0 14 0.0% Summary 44 0 44 0.0% Summary 164 0 164 0.0% Summary 504 0 504 0.0% Summary 504 0 504 0.0% Summary 33 0 33 0.0% Summary 8 0 8 0.0% Summary 41 0 41 0.0% Summary 41 0 41 0.0% Summary 0 0 0 100.0% Summary 34 26 8 76.5% Summary 44 17 27 38.6% Summary 6 1 5 16.7% Summary 9 0 9 0.0% Summary 8 0 8 0.0% Summary 101 44 57 43.6% Summary 101 44 57 43.6% Summary 0 0 0 100.0% Summary 0 0 0 100.0% Summary 71 0 71 0.0% Summary 4 0 4 0.0% Summary 16 0 16 0.0% Summary 16 0 16 0.0% Summary 91 0 91 0.0% Summary 91 0 91 0.0% Summary 737 44 693 6.0%"},{"location":"coverage/client/","title":"client","text":"Name Lines Covered Uncovered Coverage src 504 0 504 0.0% Game 29 0 29 0.0% Game.cpp 27 0 27 0.0% Game.hpp 2 0 2 0.0% Objets 222 0 222 0.0% Abstract 17 0 17 0.0% AObjet 17 0 17 0.0% AObjet.cpp 12 0 12 0.0% AObjet.hpp 5 0 5 0.0% IObjet 0 0 0 100.0% IObjet.hpp 0 0 0 100.0% Background 9 0 9 0.0% background.cpp 9 0 9 0.0% background.hpp 0 0 0 100.0% Button 179 0 179 0.0% CostumButton 36 0 36 0.0% costumButton.cpp 31 0 31 0.0% costumButton.hpp 5 0 5 0.0% GeneriqueButton 13 0 13 0.0% generiqueButton.cpp 12 0 12 0.0% generiqueButton.hpp 1 0 1 0.0% JoinRoomButton 40 0 40 0.0% joinRoomButton.cpp 36 0 36 0.0% joinRoomButton.hpp 4 0 4 0.0% SliderVolume 38 0 38 0.0% sliderVolume.cpp 36 0 36 0.0% sliderVolume.hpp 2 0 2 0.0% SpriteButton 22 0 22 0.0% spriteButton.cpp 19 0 19 0.0% spriteButton.hpp 3 0 3 0.0% TextButton 30 0 30 0.0% textButton.cpp 26 0 26 0.0% textButton.hpp 4 0 4 0.0% Text 17 0 17 0.0% text.cpp 12 0 12 0.0% text.hpp 5 0 5 0.0% RessourcesManager 89 0 89 0.0% ressourcesManager.cpp 87 0 87 0.0% ressourcesManager.hpp 2 0 2 0.0% Scene 164 0 164 0.0% Credit_scene 26 0 26 0.0% credit_s.cpp 26 0 26 0.0% credit_s.hpp 0 0 0 100.0% HostGame_scene 22 0 22 0.0% hostGame_s.cpp 22 0 22 0.0% hostGame_s.hpp 0 0 0 100.0% JoinGame_scene 25 0 25 0.0% joinGame_s.cpp 25 0 25 0.0% joinGame_s.hpp 0 0 0 100.0% Menu_scene 33 0 33 0.0% menu_s.cpp 33 0 33 0.0% menu_s.hpp 0 0 0 100.0% SceneManager 14 0 14 0.0% SceneManager.cpp 14 0 14 0.0% SceneManager.hpp 0 0 0 100.0% Setting_scene 44 0 44 0.0% setting_s.cpp 44 0 44 0.0% setting_s.hpp 0 0 0 100.0% IScene.hpp 0 0 0 100.0% Summary 29 0 29 0.0% Summary 17 0 17 0.0% Summary 0 0 0 100.0% Summary 17 0 17 0.0% Summary 9 0 9 0.0% Summary 36 0 36 0.0% Summary 13 0 13 0.0% Summary 40 0 40 0.0% Summary 38 0 38 0.0% Summary 22 0 22 0.0% Summary 30 0 30 0.0% Summary 179 0 179 0.0% Summary 17 0 17 0.0% Summary 222 0 222 0.0% Summary 89 0 89 0.0% Summary 26 0 26 0.0% Summary 22 0 22 0.0% Summary 25 0 25 0.0% Summary 33 0 33 0.0% Summary 14 0 14 0.0% Summary 44 0 44 0.0% Summary 164 0 164 0.0% Summary 504 0 504 0.0% Summary 504 0 504 0.0%"},{"location":"coverage/client/src/","title":"src","text":"Name Lines Covered Uncovered Coverage Game 29 0 29 0.0% Game.cpp 27 0 27 0.0% Game.hpp 2 0 2 0.0% Objets 222 0 222 0.0% Abstract 17 0 17 0.0% AObjet 17 0 17 0.0% AObjet.cpp 12 0 12 0.0% AObjet.hpp 5 0 5 0.0% IObjet 0 0 0 100.0% IObjet.hpp 0 0 0 100.0% Background 9 0 9 0.0% background.cpp 9 0 9 0.0% background.hpp 0 0 0 100.0% Button 179 0 179 0.0% CostumButton 36 0 36 0.0% costumButton.cpp 31 0 31 0.0% costumButton.hpp 5 0 5 0.0% GeneriqueButton 13 0 13 0.0% generiqueButton.cpp 12 0 12 0.0% generiqueButton.hpp 1 0 1 0.0% JoinRoomButton 40 0 40 0.0% joinRoomButton.cpp 36 0 36 0.0% joinRoomButton.hpp 4 0 4 0.0% SliderVolume 38 0 38 0.0% sliderVolume.cpp 36 0 36 0.0% sliderVolume.hpp 2 0 2 0.0% SpriteButton 22 0 22 0.0% spriteButton.cpp 19 0 19 0.0% spriteButton.hpp 3 0 3 0.0% TextButton 30 0 30 0.0% textButton.cpp 26 0 26 0.0% textButton.hpp 4 0 4 0.0% Text 17 0 17 0.0% text.cpp 12 0 12 0.0% text.hpp 5 0 5 0.0% RessourcesManager 89 0 89 0.0% ressourcesManager.cpp 87 0 87 0.0% ressourcesManager.hpp 2 0 2 0.0% Scene 164 0 164 0.0% Credit_scene 26 0 26 0.0% credit_s.cpp 26 0 26 0.0% credit_s.hpp 0 0 0 100.0% HostGame_scene 22 0 22 0.0% hostGame_s.cpp 22 0 22 0.0% hostGame_s.hpp 0 0 0 100.0% JoinGame_scene 25 0 25 0.0% joinGame_s.cpp 25 0 25 0.0% joinGame_s.hpp 0 0 0 100.0% Menu_scene 33 0 33 0.0% menu_s.cpp 33 0 33 0.0% menu_s.hpp 0 0 0 100.0% SceneManager 14 0 14 0.0% SceneManager.cpp 14 0 14 0.0% SceneManager.hpp 0 0 0 100.0% Setting_scene 44 0 44 0.0% setting_s.cpp 44 0 44 0.0% setting_s.hpp 0 0 0 100.0% IScene.hpp 0 0 0 100.0% Summary 29 0 29 0.0% Summary 17 0 17 0.0% Summary 0 0 0 100.0% Summary 17 0 17 0.0% Summary 9 0 9 0.0% Summary 36 0 36 0.0% Summary 13 0 13 0.0% Summary 40 0 40 0.0% Summary 38 0 38 0.0% Summary 22 0 22 0.0% Summary 30 0 30 0.0% Summary 179 0 179 0.0% Summary 17 0 17 0.0% Summary 222 0 222 0.0% Summary 89 0 89 0.0% Summary 26 0 26 0.0% Summary 22 0 22 0.0% Summary 25 0 25 0.0% Summary 33 0 33 0.0% Summary 14 0 14 0.0% Summary 44 0 44 0.0% Summary 164 0 164 0.0% Summary 504 0 504 0.0%"},{"location":"coverage/client/src/Game/","title":"Game","text":"Name Lines Covered Uncovered Coverage Game.cpp 27 0 27 0.0% Game.hpp 2 0 2 0.0% Summary 29 0 29 0.0%"},{"location":"coverage/client/src/Game/Game.cpp/","title":"Game.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** Game\n*/\n\n#include \"Game.hpp\"\n\nnamespace RType {\n    namespace GUI {\n\n        Game::Game(SceneManager&amp; sceneManager)\n            : _window(std::make_shared&lt;sf::RenderWindow&gt;(sf::VideoMode(1000, 800), \"Main Window\")), _sceneManager(sceneManager), _fpsLimit(60), _volumeSound(100.00f) {\n                initScene();\n        }\n\n        void Game::run() {\n            sf::Clock clock;\n            while (_window-&gt;isOpen()) {\n                sf::Time dt = clock.restart();\n                processEvents();\n                _sceneManager.update(dt);\n                render();\n            }\n        }\n\n        void Game::setFPSLimit(int fps) {\n            _fpsLimit = fps;\n            _window-&gt;setFramerateLimit(_fpsLimit);\n        }\n\n        void Game::initScene() {\n            try {\n                _sceneManager.addScene(\"menu\", std::make_shared&lt;MainMenu&gt;(_sceneManager, _window));\n                _sceneManager.addScene(\"setting\", std::make_shared&lt;Setting&gt;(_sceneManager, _window));\n                _sceneManager.addScene(\"hostGame\", std::make_shared&lt;HostGame&gt;(_sceneManager, _window));\n                _sceneManager.addScene(\"joinGame\", std::make_shared&lt;JoinGame&gt;(_sceneManager, _window));\n                _sceneManager.addScene(\"credit\", std::make_shared&lt;Credit&gt;(_sceneManager, _window));\n                _sceneManager.changeScene(\"menu\");\n                setFPSLimit(_fpsLimit);\n                _menuMusic = ResourceManager::getMusic(\"MenuMusic.wav\");\n                _menuMusic-&gt;setLoop(true);\n                _menuMusic-&gt;play();\n            } catch (const std::exception&amp; e) {\n                std::cerr &lt;&lt; \"Error during scene initialization: \" &lt;&lt; e.what() &lt;&lt; std::endl;\n                throw;\n            }\n        }\n\n        void Game::processEvents() {\n            sf::Event event;\n            while (_window-&gt;pollEvent(event)) {\n                if (event.type == sf::Event::Closed) {\n                    _window-&gt;close();\n                }\n                _sceneManager.handleEvent(event);\n            }\n        }\n\n        void Game::render() {\n            _window-&gt;clear();\n            _sceneManager.render(*_window);\n            _window-&gt;display();\n        }\n\n    }\n}\n</code></pre>"},{"location":"coverage/client/src/Game/Game.hpp/","title":"Game.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** Game\n*/\n\n#ifndef GAME_HPP\n    #define GAME_HPP\n\n#include &lt;SFML/Graphics.hpp&gt;\n#include \"Scene/SceneManager/SceneManager.hpp\"\n#include \"RessourcesManager/ressourcesManager.hpp\"\n#include \"Scene/Menu_scene/menu_s.hpp\"\n#include \"Scene/Setting_scene/setting_s.hpp\"\n#include \"Scene/HostGame_scene/hostGame_s.hpp\"\n#include \"Scene/JoinGame_scene/joinGame_s.hpp\"\n#include \"Scene/Credit_scene/credit_s.hpp\"\n\nnamespace RType {\n    namespace GUI {\n        class Game {\n        public:\n            Game(SceneManager&amp; sceneManager);\n\n            void run();\n            void initScene();\n            void setFPSLimit(int fps);\n            void setVolumeSound(float newVolume) {_volumeSound = newVolume; };\n\n            float getVolumeSound() { return _volumeSound; };\n\n        private:\n            void processEvents();\n            void update(sf::Time dt);\n            void render();\n\n            std::shared_ptr&lt;sf::RenderWindow&gt; _window;\n            SceneManager&amp; _sceneManager;\n            IScene* _currentScene;\n            sf::Music* _menuMusic;\n            float _volumeSound;\n            int _fpsLimit;\n        };\n    }\n}\n\n#endif\n</code></pre>"},{"location":"coverage/client/src/Objets/","title":"Objets","text":"Name Lines Covered Uncovered Coverage Abstract 17 0 17 0.0% AObjet 17 0 17 0.0% AObjet.cpp 12 0 12 0.0% AObjet.hpp 5 0 5 0.0% IObjet 0 0 0 100.0% IObjet.hpp 0 0 0 100.0% Background 9 0 9 0.0% background.cpp 9 0 9 0.0% background.hpp 0 0 0 100.0% Button 179 0 179 0.0% CostumButton 36 0 36 0.0% costumButton.cpp 31 0 31 0.0% costumButton.hpp 5 0 5 0.0% GeneriqueButton 13 0 13 0.0% generiqueButton.cpp 12 0 12 0.0% generiqueButton.hpp 1 0 1 0.0% JoinRoomButton 40 0 40 0.0% joinRoomButton.cpp 36 0 36 0.0% joinRoomButton.hpp 4 0 4 0.0% SliderVolume 38 0 38 0.0% sliderVolume.cpp 36 0 36 0.0% sliderVolume.hpp 2 0 2 0.0% SpriteButton 22 0 22 0.0% spriteButton.cpp 19 0 19 0.0% spriteButton.hpp 3 0 3 0.0% TextButton 30 0 30 0.0% textButton.cpp 26 0 26 0.0% textButton.hpp 4 0 4 0.0% Text 17 0 17 0.0% text.cpp 12 0 12 0.0% text.hpp 5 0 5 0.0% Summary 17 0 17 0.0% Summary 0 0 0 100.0% Summary 17 0 17 0.0% Summary 9 0 9 0.0% Summary 36 0 36 0.0% Summary 13 0 13 0.0% Summary 40 0 40 0.0% Summary 38 0 38 0.0% Summary 22 0 22 0.0% Summary 30 0 30 0.0% Summary 179 0 179 0.0% Summary 17 0 17 0.0% Summary 222 0 222 0.0%"},{"location":"coverage/client/src/Objets/Abstract/","title":"Abstract","text":"Name Lines Covered Uncovered Coverage AObjet 17 0 17 0.0% AObjet.cpp 12 0 12 0.0% AObjet.hpp 5 0 5 0.0% IObjet 0 0 0 100.0% IObjet.hpp 0 0 0 100.0% Summary 17 0 17 0.0% Summary 0 0 0 100.0% Summary 17 0 17 0.0%"},{"location":"coverage/client/src/Objets/Abstract/AObjet/","title":"AObjet","text":"Name Lines Covered Uncovered Coverage AObjet.cpp 12 0 12 0.0% AObjet.hpp 5 0 5 0.0% Summary 17 0 17 0.0%"},{"location":"coverage/client/src/Objets/Abstract/AObjet/AObjet.cpp/","title":"AObjet.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** AObjet Component\n*/\n\n#include \"AObjet.hpp\"\n\nnamespace RType {\n    namespace GUI {\n        namespace Objet {\n            AObjet::AObjet() {\n            }\n\n            AObjet::~AObjet() {\n            }\n\n            void AObjet::destroy() {\n                _isDestroyed = true;\n            }\n\n            void AObjet::draw(sf::RenderWindow&amp; window) const {\n                if (!_isDestroyed) {\n                    window.draw(_shape);\n                }\n            }\n\n            void AObjet::resize(float factor) {\n                _shape.setSize(_shape.getSize() * factor);\n            }\n\n            void AObjet::update(const sf::RenderWindow&amp; window) {\n            }\n\n            void AObjet::setPosition(sf::Vector2f position) {\n                _shape.setPosition(position);\n            }\n\n            void AObjet::setSize(sf::Vector2f size) {\n                _shape.setSize(size);\n            }\n\n            void AObjet::setColor(sf::Color color) {\n                _color = color;\n                _shape.setFillColor(_color);\n            }\n\n            void AObjet::setLabel(const std::string&amp; label) {\n                _label = label;\n            }\n\n            bool RType::GUI::Objet::AObjet::isClicked(const sf::Vector2i&amp; mousePosition) const {\n                if (_isDestroyed)\n                    return false;\n                sf::FloatRect bounds = _shape.getGlobalBounds();\n                return bounds.contains(static_cast&lt;float&gt;(mousePosition.x), static_cast&lt;float&gt;(mousePosition.y));\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"coverage/client/src/Objets/Abstract/AObjet/AObjet.hpp/","title":"AObjet.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** AObjet Component\n*/\n\n#ifndef ABSTRACT_OBJET_HPP_\n    #define ABSTRACT_OBJET_HPP_\n\n#include &lt;SFML/Graphics.hpp&gt;\n#include &lt;iostream&gt;\n\n#include \"Objets/Abstract/IObjet/IObjet.hpp\"\n\nnamespace RType {\n    namespace GUI {\n        namespace Objet {\n            class AObjet: public IObjet {\n                public:\n                    AObjet();\n                    virtual ~AObjet();\n\n                    void destroy() override;\n                    virtual void draw(sf::RenderWindow &amp;window) const override;\n                    virtual void resize(float factor) override;\n                    virtual void update(const sf::RenderWindow&amp; window) override;\n                    virtual bool isClicked(const sf::Vector2i&amp; mousePosition) const override;\n\n                    virtual void setPosition(sf::Vector2f position);\n                    virtual void setSize(sf::Vector2f size);\n                    virtual void setColor(sf::Color color);\n                    virtual void setLabel(const std::string&amp; label);\n\n                    virtual std::string getLabel() const {return _label;};\n                    virtual sf::Vector2f getPosition() const {return _shape.getPosition();};\n                    virtual sf::Vector2f getSize() const {return _shape.getSize();};\n                    virtual sf::Color getColor() const {return _color;};\n                    virtual float getVolume() const { return _volume;}\n\n                protected:\n                    bool _isDestroyed = false;\n                    sf::Color _color = sf::Color::White;\n                    std::string _label;\n                    sf::RectangleShape _shape;\n                    float _volume;\n\n                private:\n                    void updateShape();\n            };\n        }\n    }\n}\n\n#endif /* !ABSTRACT_OBJET_HPP_ */\n</code></pre>"},{"location":"coverage/client/src/Objets/Abstract/IObjet/","title":"IObjet","text":"Name Lines Covered Uncovered Coverage IObjet.hpp 0 0 0 100.0% Summary 0 0 0 100.0%"},{"location":"coverage/client/src/Objets/Abstract/IObjet/IObjet.hpp/","title":"IObjet.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** IObjet Component\n*/\n\n#ifndef INTERFACE_OBJET_HPP_\n    #define INTERFACE_OBJET_HPP_\n\n#include &lt;SFML/Graphics.hpp&gt;\n#include &lt;iostream&gt;\n\nnamespace RType {\n    namespace GUI {\n        namespace Objet {\n            class IObjet {\n                public:\n                    virtual ~IObjet() = default;\n\n                    virtual void destroy() = 0;\n\n                    virtual void draw(sf::RenderWindow &amp;window) const = 0;\n                    virtual void resize(float factor) = 0;\n                    virtual bool isClicked(const sf::Vector2i&amp; mousePosition) const = 0;\n                    virtual void update(const sf::RenderWindow&amp; window) = 0;\n\n                    virtual void setColor(sf::Color color) = 0;\n                    virtual void setPosition(sf::Vector2f position) = 0;\n                    virtual void setSize(sf::Vector2f size) = 0;\n                    virtual void setLabel(const std::string&amp; label) = 0;\n\n                    virtual std::string getLabel() const = 0;\n                    virtual sf::Color getColor() const = 0;\n                    virtual sf::Vector2f getPosition() const = 0;\n                    virtual sf::Vector2f getSize() const = 0;\n            };\n        }\n    }\n}\n\n#endif\n</code></pre>"},{"location":"coverage/client/src/Objets/Background/","title":"Background","text":"Name Lines Covered Uncovered Coverage background.cpp 9 0 9 0.0% background.hpp 0 0 0 100.0% Summary 9 0 9 0.0%"},{"location":"coverage/client/src/Objets/Background/background.cpp/","title":"background.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** Background Component\n*/\n#include \"background.hpp\"\n\nnamespace RType {\n    namespace GUI {\n        namespace Objet {\n\n            Background::Background(std::string texture) {\n                m_texture = &amp;ResourceManager::getTexture(texture);\n                m_sprite.setTexture(*m_texture);\n                m_sprite.setPosition(0, 0);\n            }\n\n            void Background::resize(const sf::Vector2u&amp; windowSize) {\n                if (!m_texture) return;\n                sf::Vector2u textureSize = m_texture-&gt;getSize();\n                float scaleX = static_cast&lt;float&gt;(windowSize.x) / textureSize.x;\n                float scaleY = static_cast&lt;float&gt;(windowSize.y) / textureSize.y;\n                m_sprite.setScale(scaleX, scaleY);\n            }\n\n            void Background::draw(sf::RenderWindow&amp; window) const {\n                window.draw(m_sprite);\n            }\n\n        }\n    }\n}\n</code></pre>"},{"location":"coverage/client/src/Objets/Background/background.hpp/","title":"background.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** Background Component\n*/\n\n#ifndef OBJET_BACKGROUND_HPP_\n    #define OBJET_BACKGROUND_HPP_\n\n#include &lt;SFML/Graphics.hpp&gt;\n#include &lt;string&gt;\n\n#include \"RessourcesManager/ressourcesManager.hpp\"\n\nnamespace RType {\n    namespace GUI {\n        namespace Objet {\n            class Background {\n            public:\n                Background(std::string texture);\n                void draw(sf::RenderWindow&amp; window) const;\n                void resize(const sf::Vector2u&amp; windowSize);\n\n            private:\n                sf::Sprite m_sprite;\n                sf::Texture* m_texture;\n            };\n        }\n    }\n}\n\n#endif\n</code></pre>"},{"location":"coverage/client/src/Objets/Button/","title":"Button","text":"Name Lines Covered Uncovered Coverage CostumButton 36 0 36 0.0% costumButton.cpp 31 0 31 0.0% costumButton.hpp 5 0 5 0.0% GeneriqueButton 13 0 13 0.0% generiqueButton.cpp 12 0 12 0.0% generiqueButton.hpp 1 0 1 0.0% JoinRoomButton 40 0 40 0.0% joinRoomButton.cpp 36 0 36 0.0% joinRoomButton.hpp 4 0 4 0.0% SliderVolume 38 0 38 0.0% sliderVolume.cpp 36 0 36 0.0% sliderVolume.hpp 2 0 2 0.0% SpriteButton 22 0 22 0.0% spriteButton.cpp 19 0 19 0.0% spriteButton.hpp 3 0 3 0.0% TextButton 30 0 30 0.0% textButton.cpp 26 0 26 0.0% textButton.hpp 4 0 4 0.0% Summary 36 0 36 0.0% Summary 13 0 13 0.0% Summary 40 0 40 0.0% Summary 38 0 38 0.0% Summary 22 0 22 0.0% Summary 30 0 30 0.0% Summary 179 0 179 0.0%"},{"location":"coverage/client/src/Objets/Button/CostumButton/","title":"CostumButton","text":"Name Lines Covered Uncovered Coverage costumButton.cpp 31 0 31 0.0% costumButton.hpp 5 0 5 0.0% Summary 36 0 36 0.0%"},{"location":"coverage/client/src/Objets/Button/CostumButton/costumButton.cpp/","title":"costumButton.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** customButton Component\n*/\n\n#include \"costumButton.hpp\"\n\nnamespace RType {\n    namespace GUI {\n        namespace Objet {\n\n            CustomButton::CustomButton(sf::Vector2f position, sf::Vector2f size, const std::string&amp; text, unsigned int charSize, sf::Color color, const std::string&amp; spriteTexture, const std::string&amp; font)\n                : _position(position), _size(size), _color(color), _state(DEFAULT) {\n                    _buttonTexture = ResourceManager::getTexture(spriteTexture);\n                    _buttonSprite.setTexture(_buttonTexture);\n                    _buttonSprite.setColor(_color);\n                    _buttonSprite.setPosition(position);\n                    _buttonSprite.setScale(size.x / _buttonTexture.getSize().x, size.y / _buttonTexture.getSize().y);\n                    _text = std::make_unique&lt;Text&gt;(std::make_pair(position.x, position.y), text, charSize, sf::Color::White, font);\n                    sf::Vector2f textSize = _text-&gt;getSize();\n                    float textX = position.x + (size.x - textSize.x) / 2;\n                    float textY = position.y + (size.y - textSize.y) / 3.5;\n                    _text-&gt;setPosition(sf::Vector2f(textX, textY));\n            }\n\n            void CustomButton::draw(sf::RenderWindow&amp; window) const {\n                window.draw(_buttonSprite);\n                if (_text) {\n                    _text-&gt;draw(window);\n                }\n            }\n\n            void CustomButton::update(const sf::RenderWindow&amp; window) {\n                sf::Vector2i mousePosition = sf::Mouse::getPosition(window);\n                bool isMouseOver = _buttonSprite.getGlobalBounds().contains(static_cast&lt;sf::Vector2f&gt;(mousePosition));\n\n                if (isMouseOver) {\n                    if (_state != HOVER) {\n                        _state = HOVER;\n                        _buttonSprite.setColor(sf::Color(150, 150, 150));\n                    }\n                    if (sf::Mouse::isButtonPressed(sf::Mouse::Left)) {\n                        if (_state != CLICKED) {\n                            _state = CLICKED;\n                            _buttonSprite.setColor(sf::Color(100, 100, 100));\n                            ResourceManager::playSound(\"buttonClick.wav\");\n                        }\n                    }\n                } else {\n                    if (_state != DEFAULT) {\n                        _state = DEFAULT;\n                        _buttonSprite.setColor(_color);\n                    }\n                }\n            }\n\n            bool CustomButton::isClicked(const sf::Vector2i&amp; mousePosition) const {\n                return _buttonSprite.getGlobalBounds().contains(static_cast&lt;sf::Vector2f&gt;(mousePosition));\n            }\n\n            void CustomButton::setPosition(sf::Vector2f position) {\n                _position = position;\n                _buttonSprite.setPosition(position);\n            }\n\n            void CustomButton::setSize(sf::Vector2f size) {\n                _size = size;\n                _buttonSprite.setScale(size.x / _buttonTexture.getSize().x, size.y / _buttonTexture.getSize().y);\n            }\n\n        }\n    }\n}\n</code></pre>"},{"location":"coverage/client/src/Objets/Button/CostumButton/costumButton.hpp/","title":"costumButton.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** customButton Component\n*/\n\n#ifndef BUTTON_OBJET_HPP\n    #define BUTTON_OBJET_HPP\n\n#include &lt;SFML/Graphics.hpp&gt;\n#include &lt;SFML/Audio.hpp&gt;\n#include &lt;functional&gt;\n#include &lt;string&gt;\n#include &lt;memory&gt;\n#include &lt;iostream&gt;\n\n#include \"Objets/Abstract/AObjet/AObjet.hpp\"\n#include \"Objets/Text/text.hpp\"\n#include \"RessourcesManager/ressourcesManager.hpp\"\n\nnamespace RType {\n    namespace GUI {\n        namespace Objet {\n\n            class CustomButton : public AObjet {\n            public:\n                CustomButton(sf::Vector2f position, sf::Vector2f size, const std::string&amp; text, unsigned int charSize, sf::Color color, \n                             const std::string&amp; spriteTexture, const std::string&amp; font);\n\n                void draw(sf::RenderWindow&amp; window) const override;\n                void update(const sf::RenderWindow&amp; window) override;\n                bool isClicked(const sf::Vector2i&amp; mousePosition) const;\n\n                void setPosition(sf::Vector2f position) override;\n                void setSize(sf::Vector2f size) override;\n                void setColor(sf::Color color) override { this-&gt;_color = color; }\n\n                sf::Color getColor() const override { return _color; }\n                sf::Vector2f getPosition() const override { return _position; }\n                sf::Vector2f getSize() const override { return _size; }\n                std::string getLabel() const override { return _text-&gt;getLabel(); }\n\n                enum ButtonState {\n                    DEFAULT,\n                    HOVER,\n                    CLICKED\n                };\n\n            private:\n                sf::Vector2f _position;\n                sf::Vector2f _size;\n                std::unique_ptr&lt;Text&gt; _text;\n                sf::Color _color;\n                sf::Sprite _buttonSprite;\n                sf::Texture _buttonTexture;\n                ButtonState _state;\n            };\n\n        }\n    }\n}\n\n#endif\n</code></pre>"},{"location":"coverage/client/src/Objets/Button/GeneriqueButton/","title":"GeneriqueButton","text":"Name Lines Covered Uncovered Coverage generiqueButton.cpp 12 0 12 0.0% generiqueButton.hpp 1 0 1 0.0% Summary 13 0 13 0.0%"},{"location":"coverage/client/src/Objets/Button/GeneriqueButton/generiqueButton.cpp/","title":"generiqueButton.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** GeneriqueButton Component\n*/\n\n#include \"generiqueButton.hpp\"\n\nnamespace RType {\n    namespace GUI {\n        namespace Objet {\n\n            GeneriqueButton::GeneriqueButton() = default;\n\n            void GeneriqueButton::addButton(std::shared_ptr&lt;AObjet&gt; button) {\n                _buttons.push_back(button);\n            }\n\n            void GeneriqueButton::draw(sf::RenderWindow&amp; window) const {\n                for (const auto&amp; button : _buttons) {\n                    button-&gt;draw(window);\n                }\n            }\n\n            void GeneriqueButton::update(const sf::RenderWindow&amp; window) {\n                for (const auto&amp; button : _buttons) {\n                    button-&gt;update(window);\n                }\n            }\n\n            bool GeneriqueButton::isClicked(const sf::Vector2i&amp; mousePosition) const {\n                for (const auto&amp; button : _buttons) {\n                    if (button-&gt;isClicked(mousePosition)) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n\n            void GeneriqueButton::setPosition(sf::Vector2f position) {\n                sf::Vector2f offset(0, 0);\n                for (const auto&amp; button : _buttons) {\n                    button-&gt;setPosition(position + offset);\n                    offset.y += button-&gt;getSize().y + 10;\n                }\n            }\n\n        }\n    }\n}\n</code></pre>"},{"location":"coverage/client/src/Objets/Button/GeneriqueButton/generiqueButton.hpp/","title":"generiqueButton.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** GeneriqueButton Component\n*/\n\n#ifndef GENERIQUE_BUTTON_HPP\n    #define GENERIQUE_BUTTON_HPP\n\n#include &lt;vector&gt;\n#include &lt;memory&gt;\n#include &lt;SFML/Graphics.hpp&gt;\n#include \"Objets/Abstract/AObjet/AObjet.hpp\"\n#include \"Objets/Button/GeneriqueButton/generiqueButton.hpp\"\n#include \"Objets/Button/TextButton/textButton.hpp\"\n#include \"Objets/Button/SpriteButton/spriteButton.hpp\"\n\nnamespace RType {\n    namespace GUI {\n        namespace Objet {\n\n            class GeneriqueButton : public AObjet {\n            public:\n                GeneriqueButton();\n\n                void addButton(std::shared_ptr&lt;AObjet&gt; button);\n                void draw(sf::RenderWindow&amp; window) const override;\n                void update(const sf::RenderWindow&amp; window) override;\n                bool isClicked(const sf::Vector2i&amp; mousePosition) const override;\n                void setPosition(sf::Vector2f position) override;\n                const std::vector&lt;std::shared_ptr&lt;AObjet&gt;&gt;&amp; getButtons() const { return _buttons; }\n\n            private:\n                std::vector&lt;std::shared_ptr&lt;AObjet&gt;&gt; _buttons;\n            };\n        }\n    }\n}\n\n#endif // COMPOSITE_BUTTON_HPP\n</code></pre>"},{"location":"coverage/client/src/Objets/Button/JoinRoomButton/","title":"JoinRoomButton","text":"Name Lines Covered Uncovered Coverage joinRoomButton.cpp 36 0 36 0.0% joinRoomButton.hpp 4 0 4 0.0% Summary 40 0 40 0.0%"},{"location":"coverage/client/src/Objets/Button/JoinRoomButton/joinRoomButton.cpp/","title":"joinRoomButton.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** JoinRoomButton Object\n*/\n\n#include \"joinRoomButton.hpp\"\n\nnamespace RType {\n    namespace GUI {\n        namespace Objet {\n            JoinRoomButton::JoinRoomButton(const sf::Vector2f&amp; position, const sf::Vector2f&amp; size, const std::string&amp; leftText, const std::string&amp; rightText, const std::string&amp; font, unsigned int charSize)\n                : _state(DEFAULT), _hoverFillColor(sf::Color(128, 128, 128)), _position(position), _size(size) {\n                    _border.setPosition(position);\n                    _border.setSize(size);\n                    _border.setFillColor(sf::Color::Transparent);\n                    _border.setOutlineThickness(2.0f);\n                    _border.setOutlineColor(sf::Color::White);\n\n                    _font = ResourceManager::getFont(font);\n                    _leftText.setFont(_font);\n                    _leftText.setString(leftText);\n                    _leftText.setCharacterSize(charSize);\n                    _leftText.setFillColor(sf::Color::White);\n                    _leftText.setPosition(position.x + 10, position.y + (size.y - charSize) / 2);\n\n                    _rightText.setFont(_font);\n                    _rightText.setString(rightText);\n                    _rightText.setCharacterSize(charSize);\n                    _rightText.setFillColor(sf::Color::White);\n                    _rightText.setPosition(position.x + size.x - _rightText.getGlobalBounds().width - 10, \n                                           position.y + (size.y - charSize) / 2);\n            }\n\n            void JoinRoomButton::draw(sf::RenderWindow&amp; window) const {\n                window.draw(_border);\n                window.draw(_leftText);\n                window.draw(_rightText);\n            }\n\n            void JoinRoomButton::update(const sf::RenderWindow&amp; window) {\n                sf::Vector2i mousePos = sf::Mouse::getPosition(window);\n                bool containsMouse = _border.getGlobalBounds().contains(static_cast&lt;sf::Vector2f&gt;(mousePos));\n\n                if (containsMouse) {\n                    if (_state != HOVER) {\n                        _state = HOVER;\n                        _border.setFillColor(_hoverFillColor);\n                    }\n\n                    if (sf::Mouse::isButtonPressed(sf::Mouse::Left)) {\n                        if (_state != CLICKED) {\n                            _state = CLICKED;\n                            ResourceManager::playSound(\"buttonClick.wav\");\n                        }\n                    } else {\n                        if (_state != HOVER) {\n                            _state = HOVER;\n                        }\n                    }\n                } else {\n                    if (_state != DEFAULT) {\n                        _state = DEFAULT;\n                        _border.setFillColor(sf::Color::Transparent);\n                    }\n                }\n            }\n\n            bool JoinRoomButton::isClicked(const sf::Vector2i&amp; mousePosition) const {\n                return _border.getGlobalBounds().contains(static_cast&lt;sf::Vector2f&gt;(mousePosition));\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"coverage/client/src/Objets/Button/JoinRoomButton/joinRoomButton.hpp/","title":"joinRoomButton.hpp","text":"<pre><code>#ifndef ROOM_BUTTON_HPP\n    #define ROOM_BUTTON_HPP\n\n#include &lt;SFML/Graphics.hpp&gt;\n#include &lt;string&gt;\n#include &lt;memory&gt;\n\n#include \"Objets/Abstract/AObjet/AObjet.hpp\"\n#include \"RessourcesManager/ressourcesManager.hpp\"\n\nnamespace RType {\n    namespace GUI {\n        namespace Objet {\n            class JoinRoomButton : public AObjet {\n            public:\n                JoinRoomButton(const sf::Vector2f&amp; position, const sf::Vector2f&amp; size, const std::string&amp; leftText, \n                           const std::string&amp; rightText, const std::string&amp; font, unsigned int charSize);\n\n                void draw(sf::RenderWindow&amp; window) const;\n                void update(const sf::RenderWindow&amp; window);\n                bool isClicked(const sf::Vector2i&amp; mousePosition) const;\n\n                sf::Text getLabel() { return _rightText; };\n                sf::Text getNbPlayerInRoom() { return _leftText; };\n                sf::Vector2f getPosition() const override { return _position; }\n                sf::Vector2f getSize() const override { return _size; }\n\n                enum ButtonState {\n                    DEFAULT,\n                    HOVER,\n                    CLICKED\n                };\n\n            private:\n                sf::RectangleShape _border;\n                sf::Text _leftText;\n                sf::Text _rightText;\n                sf::Font _font;\n                ButtonState _state;\n                sf::Vector2f _position;\n                sf::Vector2f _size;\n\n                sf::Color _hoverFillColor;\n                sf::Color _clickFillColor;  // Couleur au clic\n            };\n        }\n    }\n}\n\n#endif\n</code></pre>"},{"location":"coverage/client/src/Objets/Button/SliderVolume/","title":"SliderVolume","text":"Name Lines Covered Uncovered Coverage sliderVolume.cpp 36 0 36 0.0% sliderVolume.hpp 2 0 2 0.0% Summary 38 0 38 0.0%"},{"location":"coverage/client/src/Objets/Button/SliderVolume/sliderVolume.cpp/","title":"sliderVolume.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** SliderVolume Component\n*/\n\n#include \"sliderVolume.hpp\"\n\nnamespace RType {\n    namespace GUI {\n        namespace Objet {\n\n            SliderVolume::SliderVolume(float x, float y, float width, float height, const std::string label)\n                : _volume(50.0f), _isDragging(false), _label(label) {\n                    _font = ResourceManager::getFont(\"Arial.ttf\");\n                    _background.setSize(sf::Vector2f(width, height));\n                    _background.setPosition(x, y);\n                    _background.setFillColor(sf::Color(200, 200, 200));\n                    _background.setOutlineThickness(2);\n                    _background.setOutlineColor(sf::Color(150, 150, 150));\n                    _slider.setSize(sf::Vector2f(10, height));\n                    _slider.setPosition(x + (width * (_volume / 100.0f)), y);\n                    _slider.setFillColor(sf::Color::Red);\n                    _volumeText.setFont(_font);\n                    _volumeText.setCharacterSize(20);\n                    _volumeText.setFillColor(sf::Color::White);\n                    updateText();\n                    _volumeText.setPosition(x + width + 10, y);\n            }\n\n            SliderVolume::~SliderVolume() {}\n\n            void SliderVolume::update(const sf::RenderWindow&amp; window) {\n                sf::Vector2i mousePos = sf::Mouse::getPosition(window);\n                if (_isDragging)\n                    updateVolume(window);\n                if (sf::Mouse::isButtonPressed(sf::Mouse::Left)) {\n                    sf::FloatRect bounds = _slider.getGlobalBounds();\n                    if (bounds.contains(static_cast&lt;sf::Vector2f&gt;(mousePos))) {\n                        _isDragging = true;\n                    }\n                } else {\n                    _isDragging = false;\n                }\n                updateText();\n            }\n\n            void SliderVolume::draw(sf::RenderWindow&amp; window) const {\n                window.draw(_background);\n                window.draw(_slider);\n                window.draw(_volumeText);\n            }\n\n            void SliderVolume::setVolume(float volume) {\n                _volume = volume;\n                updateText();\n            }\n\n            void SliderVolume::updateVolume(const sf::RenderWindow&amp; window) {\n                sf::Vector2i mousePos = sf::Mouse::getPosition(window);\n                sf::FloatRect bounds = _background.getGlobalBounds();\n\n                if (bounds.contains(static_cast&lt;sf::Vector2f&gt;(mousePos))) {\n                    float newVolume = (mousePos.x - bounds.left) / bounds.width * 100.0f;\n                    newVolume = std::max(0.0f, std::min(100.0f, newVolume));\n                    _volume = newVolume;\n                    _slider.setPosition(bounds.left + (bounds.width * (_volume / 100.0f)), bounds.top);\n                }\n            }\n\n            void SliderVolume::updateText() {\n                _volumeText.setString(std::to_string(static_cast&lt;int&gt;(_volume)) + \"%\");\n            }\n\n        }\n    }\n}\n</code></pre>"},{"location":"coverage/client/src/Objets/Button/SliderVolume/sliderVolume.hpp/","title":"sliderVolume.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** SliderVolume Component\n*/\n\n#ifndef SLIDERVOLUME_HPP\n    #define SLIDERVOLUME_HPP\n\n#include &lt;SFML/Graphics.hpp&gt;\n#include &lt;SFML/Audio.hpp&gt;\n#include \"Objets/Abstract/AObjet/AObjet.hpp\"\n#include \"RessourcesManager/ressourcesManager.hpp\"\n\nnamespace RType {\n    namespace GUI {\n        namespace Objet {\n\n            class SliderVolume : public AObjet {\n            public:\n                SliderVolume(float x, float y, float width, float height, const std::string label);\n                ~SliderVolume();\n\n                void update(const sf::RenderWindow&amp; window);\n                void draw(sf::RenderWindow&amp; window) const;\n\n                void setVolume(float volume);\n                float getVolume() const { return _volume; };\n                std::string getLabel() const override { return _label; };\n\n            private:\n                sf::RectangleShape _background;\n                sf::RectangleShape _slider;\n                sf::Text _volumeText;\n                sf::Font _font;\n                std::string _label;\n                float _volume;\n                bool _isDragging;\n\n                void updateVolume(const sf::RenderWindow&amp; window);\n                void updateText();\n            };\n\n        }\n    }\n}\n\n#endif\n</code></pre>"},{"location":"coverage/client/src/Objets/Button/SpriteButton/","title":"SpriteButton","text":"Name Lines Covered Uncovered Coverage spriteButton.cpp 19 0 19 0.0% spriteButton.hpp 3 0 3 0.0% Summary 22 0 22 0.0%"},{"location":"coverage/client/src/Objets/Button/SpriteButton/spriteButton.cpp/","title":"spriteButton.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** SpriteButton Component\n*/\n\n#include \"spriteButton.hpp\"\n\nnamespace RType {\n    namespace GUI {\n        namespace Objet {\n\n            SpriteButton::SpriteButton(sf::Vector2f position, sf::Vector2f size, const std::string&amp; textureFile, const std::string label)\n                : _size(size), _position(position), _label(label) {\n                    _texture = ResourceManager::getTexture(textureFile);\n                    _sprite.setTexture(_texture);\n                    _sprite.setPosition(position);\n                    _sprite.setScale(size.x / _texture.getSize().x, size.y / _texture.getSize().y);\n                    _originalColor = _sprite.getColor();\n                    _hoverColor = sf::Color(200, 200, 200);\n                    _clickedColor = sf::Color(150, 150, 150);\n            }\n\n            void SpriteButton::draw(sf::RenderWindow&amp; window) const {\n                window.draw(_sprite);\n            }\n\n            void SpriteButton::update(const sf::RenderWindow&amp; window) {\n                sf::Vector2i mousePos = sf::Mouse::getPosition(window);\n                bool isHovered = _sprite.getGlobalBounds().contains(static_cast&lt;sf::Vector2f&gt;(mousePos));\n\n                if (isHovered) {\n                    if (sf::Mouse::isButtonPressed(sf::Mouse::Left)) {\n                        _sprite.setColor(_clickedColor);\n                        ResourceManager::playSound(\"buttonClick.wav\");\n                    } else {\n                        _sprite.setColor(_hoverColor);\n                    }\n                } else {\n                    _sprite.setColor(_originalColor);\n                }\n            }\n\n            void SpriteButton::setPosition(sf::Vector2f position) {\n                _sprite.setPosition(position);\n            }\n\n            void SpriteButton::setSize(sf::Vector2f size) {\n                _sprite.setScale(size.x / _texture.getSize().x, size.y / _texture.getSize().y);\n            }\n\n            bool SpriteButton::isClicked(const sf::Vector2i&amp; mousePosition) const {\n                return _sprite.getGlobalBounds().contains(static_cast&lt;sf::Vector2f&gt;(mousePosition));\n            }\n\n        }\n    }\n}\n</code></pre>"},{"location":"coverage/client/src/Objets/Button/SpriteButton/spriteButton.hpp/","title":"spriteButton.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** SpriteButton Component\n*/\n\n#ifndef SPRITE_BUTTON_HPP\n    #define SPRITE_BUTTON_HPP\n\n#include &lt;SFML/Graphics.hpp&gt;\n#include \"Objets/Abstract/AObjet/AObjet.hpp\"\n\n#include \"RessourcesManager/ressourcesManager.hpp\"\n\nnamespace RType {\n    namespace GUI {\n        namespace Objet {\n            class SpriteButton : public AObjet {\n            public:\n                SpriteButton(sf::Vector2f position, sf::Vector2f size, const std::string&amp; textureFile, const std::string label);\n\n                void draw(sf::RenderWindow&amp; window) const override;\n                void update(const sf::RenderWindow&amp; window) override;\n                void setPosition(sf::Vector2f position) override;\n                void setSize(sf::Vector2f size) override;\n\n                bool isClicked(const sf::Vector2i&amp; mousePosition) const override;\n\n                sf::Vector2f getPosition() const override { return _position; }\n                sf::Vector2f getSize() const override { return _size; }\n                std::string getLabel() const override { return _label; }\n\n            private:\n                std::string _label;\n                sf::Sprite _sprite;\n                sf::Texture _texture;\n                sf::Vector2f _position;\n                sf::Vector2f _size;\n                sf::Color _originalColor = _sprite.getColor();\n                sf::Color _hoverColor = sf::Color(200, 200, 200);\n                sf::Color _clickedColor = sf::Color(150, 150, 150);\n            };\n        }\n    }\n}\n\n#endif\n</code></pre>"},{"location":"coverage/client/src/Objets/Button/TextButton/","title":"TextButton","text":"Name Lines Covered Uncovered Coverage textButton.cpp 26 0 26 0.0% textButton.hpp 4 0 4 0.0% Summary 30 0 30 0.0%"},{"location":"coverage/client/src/Objets/Button/TextButton/textButton.cpp/","title":"textButton.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** ButtonText Component\n*/\n\n#include \"textButton.hpp\"\n\nnamespace RType {\n    namespace GUI {\n        namespace Objet {\n\n            TextButton::TextButton(sf::Vector2f position, const std::string&amp; text, unsigned int charSize, sf::Color defaultColor, sf::Color hoverColor, sf::Color clickedColor, const std::string&amp; font)\n                : _position(position), _defaultColor(defaultColor), _hoverColor(hoverColor), _clickedColor(clickedColor), _state(DEFAULT) {\n                    _text = std::make_unique&lt;Text&gt;(std::make_pair(position.x, position.y), text, charSize, defaultColor, font);\n            }\n\n            void TextButton::draw(sf::RenderWindow&amp; window) const {\n                if (_text) {\n                    _text-&gt;draw(window);\n                }\n            }\n\n            void TextButton::update(const sf::RenderWindow&amp; window) {\n                sf::Vector2i mousePosition = sf::Mouse::getPosition(window);\n                sf::Vector2f mousePosF(static_cast&lt;float&gt;(mousePosition.x), static_cast&lt;float&gt;(mousePosition.y));\n                sf::FloatRect buttonBounds = _text-&gt;getBounds();\n                bool isMouseOver = buttonBounds.contains(mousePosF);\n\n                if (isMouseOver) {\n                    if (_state != CLICKED &amp;&amp; sf::Mouse::isButtonPressed(sf::Mouse::Left)) {\n                        _state = CLICKED;\n                        _text-&gt;setColor(_clickedColor);\n                        ResourceManager::playSound(\"buttonClick.wav\");\n                    } else if (_state != CLICKED) {\n                        _state = HOVER;\n                        _text-&gt;setColor(_hoverColor);\n                    }\n                } else if (_state != DEFAULT) {\n                    _state = DEFAULT;\n                    _text-&gt;setColor(_defaultColor);\n                }\n                if (!sf::Mouse::isButtonPressed(sf::Mouse::Left) &amp;&amp; _state == CLICKED) {\n                    _state = DEFAULT;\n                    _text-&gt;setColor(_defaultColor);\n                }\n            }\n\n            bool TextButton::isClicked(const sf::Vector2i&amp; mousePosition) const {\n                sf::FloatRect buttonBounds = _text-&gt;getBounds();\n                return buttonBounds.contains(static_cast&lt;sf::Vector2f&gt;(mousePosition));\n            }\n\n            void TextButton::setPosition(sf::Vector2f position) {\n                _position = position;\n                _text-&gt;setPosition(position);\n            }\n\n            void TextButton::setColor(sf::Color color) {\n                _defaultColor = color;\n                _text-&gt;setColor(color);\n            }\n\n        }\n    }\n}\n</code></pre>"},{"location":"coverage/client/src/Objets/Button/TextButton/textButton.hpp/","title":"textButton.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** TexteButton Component\n*/\n\n#ifndef TEXT_BUTTON_HPP\n    #define TEXT_BUTTON_HPP\n\n#include &lt;SFML/Graphics.hpp&gt;\n#include &lt;SFML/Audio.hpp&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n\n#include \"Objets/Abstract/AObjet/AObjet.hpp\"\n#include \"Objets/Text/text.hpp\"\n\nnamespace RType {\n    namespace GUI {\n        namespace Objet {\n\n            class TextButton : public AObjet {\n            public:\n                TextButton(sf::Vector2f position, const std::string&amp; text, unsigned int charSize,\n                           sf::Color defaultColor, sf::Color hoverColor, sf::Color clickedColor, const std::string&amp; font);\n\n                void draw(sf::RenderWindow&amp; window) const override;\n                void update(const sf::RenderWindow&amp; window) override;\n\n                bool isClicked(const sf::Vector2i&amp; mousePosition) const override;\n\n                void setPosition(sf::Vector2f position) override;\n                void setColor(sf::Color color) override;\n\n                sf::Vector2f getPosition() const override { return _text-&gt;getPosition(); }\n                sf::Vector2f getSize() const override { return sf::Vector2f(_text-&gt;getBounds().width, _text-&gt;getBounds().height); }\n                sf::Color getColor() const override { return _text-&gt;getColor(); }\n                std::string getLabel() const override { return _text-&gt;getLabel(); }\n\n            private:\n                sf::Vector2f _position;\n                std::unique_ptr&lt;Text&gt; _text;\n                sf::Color _defaultColor;\n                sf::Color _hoverColor;\n                sf::Color _clickedColor;\n\n                enum ButtonState {\n                    DEFAULT,\n                    HOVER,\n                    CLICKED\n                };\n\n                ButtonState _state;\n            };\n\n        }\n    }\n}\n\n#endif\n</code></pre>"},{"location":"coverage/client/src/Objets/Text/","title":"Text","text":"Name Lines Covered Uncovered Coverage text.cpp 12 0 12 0.0% text.hpp 5 0 5 0.0% Summary 17 0 17 0.0%"},{"location":"coverage/client/src/Objets/Text/text.cpp/","title":"text.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** Text Object\n*/\n#include \"text.hpp\"\n\nnamespace RType {\n    namespace GUI {\n        namespace Objet {\n            Text::Text(std::pair&lt;float, float&gt; position, const std::string&amp; text, unsigned int charSize, const sf::Color&amp; color, const std::string&amp; fontType) {\n                _font = ResourceManager::getFont(fontType);\n                _text.setFont(_font);\n                _text.setString(text);\n                _text.setCharacterSize(charSize);\n                _text.setFillColor(color);\n                _text.setPosition(position.first, position.second);\n                _fontSize = charSize;\n            }\n\n            void Text::draw(sf::RenderWindow&amp; window) const {\n                window.draw(_text);\n            }\n\n            void Text::resize(float factor) {\n                _text.setCharacterSize(_fontSize);\n            }\n\n            void Text::setPosition(sf::Vector2f position) {\n                _text.setPosition(position);\n            }\n\n            void Text::setColor(sf::Color color) {\n                _text.setFillColor(color);\n            }\n\n            void Text::setLabel(const std::string&amp; label) {\n                _text.setString(sf::String::fromUtf8(label.begin(), label.end()));\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"coverage/client/src/Objets/Text/text.hpp/","title":"text.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** Text Object\n*/\n#ifndef TEXT_HPP\n    #define TEXT_HPP\n\n#include &lt;SFML/Graphics.hpp&gt;\n#include &lt;string&gt;\n\n#include \"Objets/Abstract/AObjet/AObjet.hpp\"\n#include \"RessourcesManager/ressourcesManager.hpp\"\n\nnamespace RType {\n    namespace GUI {\n        namespace Objet {\n\n            class Text : public AObjet {\n            public:\n                Text(std::pair&lt;float, float&gt; position, const std::string&amp; text, unsigned int charSize, const sf::Color&amp; color, const std::string&amp; fontType);\n\n                void draw(sf::RenderWindow&amp; window) const override;\n                void resize(float factor);\n\n                void setColor(sf::Color color) override;\n                void setPosition(sf::Vector2f position) override;\n                void setLabel(const std::string&amp; label);\n\n                std::string getLabel() const override { return _text.getString(); }\n                sf::Color getColor() const override { return _text.getFillColor(); }\n                sf::Vector2f getPosition() const override { return _text.getPosition(); }\n                sf::Vector2f getSize() const override { return sf::Vector2f(_text.getGlobalBounds().width, _text.getGlobalBounds().height); }\n                sf::FloatRect getBounds() const { return _text.getGlobalBounds(); }\n\n            private:\n                sf::Text _text;\n                sf::Font _font;\n                int _fontSize;\n            };\n\n        }\n    }\n}\n\n#endif\n</code></pre>"},{"location":"coverage/client/src/RessourcesManager/","title":"RessourcesManager","text":"Name Lines Covered Uncovered Coverage ressourcesManager.cpp 87 0 87 0.0% ressourcesManager.hpp 2 0 2 0.0% Summary 89 0 89 0.0%"},{"location":"coverage/client/src/RessourcesManager/ressourcesManager.cpp/","title":"ressourcesManager.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** Ressource Manager\n*/\n\n#include \"ressourcesManager.hpp\"\n\nnamespace RType {\n    namespace GUI {\n\n        std::unordered_map&lt;std::string, sf::Texture&gt; ResourceManager::_textures;\n        std::unordered_map&lt;std::string, sf::Font&gt; ResourceManager::_fonts;\n        std::unordered_map&lt;std::string, std::unique_ptr&lt;sf::Music&gt;&gt; ResourceManager::_musics;\n        std::unordered_map&lt;std::string, sf::SoundBuffer&gt; ResourceManager::_sounds;\n        std::unordered_map&lt;std::string, sf::Sound&gt; ResourceManager::_activeSounds;\n        bool ResourceManager::_soundEnabled = true;\n        bool ResourceManager::_musicEnabled = true;\n\n        void ResourceManager::loadAllResources() {\n            loadTexture(\"backgroundMenu.jpg\", \"assets/background/backgroundMenu.jpg\");\n            loadTexture(\"backgroundSetting.jpg\", \"assets/background/backgroundSetting.jpg\");\n            loadTexture(\"logo.png\", \"assets/logo/Epitech_logo.png\");\n            loadTexture(\"Arnaud.png\", \"assets/credit/Arnaud.png\");\n            loadTexture(\"Clement.png\", \"assets/credit/Clement.jpg\");\n            loadTexture(\"Alexandre.png\", \"assets/credit/Alexandre.png\");\n            loadTexture(\"Jule.png\", \"assets/credit/Jule.png\");\n            loadTexture(\"Lucas.png\", \"assets/credit/Lucas.jpg\");\n            loadTexture(\"button.png\", \"assets/button/button.png\");\n            loadTexture(\"button2.png\", \"assets/button/button2.png\");\n            loadTexture(\"backButton.png\", \"assets/button/backButton.png\");\n            loadFont(\"Arial.ttf\", \"assets/fonts/arial.ttf\");\n            loadMusic(\"MenuMusic.wav\", \"assets/music/MenuMusic.wav\");\n            loadSound(\"buttonClick.wav\", \"assets/sounds/buttonClick.wav\");\n        }\n\n        void ResourceManager::clearResources() {\n            _textures.clear();\n            _fonts.clear();\n            _musics.clear();\n            _sounds.clear();\n            _activeSounds.clear();\n        }\n\n        //////////////////////////////////// TEXTURES ////////////////////////////////////\n\n        bool ResourceManager::loadTexture(const std::string&amp; textureLabel, const std::string&amp; filename) {\n            if (isTextureLoaded(textureLabel))\n                return true;\n            sf::Texture texture;\n            if (!texture.loadFromFile(filename)) {\n                std::cerr &lt;&lt; \"Failed to load texture: \" &lt;&lt; filename &lt;&lt; std::endl;\n                return false;\n            }\n            _textures[textureLabel] = std::move(texture);\n            return true;\n        }\n\n        sf::Texture&amp; ResourceManager::getTexture(const std::string&amp; textureLabel) {\n            auto thisTexture = _textures.find(textureLabel);\n            if (thisTexture == _textures.end()) {\n                throw std::runtime_error(\"Texture not found: \" + textureLabel);\n            }\n            return thisTexture-&gt;second;\n        }\n\n        bool ResourceManager::isTextureLoaded(const std::string&amp; textureLabel) {\n            return _textures.find(textureLabel) != _textures.end();\n        }\n\n        //////////////////////////////////// FONTS ///////////////////////////////////////\n\n        bool ResourceManager::loadFont(const std::string&amp; fontLabel, const std::string&amp; filename) {\n            if (isFontLoaded(fontLabel))\n                return true;\n            sf::Font font;\n            if (!font.loadFromFile(filename)) {\n                std::cerr &lt;&lt; \"Failed to load font: \" &lt;&lt; filename &lt;&lt; std::endl;\n                return false;\n            }\n            _fonts[fontLabel] = std::move(font);\n            return true;\n        }\n\n        sf::Font&amp; ResourceManager::getFont(const std::string&amp; fontLabel) {\n            auto thisFont = _fonts.find(fontLabel);\n            if (thisFont == _fonts.end()) {\n                throw std::runtime_error(\"Font not found: \" + fontLabel);\n            }\n            return thisFont-&gt;second;\n        }\n\n        bool ResourceManager::isFontLoaded(const std::string&amp; fontLabel) {\n            return _fonts.find(fontLabel) != _fonts.end();\n        }\n\n        //////////////////////////////////// MUSIC ///////////////////////////////////////\n\n        bool ResourceManager::loadMusic(const std::string&amp; musicLabel, const std::string&amp; filename) {\n            if (isMusicLoaded(musicLabel))\n                return true;\n            auto music = std::make_unique&lt;sf::Music&gt;();\n            if (!music-&gt;openFromFile(filename)) {\n                std::cerr &lt;&lt; \"Failed to load music: \" &lt;&lt; filename &lt;&lt; std::endl;\n                return false;\n            }\n            music-&gt;setVolume(100);\n            _musics[musicLabel] = std::move(music);\n            return true;\n        }\n\n        sf::Music* ResourceManager::getMusic(const std::string&amp; musicLabel) {\n            auto thisMusic = _musics.find(musicLabel);\n            if (thisMusic == _musics.end()) {\n                throw std::runtime_error(\"Music not found: \" + musicLabel);\n            }\n            return thisMusic-&gt;second.get();\n        }\n\n        bool ResourceManager::isMusicLoaded(const std::string&amp; musicLabel) {\n            return _musics.find(musicLabel) != _musics.end();\n        }\n\n        void ResourceManager::updateMusicVolume(const std::string&amp; musicLabel, float volume) {\n            sf::Music* music = getMusic(musicLabel);\n            if (music) {\n                music-&gt;setVolume(volume);\n            }\n        }\n\n        //////////////////////////////////// SOUNDS ///////////////////////////////////////\n\n        bool ResourceManager::loadSound(const std::string&amp; soundLabel, const std::string&amp; filename) {\n            if (isSoundLoaded(soundLabel))\n                return true;\n            sf::SoundBuffer soundBuffer;\n            if (!soundBuffer.loadFromFile(filename)) {\n                std::cerr &lt;&lt; \"Failed to load sound: \" &lt;&lt; filename &lt;&lt; std::endl;\n                return false;\n            }\n            _sounds[soundLabel] = std::move(soundBuffer);\n            return true;\n        }\n\n        sf::SoundBuffer&amp; ResourceManager::getSound(const std::string&amp; soundLabel) {\n            auto thisSound = _sounds.find(soundLabel);\n            if (thisSound == _sounds.end()) {\n                throw std::runtime_error(\"Sound not found: \" + soundLabel);\n            }\n            return thisSound-&gt;second;\n        }\n\n        bool ResourceManager::isSoundLoaded(const std::string&amp; soundLabel) {\n            return _sounds.find(soundLabel) != _sounds.end();\n        }\n\n        void ResourceManager::playSound(const std::string&amp; soundLabel) {\n            if (!_soundEnabled)\n                return;\n            if (!isSoundLoaded(soundLabel))\n                loadSound(soundLabel, soundLabel);\n            if (_activeSounds.find(soundLabel) != _activeSounds.end()) {\n                _activeSounds[soundLabel].play();\n            } else {\n                sf::Sound sound;\n                sound.setBuffer(getSound(soundLabel));\n                sound.setVolume(100.f);\n                sound.play();\n                _activeSounds[soundLabel] = std::move(sound);\n            }\n        }\n\n        void ResourceManager::updateAllSoundsVolume(float volume) {\n            for (auto&amp; [label, sound] : _activeSounds) {\n                sound.setVolume(volume);\n            }\n        }\n\n        void ResourceManager::clearInactiveSounds() {\n            for (auto it = _activeSounds.begin(); it != _activeSounds.end();) {\n                if (it-&gt;second.getStatus() != sf::Sound::Playing) {\n                    it = _activeSounds.erase(it);\n                } else {\n                    ++it;\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"coverage/client/src/RessourcesManager/ressourcesManager.hpp/","title":"ressourcesManager.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** Ressource Manager Header\n*/\n\n#ifndef RESOURCE_MANAGER_HPP\n    #define RESOURCE_MANAGER_HPP\n\n#include &lt;SFML/Graphics.hpp&gt;\n#include &lt;SFML/Audio.hpp&gt;\n#include &lt;unordered_map&gt;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nnamespace RType {\n    namespace GUI {\n        class ResourceManager {\n        public:\n            static void loadAllResources();\n            static void clearResources();\n\n            // Handle textures\n            static bool loadTexture(const std::string&amp; textureLabel, const std::string&amp; filename);\n            static sf::Texture&amp; getTexture(const std::string&amp; textureLabel);\n            static bool isTextureLoaded(const std::string&amp; textureLabel);\n\n            // Handle fonts\n            static bool loadFont(const std::string&amp; fontLabel, const std::string&amp; filename);\n            static sf::Font&amp; getFont(const std::string&amp; fontLabel);\n            static bool isFontLoaded(const std::string&amp; fontLabel);\n\n            // Handle music\n            static bool loadMusic(const std::string&amp; musicLabel, const std::string&amp; filename);\n            static sf::Music* getMusic(const std::string&amp; musicLabel);\n            static bool isMusicLoaded(const std::string&amp; musicLabel);\n            static void updateMusicVolume(const std::string&amp; musicLabel, float volume);\n            static void toggleMusic(bool enabled){_musicEnabled = enabled;};\n\n            // Handle sounds\n            static bool loadSound(const std::string&amp; soundLabel, const std::string&amp; filename);\n            static sf::SoundBuffer&amp; getSound(const std::string&amp; soundLabel);\n            static bool isSoundLoaded(const std::string&amp; soundLabel);\n            static void playSound(const std::string&amp; soundLabel);\n            static void updateAllSoundsVolume(float volume);\n            static void clearInactiveSounds();\n            static void toggleSounds(bool enabled){_soundEnabled = enabled;};\n\n        private:\n            static std::unordered_map&lt;std::string, sf::Texture&gt; _textures;\n            static std::unordered_map&lt;std::string, sf::Font&gt; _fonts;\n            static std::unordered_map&lt;std::string, std::unique_ptr&lt;sf::Music&gt;&gt; _musics;\n            static std::unordered_map&lt;std::string, sf::SoundBuffer&gt; _sounds;\n            static std::unordered_map&lt;std::string, sf::Sound&gt; _activeSounds;\n            static bool _soundEnabled;\n            static bool _musicEnabled;\n        };\n    }\n}\n\n#endif\n</code></pre>"},{"location":"coverage/client/src/Scene/","title":"Scene","text":"Name Lines Covered Uncovered Coverage Credit_scene 26 0 26 0.0% credit_s.cpp 26 0 26 0.0% credit_s.hpp 0 0 0 100.0% HostGame_scene 22 0 22 0.0% hostGame_s.cpp 22 0 22 0.0% hostGame_s.hpp 0 0 0 100.0% JoinGame_scene 25 0 25 0.0% joinGame_s.cpp 25 0 25 0.0% joinGame_s.hpp 0 0 0 100.0% Menu_scene 33 0 33 0.0% menu_s.cpp 33 0 33 0.0% menu_s.hpp 0 0 0 100.0% SceneManager 14 0 14 0.0% SceneManager.cpp 14 0 14 0.0% SceneManager.hpp 0 0 0 100.0% Setting_scene 44 0 44 0.0% setting_s.cpp 44 0 44 0.0% setting_s.hpp 0 0 0 100.0% IScene.hpp 0 0 0 100.0% Summary 26 0 26 0.0% Summary 22 0 22 0.0% Summary 25 0 25 0.0% Summary 33 0 33 0.0% Summary 14 0 14 0.0% Summary 44 0 44 0.0% Summary 164 0 164 0.0%"},{"location":"coverage/client/src/Scene/IScene.hpp/","title":"IScene.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** IScene\n*/\n\n#ifndef ISCENE_HPP\n    #define ISCENE_HPP\n\n#include &lt;SFML/Graphics.hpp&gt;\n\nnamespace RType {\n    namespace GUI {\n        class IScene {\n        public:\n            virtual ~IScene() {}\n\n            virtual void nextScene(const std::string&amp; sceneName) = 0;\n            virtual void handleEvent(const sf::Event&amp; event) = 0;\n            virtual void update(sf::Time dt) = 0;\n            virtual void render(sf::RenderWindow&amp; window) = 0;\n            virtual void resize(sf::RenderWindow&amp; window, const sf::Vector2u&amp; baseSize) = 0;\n        };\n    }\n}\n\n#endif\n</code></pre>"},{"location":"coverage/client/src/Scene/Credit_scene/","title":"Credit_scene","text":"Name Lines Covered Uncovered Coverage credit_s.cpp 26 0 26 0.0% credit_s.hpp 0 0 0 100.0% Summary 26 0 26 0.0%"},{"location":"coverage/client/src/Scene/Credit_scene/credit_s.cpp/","title":"credit_s.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** credit Scene\n*/\n\n#include \"credit_s.hpp\"\n\nnamespace RType {\n    namespace GUI {\n\n        Credit::Credit(SceneManager&amp; sceneManager, std::shared_ptr&lt;sf::RenderWindow&gt;&amp; window)\n            : c_sceneManager(sceneManager), c_background(nullptr), c_window(window) {\n            c_background = std::make_unique&lt;Objet::Background&gt;(\"backgroundMenu.jpg\");\n            c_texts.emplace_back(std::make_unique&lt;Objet::Text&gt;(std::make_pair(100.0f, 50.0f), \"Cr\u00e9dits\", 40, sf::Color::White, \"Arial.ttf\"));\n            c_generiqueButton.addButton(std::make_shared&lt;Objet::SpriteButton&gt;(\n                sf::Vector2f(0.0f, 0.0f),\n                sf::Vector2f(100.0f, 30.0f),\n                \"backButton.png\", \"backButton\"\n            ));\n\n            sf::Texture&amp; logoTexture = ResourceManager::getTexture(\"Arnaud.png\");\n            c_logoSprite.setTexture(logoTexture);\n            c_logoSprite.setPosition(400.f, 50.f);\n\n        }\n\n        void Credit::handleEvent(const sf::Event&amp; event) {\n            if (event.type == sf::Event::MouseButtonPressed &amp;&amp; event.mouseButton.button == sf::Mouse::Left) {\n                sf::Vector2i mousePosition(event.mouseButton.x, event.mouseButton.y);\n                if (c_generiqueButton.isClicked(mousePosition)) {\n                    for (const auto&amp; button : c_generiqueButton.getButtons()) {\n                        if (button-&gt;isClicked(mousePosition)) {\n                            const std::string&amp; label = button-&gt;getLabel();\n                            if (label == \"Settings\") {\n                                nextScene(\"setting\");\n                            }\n                            if (label == \"backButton\") {\n                                nextScene(\"menu\");\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        void Credit::resize(sf::RenderWindow&amp; window, const sf::Vector2u&amp; baseSize) {\n        }\n\n        void Credit::update(sf::Time dt) {\n        }\n\n        void Credit::render(sf::RenderWindow&amp; window) {\n            c_background-&gt;draw(window);\n            window.draw(c_logoSprite);\n            c_generiqueButton.update(*c_window);\n            c_generiqueButton.draw(window);\n            for (const auto&amp; text : c_texts) {\n                text-&gt;draw(window);\n            }\n        }\n\n        void Credit::nextScene(const std::string&amp; sceneName) {\n            c_sceneManager.changeScene(sceneName);\n        }\n    }\n}\n</code></pre>"},{"location":"coverage/client/src/Scene/Credit_scene/credit_s.hpp/","title":"credit_s.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** credit Scene\n*/\n\n#ifndef CREDIT_SCENE_HPP\n    #define CREDIT_SCENE_HPP\n\n    #include &lt;SFML/Graphics.hpp&gt;\n    #include &lt;iostream&gt;\n    #include &lt;memory&gt;\n    #include &lt;vector&gt;\n\n    #include \"Scene/IScene.hpp\"\n    #include \"Objets/Button/TextButton/textButton.hpp\"\n    #include \"Objets/Button/SpriteButton/spriteButton.hpp\"\n    #include \"Objets/Button/GeneriqueButton/generiqueButton.hpp\"\n    #include \"Scene/SceneManager/SceneManager.hpp\"\n    #include \"Objets/Background/background.hpp\"\n\nnamespace RType {\n    namespace GUI {\n        class Credit : public IScene {\n        public:\n            Credit(SceneManager&amp; sceneManager, std::shared_ptr&lt;sf::RenderWindow&gt;&amp; window);\n\n            void handleEvent(const sf::Event&amp; event) override;\n            void update(sf::Time dt) override;\n            void render(sf::RenderWindow&amp; window) override;\n            void nextScene(const std::string&amp; sceneName) override;\n            void resize(sf::RenderWindow&amp; window, const sf::Vector2u&amp; baseSize) override;\n\n        private:\n            std::shared_ptr&lt;sf::RenderWindow&gt; c_window;\n            SceneManager&amp; c_sceneManager;\n\n            std::unique_ptr&lt;RType::GUI::Objet::Background&gt; c_background;\n            RType::GUI::Objet::GeneriqueButton c_generiqueButton;\n            std::vector&lt;std::unique_ptr&lt;RType::GUI::Objet::Text&gt;&gt; c_texts;\n            sf::Sprite c_logoSprite;\n        };\n    }\n}\n\n#endif\n</code></pre>"},{"location":"coverage/client/src/Scene/HostGame_scene/","title":"HostGame_scene","text":"Name Lines Covered Uncovered Coverage hostGame_s.cpp 22 0 22 0.0% hostGame_s.hpp 0 0 0 100.0% Summary 22 0 22 0.0%"},{"location":"coverage/client/src/Scene/HostGame_scene/hostGame_s.cpp/","title":"hostGame_s.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** hostgame Scene\n*/\n\n#include \"hostGame_s.hpp\"\n\nnamespace RType {\n    namespace GUI {\n\n        HostGame::HostGame(SceneManager&amp; sceneManager, std::shared_ptr&lt;sf::RenderWindow&gt;&amp; window)\n            : h_sceneManager(sceneManager), h_background(nullptr), h_window(window) {\n            h_background = std::make_unique&lt;Objet::Background&gt;(\"backgroundMenu.jpg\");\n            h_texts.emplace_back(std::make_unique&lt;Objet::Text&gt;(std::make_pair(100.0f, 50.0f), \"Host Game\", 40, sf::Color::White, \"Arial.ttf\"));\n            h_generiqueButton.addButton(std::make_shared&lt;Objet::SpriteButton&gt;(\n                sf::Vector2f(0.0f, 0.0f),\n                sf::Vector2f(100.0f, 30.0f),\n                \"backButton.png\", \"backButton\"\n            ));\n\n        }\n\n        void HostGame::handleEvent(const sf::Event&amp; event) {\n            if (event.type == sf::Event::MouseButtonPressed &amp;&amp; event.mouseButton.button == sf::Mouse::Left) {\n                sf::Vector2i mousePosition(event.mouseButton.x, event.mouseButton.y);\n                if (h_generiqueButton.isClicked(mousePosition)) {\n                    for (const auto&amp; button : h_generiqueButton.getButtons()) {\n                        if (button-&gt;isClicked(mousePosition)) {\n                            const std::string&amp; label = button-&gt;getLabel();\n                            if (label == \"Settings\") {\n                                nextScene(\"setting\");\n                            }\n                            if (label == \"backButton\") {\n                                nextScene(\"menu\");\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        void HostGame::resize(sf::RenderWindow&amp; window, const sf::Vector2u&amp; baseSize) {\n        }\n\n        void HostGame::update(sf::Time dt) {\n        }\n\n        void HostGame::render(sf::RenderWindow&amp; window) {\n            h_background-&gt;draw(window);\n            h_generiqueButton.update(*h_window);\n            h_generiqueButton.draw(window);\n            for (const auto&amp; text : h_texts) {\n                text-&gt;draw(window);\n            }\n        }\n\n        void HostGame::nextScene(const std::string&amp; sceneName) {\n            h_sceneManager.changeScene(sceneName);\n        }\n    }\n}\n</code></pre>"},{"location":"coverage/client/src/Scene/HostGame_scene/hostGame_s.hpp/","title":"hostGame_s.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** hostgame Scene\n*/\n\n#ifndef HOSTGAME_SCENE_HPP\n    #define HOSTGAME_SCENE_HPP\n\n    #include &lt;SFML/Graphics.hpp&gt;\n    #include &lt;iostream&gt;\n    #include &lt;memory&gt;\n    #include &lt;vector&gt;\n\n    #include \"Scene/IScene.hpp\"\n    #include \"Objets/Button/TextButton/textButton.hpp\"\n    #include \"Objets/Button/SpriteButton/spriteButton.hpp\"\n    #include \"Objets/Button/GeneriqueButton/generiqueButton.hpp\"\n    #include \"Scene/SceneManager/SceneManager.hpp\"\n    #include \"Objets/Background/background.hpp\"\n\nnamespace RType {\n    namespace GUI {\n        class HostGame : public IScene {\n        public:\n            HostGame(SceneManager&amp; sceneManager, std::shared_ptr&lt;sf::RenderWindow&gt;&amp; window);\n\n            void handleEvent(const sf::Event&amp; event) override;\n            void update(sf::Time dt) override;\n            void render(sf::RenderWindow&amp; window) override;\n            void nextScene(const std::string&amp; sceneName) override;\n            void resize(sf::RenderWindow&amp; window, const sf::Vector2u&amp; baseSize) override;\n\n        private:\n            std::shared_ptr&lt;sf::RenderWindow&gt; h_window;\n            SceneManager&amp; h_sceneManager;\n\n            std::unique_ptr&lt;RType::GUI::Objet::Background&gt; h_background;\n            RType::GUI::Objet::GeneriqueButton h_generiqueButton;\n            std::vector&lt;std::unique_ptr&lt;RType::GUI::Objet::Text&gt;&gt; h_texts;\n        };\n    }\n}\n\n#endif\n</code></pre>"},{"location":"coverage/client/src/Scene/JoinGame_scene/","title":"JoinGame_scene","text":"Name Lines Covered Uncovered Coverage joinGame_s.cpp 25 0 25 0.0% joinGame_s.hpp 0 0 0 100.0% Summary 25 0 25 0.0%"},{"location":"coverage/client/src/Scene/JoinGame_scene/joinGame_s.cpp/","title":"joinGame_s.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** joinGame Scene\n*/\n\n#include \"joinGame_s.hpp\"\n\nnamespace RType {\n    namespace GUI {\n\n        JoinGame::JoinGame(SceneManager&amp; sceneManager, std::shared_ptr&lt;sf::RenderWindow&gt;&amp; window)\n            : j_sceneManager(sceneManager), j_background(nullptr), j_window(window) {\n            j_background = std::make_unique&lt;Objet::Background&gt;(\"backgroundMenu.jpg\");\n            j_texts.emplace_back(std::make_unique&lt;Objet::Text&gt;(std::make_pair(100.0f, 50.0f), \"Join Game\", 40, sf::Color::White, \"Arial.ttf\"));\n            j_generiqueButton.addButton(std::make_shared&lt;Objet::SpriteButton&gt;(\n                sf::Vector2f(0.0f, 0.0f),\n                sf::Vector2f(100.0f, 30.0f),\n                \"backButton.png\", \"backButton\"\n            ));\n            j_generiqueButton.addButton(std::make_shared&lt;Objet::JoinRoomButton&gt;(\n                sf::Vector2f(200.0f, 150.0f),\n                sf::Vector2f(600.0f, 100.0f),\n                \"alex room\", \"3/4\", \"Arial.ttf\", 30\n            ));\n        }\n\n        void JoinGame::handleEvent(const sf::Event&amp; event) {\n            if (event.type == sf::Event::MouseButtonPressed &amp;&amp; event.mouseButton.button == sf::Mouse::Left) {\n                sf::Vector2i mousePosition(event.mouseButton.x, event.mouseButton.y);\n                if (j_generiqueButton.isClicked(mousePosition)) {\n                    for (const auto&amp; button : j_generiqueButton.getButtons()) {\n                        if (button-&gt;isClicked(mousePosition)) {\n                            const std::string&amp; label = button-&gt;getLabel();\n                            if (label == \"Settings\") {\n                                nextScene(\"setting\");\n                            }\n                            if (label == \"backButton\") {\n                                nextScene(\"menu\");\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        void JoinGame::resize(sf::RenderWindow&amp; window, const sf::Vector2u&amp; baseSize) {\n        }\n\n        void JoinGame::update(sf::Time dt) {\n        }\n\n        void JoinGame::render(sf::RenderWindow&amp; window) {\n            j_background-&gt;draw(window);\n            j_generiqueButton.update(*j_window);\n            j_generiqueButton.draw(window);\n            for (const auto&amp; text : j_texts) {\n                text-&gt;draw(window);\n            }\n        }\n\n        void JoinGame::nextScene(const std::string&amp; sceneName) {\n            j_sceneManager.changeScene(sceneName);\n        }\n    }\n}\n</code></pre>"},{"location":"coverage/client/src/Scene/JoinGame_scene/joinGame_s.hpp/","title":"joinGame_s.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** JoinGame Scene\n*/\n\n#ifndef JoinGame_SCENE_HPP\n    #define JoinGame_SCENE_HPP\n\n    #include &lt;SFML/Graphics.hpp&gt;\n    #include &lt;iostream&gt;\n    #include &lt;memory&gt;\n    #include &lt;vector&gt;\n\n    #include \"Scene/IScene.hpp\"\n    #include \"Objets/Button/TextButton/textButton.hpp\"\n    #include \"Objets/Button/SpriteButton/spriteButton.hpp\"\n    #include \"Objets/Button/GeneriqueButton/generiqueButton.hpp\"\n    #include \"Objets/Button/JoinRoomButton/joinRoomButton.hpp\"\n    #include \"Scene/SceneManager/SceneManager.hpp\"\n    #include \"Objets/Background/background.hpp\"\n\nnamespace RType {\n    namespace GUI {\n        class JoinGame : public IScene {\n        public:\n            JoinGame(SceneManager&amp; sceneManager, std::shared_ptr&lt;sf::RenderWindow&gt;&amp; window);\n\n            void handleEvent(const sf::Event&amp; event) override;\n            void update(sf::Time dt) override;\n            void render(sf::RenderWindow&amp; window) override;\n            void nextScene(const std::string&amp; sceneName) override;\n            void resize(sf::RenderWindow&amp; window, const sf::Vector2u&amp; baseSize) override;\n\n        private:\n            std::shared_ptr&lt;sf::RenderWindow&gt; j_window;\n            SceneManager&amp; j_sceneManager;\n\n            std::unique_ptr&lt;RType::GUI::Objet::Background&gt; j_background;\n            RType::GUI::Objet::GeneriqueButton j_generiqueButton;\n            std::vector&lt;std::unique_ptr&lt;RType::GUI::Objet::Text&gt;&gt; j_texts;\n        };\n    }\n}\n\n#endif\n</code></pre>"},{"location":"coverage/client/src/Scene/Menu_scene/","title":"Menu_scene","text":"Name Lines Covered Uncovered Coverage menu_s.cpp 33 0 33 0.0% menu_s.hpp 0 0 0 100.0% Summary 33 0 33 0.0%"},{"location":"coverage/client/src/Scene/Menu_scene/menu_s.cpp/","title":"menu_s.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** Menu Scene\n*/\n\n#include \"menu_s.hpp\"\n\nnamespace RType {\n    namespace GUI {\n\n        MainMenu::MainMenu(SceneManager&amp; sceneManager, std::shared_ptr&lt;sf::RenderWindow&gt;&amp; window)\n            : m_sceneManager(sceneManager), m_background(nullptr), _window(window) {\n            m_background = std::make_unique&lt;Objet::Background&gt;(\"backgroundMenu.jpg\");\n            sf::Texture&amp; logoTexture = ResourceManager::getTexture(\"logo.png\");\n            m_logoSprite.setTexture(logoTexture);\n            m_logoSprite.setPosition(400.f, 50.f);\n\n            m_generiqueButton.addButton(std::make_shared&lt;Objet::TextButton&gt;(\n                sf::Vector2f(200.0f, 150.0f),\n                \"Join Game\", 30, sf::Color::White, sf::Color::Yellow, sf::Color::Red, \"Arial.ttf\"\n            ));\n\n            m_generiqueButton.addButton(std::make_shared&lt;Objet::TextButton&gt;(\n                sf::Vector2f(200.0f, 200.0f),\n                \"Host Game\", 30, sf::Color::White, sf::Color::Yellow, sf::Color::Red, \"Arial.ttf\"\n            ));\n\n            m_generiqueButton.addButton(std::make_shared&lt;Objet::TextButton&gt;(\n                sf::Vector2f(200.0f, 300.0f),\n                \"Settings\", 30, sf::Color::White, sf::Color::Yellow, sf::Color::Red, \"Arial.ttf\"\n            ));\n\n            m_generiqueButton.addButton(std::make_shared&lt;Objet::TextButton&gt;(\n                sf::Vector2f(200.0f, 350.0f),\n                \"Credits\", 30, sf::Color::White, sf::Color::Yellow, sf::Color::Red, \"Arial.ttf\"\n            ));\n\n            m_generiqueButton.addButton(std::make_shared&lt;Objet::TextButton&gt;(\n                sf::Vector2f(200.0f, 400.0f),\n                \"Quit\", 30, sf::Color::Red, sf::Color::Yellow, sf::Color::Red, \"Arial.ttf\"\n            ));\n        }\n\n        void MainMenu::handleEvent(const sf::Event&amp; event) {\n            if (event.type == sf::Event::MouseButtonReleased &amp;&amp; event.mouseButton.button == sf::Mouse::Left) {\n                sf::Vector2i mousePosition(event.mouseButton.x, event.mouseButton.y);\n                for (const auto&amp; button : m_generiqueButton.getButtons()) {\n                    if (button-&gt;isClicked(mousePosition)) {\n                        const std::string&amp; label = button-&gt;getLabel();\n                        if (label == \"Settings\") {\n                            nextScene(\"setting\");\n                        } else if (label == \"Host Game\") {\n                            nextScene(\"hostGame\");\n                        } else if (label == \"Join Game\") {\n                            nextScene(\"joinGame\");\n                        } else if (label == \"Credits\") {\n                            nextScene(\"credit\");\n                        }\n                    }\n                }\n            }\n        }\n\n        void MainMenu::resize(sf::RenderWindow&amp; window, const sf::Vector2u&amp; baseSize) {\n        }\n\n        void MainMenu::update(sf::Time dt) {\n        }\n\n        void MainMenu::render(sf::RenderWindow&amp; window) {\n            m_background-&gt;draw(window);\n            window.draw(m_logoSprite);\n            m_generiqueButton.update(*_window);\n            m_generiqueButton.draw(window);\n        }\n\n        void MainMenu::nextScene(const std::string&amp; sceneName) {\n            m_sceneManager.changeScene(sceneName);\n        }\n    }\n}\n</code></pre>"},{"location":"coverage/client/src/Scene/Menu_scene/menu_s.hpp/","title":"menu_s.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** Menu Scene\n*/\n\n#ifndef MENU_SCENE_HPP\n    #define MENU_SCENE_HPP\n\n    #include &lt;SFML/Graphics.hpp&gt;\n    #include &lt;iostream&gt;\n    #include &lt;memory&gt;\n    #include &lt;vector&gt;\n\n    #include \"Scene/IScene.hpp\"\n    #include \"Objets/Button/TextButton/textButton.hpp\"\n    #include \"Objets/Button/CostumButton/costumButton.hpp\"\n    #include \"Objets/Button/SpriteButton/spriteButton.hpp\"\n    #include \"Objets/Button/GeneriqueButton/generiqueButton.hpp\"\n    #include \"Scene/SceneManager/SceneManager.hpp\"\n    #include \"Objets/Background/background.hpp\"\n\nnamespace RType {\n    namespace GUI {\n        class MainMenu : public IScene {\n        public:\n            MainMenu(SceneManager&amp; sceneManager, std::shared_ptr&lt;sf::RenderWindow&gt;&amp; window);\n\n            void handleEvent(const sf::Event&amp; event) override;\n            void update(sf::Time dt) override;\n            void render(sf::RenderWindow&amp; window) override;\n            void nextScene(const std::string&amp; sceneName) override;\n            void resize(sf::RenderWindow&amp; window, const sf::Vector2u&amp; baseSize) override;\n\n        private:\n            std::shared_ptr&lt;sf::RenderWindow&gt; _window;\n            SceneManager&amp; m_sceneManager;\n\n            std::unique_ptr&lt;RType::GUI::Objet::Background&gt; m_background;\n            RType::GUI::Objet::GeneriqueButton m_generiqueButton;\n            sf::Sprite m_logoSprite;\n        };\n    }\n}\n\n#endif\n</code></pre>"},{"location":"coverage/client/src/Scene/SceneManager/","title":"SceneManager","text":"Name Lines Covered Uncovered Coverage SceneManager.cpp 14 0 14 0.0% SceneManager.hpp 0 0 0 100.0% Summary 14 0 14 0.0%"},{"location":"coverage/client/src/Scene/SceneManager/SceneManager.cpp/","title":"SceneManager.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** SceneManager\n*/\n\n#include \"SceneManager.hpp\"\nnamespace RType {\n    namespace GUI {\n\n        SceneManager::SceneManager() : _currentScene(nullptr) {}\n\n        void SceneManager::addScene(const std::string&amp; name, std::shared_ptr&lt;IScene&gt; scene) {\n            if (_scenes.find(name) != _scenes.end()) {\n                throw std::runtime_error(\"Scene '\" + name + \"' already exists!\");\n            }\n            _scenes[name] = scene;\n        }\n\n        void SceneManager::changeScene(const std::string&amp; sceneName) {\n            auto currentScene = _scenes.find(sceneName);\n            if (currentScene == _scenes.end()) {\n                std::cerr &lt;&lt; \"Scene '\" &lt;&lt; sceneName &lt;&lt; \"' not found!\" &lt;&lt; std::endl;\n                return;\n            }\n            _currentScene = currentScene-&gt;second;\n        }\n\n        void SceneManager::handleEvent(const sf::Event&amp; event) {\n            if (_currentScene) {\n                _currentScene-&gt;handleEvent(event);\n            }\n        }\n\n        void SceneManager::update(sf::Time dt) {\n            if (_currentScene) {\n                _currentScene-&gt;update(dt);\n            }\n        }\n\n        void SceneManager::render(sf::RenderWindow&amp; window) {\n            if (_currentScene) {\n                _currentScene-&gt;render(window);\n            }\n        }\n\n        void SceneManager::resizeScene(sf::RenderWindow&amp; window, const sf::Vector2u&amp; baseSize) {\n            for (auto&amp; pair : _scenes) {\n                pair.second-&gt;resize(window, baseSize);\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"coverage/client/src/Scene/SceneManager/SceneManager.hpp/","title":"SceneManager.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** SceneManager\n*/\n\n#ifndef SCENE_MANAGER_HPP\n    #define SCENE_MANAGER_HPP\n\n#include &lt;memory&gt;\n#include &lt;unordered_map&gt;\n#include &lt;iostream&gt;\n\n#include \"Scene/IScene.hpp\"\n\nnamespace RType {\n    namespace GUI {\n\n        class SceneManager {\n        public:\n            SceneManager();\n\n            void addScene(const std::string&amp; name, std::shared_ptr&lt;IScene&gt; scene);\n            void changeScene(const std::string&amp; sceneName);\n            void handleEvent(const sf::Event&amp; event);\n            void update(sf::Time dt);\n            void render(sf::RenderWindow&amp; window);\n            void resizeScene(sf::RenderWindow&amp; window, const sf::Vector2u&amp; baseSize);\n\n        private:\n            std::unordered_map&lt;std::string, std::shared_ptr&lt;IScene&gt;&gt; _scenes;\n            std::shared_ptr&lt;IScene&gt; _currentScene;\n        };\n    }\n}\n\n#endif\n</code></pre>"},{"location":"coverage/client/src/Scene/Setting_scene/","title":"Setting_scene","text":"Name Lines Covered Uncovered Coverage setting_s.cpp 44 0 44 0.0% setting_s.hpp 0 0 0 100.0% Summary 44 0 44 0.0%"},{"location":"coverage/client/src/Scene/Setting_scene/setting_s.cpp/","title":"setting_s.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** Setting Scene\n*/\n\n#include \"setting_s.hpp\"\n\nnamespace RType {\n    namespace GUI {\n        Setting::Setting(SceneManager&amp; sceneManager, std::shared_ptr&lt;sf::RenderWindow&gt;&amp; window)\n        : s_sceneManager(sceneManager), _window(window) {\n            s_background = std::make_unique&lt;Objet::Background&gt;(\"backgroundSetting.jpg\");\n            s_texts.emplace_back(std::make_unique&lt;Objet::Text&gt;(std::make_pair(100.0f, 50.0f), \"Settings\", 40, sf::Color::White, \"Arial.ttf\"));\n            s_generiqueButton.addButton(std::make_shared&lt;Objet::SpriteButton&gt;(\n                sf::Vector2f(0.0f, 0.0f),\n                sf::Vector2f(100.0f, 30.0f),\n                \"backButton.png\", \"backButton\"\n            ));\n            s_generiqueButton.addButton(std::make_shared&lt;Objet::CustomButton&gt;(\n                sf::Vector2f(100.0f, 300.0f),\n                sf::Vector2f(200.0f, 50.0f),\n                \"600x1000\", 30, sf::Color::White, \"button.png\", \"Arial.ttf\"\n            ));\n            s_generiqueButton.addButton(std::make_shared&lt;Objet::CustomButton&gt;(\n                sf::Vector2f(100.0f, 400.0f),\n                sf::Vector2f(200.0f, 50.0f),\n                \"800x1200\", 30, sf::Color::White, \"button.png\", \"Arial.ttf\"\n            ));\n            s_generiqueButton.addButton(std::make_shared&lt;Objet::CustomButton&gt;(\n                sf::Vector2f(100.0f, 500.0f),\n                sf::Vector2f(200.0f, 50.0f),\n                \"1200x1800\", 30, sf::Color::White, \"button.png\", \"Arial.ttf\"\n            ));\n            s_texts.emplace_back(std::make_unique&lt;Objet::Text&gt;(std::make_pair(100.0f, 150.0f), \"Volume Settings\", 30, sf::Color::White, \"Arial.ttf\"));\n            s_generiqueButton.addButton(std::make_shared&lt;Objet::SliderVolume&gt;(\n                100.0f, 100.0f, 200.0f, 20.0f, \"SliderVolumeMusic\"\n            ));\n            s_generiqueButton.addButton(std::make_shared&lt;Objet::SliderVolume&gt;(\n                100.0f, 200.0f, 200.0f, 20.0f, \"SliderVolumeSound\"\n            ));\n        }\n\n        void Setting::handleEvent(const sf::Event&amp; event) {\n            if (event.type == sf::Event::MouseButtonPressed &amp;&amp; event.mouseButton.button == sf::Mouse::Left) {\n                sf::Vector2i mousePosition(event.mouseButton.x, event.mouseButton.y);\n                if (s_generiqueButton.isClicked(mousePosition)) {\n                    for (const auto&amp; button : s_generiqueButton.getButtons()) {\n                        if (button-&gt;isClicked(mousePosition)) {\n                            const std::string&amp; label = button-&gt;getLabel();\n                            if (label == \"backButton\") {\n                                nextScene(\"menu\");\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n            if (event.type == sf::Event::MouseMoved || event.type == sf::Event::MouseButtonPressed) {\n                for (const auto&amp; button : s_generiqueButton.getButtons()) {\n                    const std::string&amp; label = button-&gt;getLabel();\n                    if (label == \"SliderVolumeMusic\") {\n                        button-&gt;update(*_window);\n                        float volume = button-&gt;getVolume();\n                        ResourceManager::updateMusicVolume(\"MenuMusic.wav\", volume);\n                    }\n                    if (label == \"SliderVolumeSound\") {\n                        button-&gt;update(*_window);\n                        float volume = button-&gt;getVolume();\n                        ResourceManager::updateAllSoundsVolume(volume);\n                    }\n                }\n            }\n        }\n\n        void Setting::update(sf::Time dt) {\n            s_generiqueButton.update(*_window);\n        }\n\n        void Setting::resize(sf::RenderWindow&amp; window, const sf::Vector2u&amp; baseSize) {\n        }\n\n        void Setting::render(sf::RenderWindow&amp; window) {\n            s_background-&gt;draw(window);\n            s_generiqueButton.update(*_window);\n            s_generiqueButton.draw(window);\n            for (const auto&amp; text : s_texts) {\n                text-&gt;draw(window);\n            }\n        }\n\n        void Setting::nextScene(const std::string&amp; sceneName) {\n            s_sceneManager.changeScene(sceneName);\n        }\n    }\n}\n</code></pre>"},{"location":"coverage/client/src/Scene/Setting_scene/setting_s.hpp/","title":"setting_s.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** Setting Scene\n*/\n\n#ifndef SETTING_SCENE_HPP\n    #define SETTING_SCENE_HPP\n\n#include &lt;SFML/Graphics.hpp&gt;\n#include &lt;memory&gt;\n#include &lt;vector&gt;\n\n#include \"Scene/IScene.hpp\"\n#include \"Objets/Button/CostumButton/costumButton.hpp\"\n#include \"Objets/Button/SpriteButton/spriteButton.hpp\"\n#include \"Objets/Button/GeneriqueButton/generiqueButton.hpp\"\n#include \"Objets/Button/SliderVolume/sliderVolume.hpp\"\n#include \"Objets/Text/text.hpp\"\n#include \"Scene/SceneManager/SceneManager.hpp\"\n#include \"Objets/Background/background.hpp\"\n\nnamespace RType {\n    namespace GUI {\n        class Setting : public IScene {\n        public:\n            Setting(SceneManager&amp; sceneManager, std::shared_ptr&lt;sf::RenderWindow&gt;&amp; window);\n\n            void handleEvent(const sf::Event&amp; event) override;\n            void update(sf::Time dt) override;\n            void render(sf::RenderWindow&amp; window) override;\n            void nextScene(const std::string&amp; sceneName) override;\n            void resize(sf::RenderWindow&amp; window, const sf::Vector2u&amp; baseSize) override;\n\n        private:\n            SceneManager&amp; s_sceneManager;\n            std::shared_ptr&lt;sf::RenderWindow&gt; _window;\n\n            std::unique_ptr&lt;RType::GUI::Objet::Background&gt; s_background;\n            std::vector&lt;std::unique_ptr&lt;RType::GUI::Objet::Text&gt;&gt; s_texts;\n            RType::GUI::Objet::GeneriqueButton s_generiqueButton;\n        };\n    }\n}\n\n#endif\n</code></pre>"},{"location":"coverage/ecs/","title":"ecs","text":"Name Lines Covered Uncovered Coverage src 41 0 41 0.0% Component 33 0 33 0.0% ComponentStorage.hpp 9 0 9 0.0% Components.hpp 24 0 24 0.0% Script 8 0 8 0.0% AScript.hpp 8 0 8 0.0% IScript.hpp 0 0 0 100.0% Summary 33 0 33 0.0% Summary 8 0 8 0.0% Summary 41 0 41 0.0% Summary 41 0 41 0.0%"},{"location":"coverage/ecs/src/","title":"src","text":"Name Lines Covered Uncovered Coverage Component 33 0 33 0.0% ComponentStorage.hpp 9 0 9 0.0% Components.hpp 24 0 24 0.0% Script 8 0 8 0.0% AScript.hpp 8 0 8 0.0% IScript.hpp 0 0 0 100.0% Summary 33 0 33 0.0% Summary 8 0 8 0.0% Summary 41 0 41 0.0%"},{"location":"coverage/ecs/src/Component/","title":"Component","text":"Name Lines Covered Uncovered Coverage ComponentStorage.hpp 9 0 9 0.0% Components.hpp 24 0 24 0.0% Summary 33 0 33 0.0%"},{"location":"coverage/ecs/src/Component/ComponentStorage.hpp/","title":"ComponentStorage.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** RType\n** File description:\n** EntityManager Class\n*/\n\n#ifndef COMPONENTSTORAGE_HPP_\n    #define COMPONENTSTORAGE_HPP_\n\n    #include \"Entity.hpp\"\n\n    /**\n    * ComponentStorage Interface\n    *\n    */\n    class ComponentStorageBase {\n        public:\n            virtual ~ComponentStorageBase() = default;\n            virtual void remove(ECS::entity_id id) = 0;\n        };\n\n    /**\n    * Stores all of the components of a same type wrapped in a std::shared_ptr\n    *\n    * @tparam Component Struct of the component.\n    */\n    template &lt;typename Component&gt;\n    class ComponentStorage : public ComponentStorageBase {\n    public:\n        std::vector&lt;std::shared_ptr&lt;Component&gt;&gt; storage;\n\n        void resize(size_t entity_count) {\n            if (entity_count &gt;= storage.size()) {\n                storage.resize(entity_count + 1);\n            }\n        }\n\n        /**\n        * Get component wrapped in a std::optional\n        *\n        * @param id Entity ID.\n        */\n        std::optional&lt;std::shared_ptr&lt;Component&gt;&gt; get(ECS::entity_id id) {\n            if (id &gt;= storage.size()) {\n                return std::nullopt;\n            }\n            return storage[id];\n        }\n\n        /**\n        * Add a component for an entity\n        *\n        * @param id Entity ID.\n        */\n        void add(ECS::entity_id id, std::shared_ptr&lt;Component&gt; component) {\n            resize(id);\n            storage[id] = std::move(component);\n        }\n\n        /**\n        * Remove component from an entity\n        *\n        * @param id Entity ID.\n        */\n        void remove(ECS::entity_id id) {\n            if (id &lt; storage.size()) {\n                storage[id] = nullptr;\n            }\n        }\n    };\n\n#endif\n</code></pre>"},{"location":"coverage/ecs/src/Component/Components.hpp/","title":"Components.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** RType\n** File description:\n** ECS Components\n*/\n\n#ifndef COMPONENTS_HPP_\n    #define COMPONENTS_HPP_\n\n    #include &lt;iostream&gt;\n\n    #include \"GUI_SFML_Graphics.hpp\"\n    #include \"Script/IScript.hpp\"\n\n    namespace ECS::Component\n    {\n        /**\n        * Position inside world space\n        *\n        * @param x X position.\n        * @param y Y position.\n        */\n        struct Position {\n            float x, y = 0;\n\n            bool operator==(const Position &amp;other) const\n            {\n                return x == other.x &amp;&amp; y == other.y;\n            }\n\n            friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Position&amp; p) {\n                os &lt;&lt; \"Position(x: \" &lt;&lt; p.x &lt;&lt; \", y: \" &lt;&lt; p.y &lt;&lt; \")\";\n                return os;\n            }\n        };\n\n        /**\n        * Velocity of entity\n        *\n        * @param x X speed.\n        * @param y Y speed.\n        */\n        struct Velocity {\n            int x, y = 0;\n\n            bool operator==(const Position &amp;other) const\n            {\n                return x == other.x &amp;&amp; y == other.y;\n            }\n\n            friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Velocity&amp; p) {\n                os &lt;&lt; \"Velocity(x: \" &lt;&lt; p.x &lt;&lt; \", y: \" &lt;&lt; p.y &lt;&lt; \")\";\n                return os;\n            }\n        };\n\n        /**\n        * Acceleration of entity\n        *\n        * @param x X acceleration.\n        * @param y Y acceleration.\n        * \n        * @warning THIS COMPONENT IS NOT IMPLEMENTED\n        */\n        struct Acceleration {\n            float x, y = 0;\n\n            bool operator==(const Acceleration &amp;other) const\n            {\n                return x == other.x &amp;&amp; y == other.y;\n            }\n        };\n\n        /**\n        * Rectangle box for collisions/zone/etc...\n        *\n        * @param x X outset.\n        * @param y Y outset.\n        * @param w width.\n        * @param h height.\n        */\n        struct Hitbox {\n            float x, y, w, h = 0;\n\n            friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Hitbox&amp; p) {\n                os &lt;&lt; \"Hitbox(x: \" &lt;&lt; p.x &lt;&lt; \", y: \" &lt;&lt; p.y &lt;&lt; \", w: \" &lt;&lt; p.w &lt;&lt; \", h: \" &lt;&lt; p.h &lt;&lt; \")\";\n                return os;\n            }\n        };\n\n        /**\n        * State value usable for StateMachine or simply indicating a state\n        *\n        * @param name State name.\n        */\n        struct State {\n            std::string value = \"\";\n\n            friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const State&amp; p) {\n                os &lt;&lt; \"State(\" &lt;&lt; p.value &lt;&lt; \")\";\n                return os;\n            }\n\n        };\n\n        /**\n        * Tag value usable for entity labeling/categorisation\n        * Usefull for entity differentiation when colliding for example\n        *\n        * @param name State name.\n        */\n        struct Tag {\n            std::string value = \"\";\n\n            friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Tag&amp; p) {\n                os &lt;&lt; \"State(\" &lt;&lt; p.value &lt;&lt; \")\";\n                return os;\n            }\n\n        };\n\n        /**\n        * Scripting on entity\n        *\n        * @param name Script name.\n        */\n        struct Script {\n            std::shared_ptr&lt;ECS::IScript&gt; content = nullptr;\n            bool hasStarted = false;\n\n            // Script( std::unique_ptr&lt;ECS::IScript&gt; c){\n            //     content = std::move(c);\n            // }\n\n            friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Script&amp; p) {\n                os &lt;&lt; \"Script()\";\n                return os;\n            }\n        };\n\n        /**\n        * Visual for entity\n        *\n        * @param sprite Sprite.\n        * @param center If true, the sprite will be centered based on it's position\n        */\n        struct Drawable {\n            sf::Sprite sprite;\n            bool center = false;\n\n            friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Drawable&amp; p) {\n                os &lt;&lt; \"Sprite()\";\n                return os;\n            }\n        };\n\n\n        /**\n        * Animation rect of entity\n        *\n        * @param rect Frame for sprite.\n        * @param fps Frame per second.\n        * @param destroyAtEnt If true, the entity will automatically be destroyed at the end of the animation, perfect for particles\n        */\n        struct Animation {\n            sf::IntRect rect;\n            int fps;\n            int currentFps = 0;\n            bool animating = false;\n            bool destroyAtEnd = false;\n\n            friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Animation&amp; p) {\n                os &lt;&lt; \"Animation()\";\n                return os;\n            }\n        };\n\n        /**\n        * Spritesheet info for selecting Sprite part on One line\n        *\n        * @param nbrOfState nbr of different states avaliable.\n        * @param state state selected.\n        * \n        * @warning THIS COMPONENT IS NOT IMPLEMENTED OR FUNCTIONAL\n        */\n        struct SpriteSheet {\n            int nbrOfState;\n            int state;\n\n            friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const SpriteSheet&amp; p) {\n                os &lt;&lt; \"SpriteSheet()\";\n                return os;\n            }\n        };\n\n\n        /**\n        * Parallax movement for entity\n        *\n        * @param speed Speed of parallax, goes backwards if negative value.\n        *\n        * @warning Float values can sometimes not work, for onsistency, only use int values\n        */\n        struct Parallax {\n            float speed = 0.5f;\n\n            bool operator==(const Parallax&amp; other) const {\n                return speed == other.speed;\n            }\n\n            friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Parallax&amp; p) {\n                os &lt;&lt; \"Parallax(speed: \" &lt;&lt; p.speed &lt;&lt; \")\";\n                return os;\n            }\n        };\n\n        /**\n        * Used for debugging local inputs\n        *\n        * @param up, down, left, right, action Action value.\n        *\n        */\n        struct PlayerInput {\n            bool up, down, left, right, action = false;\n        };\n\n        /**\n        * Health information for component\n        *\n        * @param health Health value\n        *\n        */\n        struct Health {\n            int health = 1;\n        };\n\n    }\n\n#endif\n</code></pre>"},{"location":"coverage/ecs/src/Script/","title":"Script","text":"Name Lines Covered Uncovered Coverage AScript.hpp 8 0 8 0.0% IScript.hpp 0 0 0 100.0% Summary 8 0 8 0.0%"},{"location":"coverage/ecs/src/Script/AScript.hpp/","title":"AScript.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** EpiGimp\n** File description:\n** ErrorException\n*/\n\n#ifndef A_SCRIPT_H_\n    #define A_SCRIPT_H_\n\n    #include \"IScript.hpp\"\n    #include \"ECSManager.hpp\"\n\n    namespace ECS\n    {\n        /**\n        * Default abstract of IScript, only global functions are defined.\n        *\n        * This script's methods will be called by the engine in specific moments, they cannot be called\n        * elsewhere\n        *\n        * Classes that inherit from this (the scripts you will create) can have their own private variables\n        * or component pointers (see example scripts in the ScriptSource folder for example)\n        *\n        * @param Game Pointer to access the engine class's content\n        * @param _selfID ID of the script's entity\n        *\n        */\n        class AScript : public ECS::IScript\n        {\n            public:\n                ~AScript() = default;\n\n                /**\n                * Called on Entity's first frame of existence, usefull for getting all components once\n                *\n                */\n                void onStart() {}\n\n                /**\n                * Called every frame\n                *\n                */\n                void onUpdate() {}\n\n                /**\n                * Called when an entity collides with another, they need a hitbox component to be activatable\n                * \n                * @param id ID of the entity who collided the script's owner\n                *\n                */\n                void onCollision(ECS::entity_id id) {}\n\n                /**\n                * Called when mouse clicks on the entity, they need to have an hitbox\n                *\n                */\n                void onClick() {}\n                void onEnterCamera() {} //NOT SUPPORTED\n                void onExitCamera() {} //NOT SUPPORTED\n\n                /**\n                * Called when Script is assigned to an entity so that they can manipulate the engine\n                *\n                * @param ecsManager Pointer to ECSManager Class (the engine).\n                */\n                void setEcsManager(ECS::ECSManager* ecsManager) {\n                    Game = ecsManager;\n                }\n\n                /**\n                * Defines the script's user ID\n                *\n                * @param id Entity ID.\n                */\n                void setEntityID(ECS::entity_id id) {\n                    _selfID = id;\n                }\n\n                /**\n                * Automatically spawn a prefab at (x, y), useful for spawning decor or temporary animation elements\n                *\n                * @warning NOT RECOMMENDED, MODIFYING ENTITIES CREATED BY THIS METHOD MAY CAUSE CRASH\n                * @param prefabName Prefab name.\n                * @param x X position\n                * @param y Y position\n                */\n                ECS::entity_id spawnPrefabAt(std::string prefabName, int x, int y) {\n                    ECS::entity_id id = Game-&gt;createEntityFromPrefab(prefabName);\n                    auto e = Game-&gt;getComponent&lt;ECS::Component::Position&gt;(id);\n                    if (e != nullptr) {\n                        e-&gt;x = x;\n                        e-&gt;y = y;\n                    }\n                    return id;\n                }\n\n            protected:\n                ECS::ECSManager *Game;\n                ECS::entity_id _selfID;\n\n        };\n    }\n\n#endif\n</code></pre>"},{"location":"coverage/ecs/src/Script/IScript.hpp/","title":"IScript.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** EpiGimp\n** File description:\n** ErrorException\n*/\n\n#ifndef I_SCRIPT_H_\n    #define I_SCRIPT_H_\n\n    #include \"Entity.hpp\"\n\n    namespace ECS\n    {\n        class ECSManager;\n\n        /**\n        * Interface for script classes\n        *\n        */\n        class IScript\n        {\n            public:\n                virtual ~IScript() = default;\n                virtual void onStart() = 0;\n                virtual void onUpdate() = 0;\n                virtual void onCollision(ECS::entity_id id) = 0;\n                virtual void onClick() = 0;\n                virtual void onEnterCamera() = 0;\n                virtual void onExitCamera() = 0;\n                virtual void setEcsManager(ECS::ECSManager* ecsManager) = 0;\n                virtual void setEntityID(ECS::entity_id id) = 0;\n        };\n    }\n\n#endif\n</code></pre>"},{"location":"coverage/flint/","title":"flint","text":"Name Lines Covered Uncovered Coverage src 101 44 57 43.6% Colors 0 0 0 100.0% Colors.cpp 0 0 0 100.0% Colors.hpp 0 0 0 100.0% CxxABI 34 26 8 76.5% CxxABI.cpp 34 26 8 76.5% CxxABI.hpp 0 0 0 100.0% Exceptions 44 17 27 38.6% Exceptions.cpp 43 17 26 39.5% Exceptions.hpp 1 0 1 0.0% Init 6 1 5 16.7% Init.cpp 6 1 5 16.7% Init.hpp 0 0 0 100.0% Logging 9 0 9 0.0% Logging.cpp 8 0 8 0.0% Logging.hpp 1 0 1 0.0% hpp 8 0 8 0.0% Inspection.hpp 8 0 8 0.0% Preprocessor.hpp 0 0 0 100.0% Summary 0 0 0 100.0% Summary 34 26 8 76.5% Summary 44 17 27 38.6% Summary 6 1 5 16.7% Summary 9 0 9 0.0% Summary 8 0 8 0.0% Summary 101 44 57 43.6% Summary 101 44 57 43.6%"},{"location":"coverage/flint/src/","title":"src","text":"Name Lines Covered Uncovered Coverage Colors 0 0 0 100.0% Colors.cpp 0 0 0 100.0% Colors.hpp 0 0 0 100.0% CxxABI 34 26 8 76.5% CxxABI.cpp 34 26 8 76.5% CxxABI.hpp 0 0 0 100.0% Exceptions 44 17 27 38.6% Exceptions.cpp 43 17 26 39.5% Exceptions.hpp 1 0 1 0.0% Init 6 1 5 16.7% Init.cpp 6 1 5 16.7% Init.hpp 0 0 0 100.0% Logging 9 0 9 0.0% Logging.cpp 8 0 8 0.0% Logging.hpp 1 0 1 0.0% hpp 8 0 8 0.0% Inspection.hpp 8 0 8 0.0% Preprocessor.hpp 0 0 0 100.0% Summary 0 0 0 100.0% Summary 34 26 8 76.5% Summary 44 17 27 38.6% Summary 6 1 5 16.7% Summary 9 0 9 0.0% Summary 8 0 8 0.0% Summary 101 44 57 43.6%"},{"location":"coverage/flint/src/Colors/","title":"Colors","text":"Name Lines Covered Uncovered Coverage Colors.cpp 0 0 0 100.0% Colors.hpp 0 0 0 100.0% Summary 0 0 0 100.0%"},{"location":"coverage/flint/src/Colors/Colors.cpp/","title":"Colors.cpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Thu, May, 2024                                                     *\n * Title           - CppLib                                                             *\n * Description     -                                                                    *\n *     Colors                                                                           *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *         \u2591        \u2591       \u2591\u2591        \u2591        \u2591        \u2591\u2591      \u2591\u2591  \u2591\u2591\u2591\u2591  \u2591             *\n *         \u2592  \u2592\u2592\u2592\u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592  \u2592  \u2592\u2592\u2592\u2592  \u2592             *\n *         \u2593      \u2593\u2593\u2593       \u2593\u2593\u2593\u2593\u2593  \u2593\u2593\u2593\u2593\u2593\u2593\u2593  \u2593\u2593\u2593\u2593      \u2593\u2593\u2593  \u2593\u2593\u2593\u2593\u2593\u2593\u2593        \u2593             *\n *         \u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588  \u2588  \u2588\u2588\u2588\u2588  \u2588             *\n *         \u2588        \u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588        \u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588        \u2588\u2588      \u2588\u2588  \u2588\u2588\u2588\u2588  \u2588             *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#include \"Colors.hpp\"\n\nnamespace Flint\n{\n    const std::string Colors::RESET          = \"\\033[0m\";\n    const std::string Colors::BOLD           = \"\\033[1m\";\n    const std::string Colors::DISABLED       = \"\\033[2m\";\n    const std::string Colors::ITALIC         = \"\\033[3m\";\n    const std::string Colors::UNDERLINE      = \"\\033[4m\";\n    const std::string Colors::BLINK          = \"\\033[5m\";\n    const std::string Colors::HIGHLIGHTED    = \"\\033[7m\";\n    const std::string Colors::STRIPED        = \"\\033[9m\";\n    const std::string Colors::BLACK          = \"\\033[30m\";\n    const std::string Colors::RED            = \"\\033[31m\";\n    const std::string Colors::GREEN          = \"\\033[32m\";\n    const std::string Colors::YELLOW         = \"\\033[33m\";\n    const std::string Colors::BLUE           = \"\\033[34m\";\n    const std::string Colors::PURPLE         = \"\\033[35m\";\n    const std::string Colors::CYAN           = \"\\033[36m\";\n    const std::string Colors::GREY           = \"\\033[37m\";\n    const std::string Colors::F_BLACK        = \"\\033[90m\";\n    const std::string Colors::F_RED          = \"\\033[91m\";\n    const std::string Colors::F_GREEN        = \"\\033[92m\";\n    const std::string Colors::F_YELLOW       = \"\\033[93m\";\n    const std::string Colors::F_BLUE         = \"\\033[94m\";\n    const std::string Colors::F_PURPLE       = \"\\033[95m\";\n    const std::string Colors::F_CYAN         = \"\\033[96m\";\n    const std::string Colors::F_GREY         = \"\\033[97m\";\n}\n</code></pre>"},{"location":"coverage/flint/src/Colors/Colors.hpp/","title":"Colors.hpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Thu, May, 2024                                                     *\n * Title           - CppLib                                                             *\n * Description     -                                                                    *\n *     Colors                                                                           *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *       \u2584\u2580\u2580\u2588\u2584\u2584\u2584\u2584  \u2584\u2580\u2580\u2584\u2580\u2580\u2580\u2584  \u2584\u2580\u2580\u2588\u2580\u2584    \u2584\u2580\u2580\u2580\u2588\u2580\u2580\u2584  \u2584\u2580\u2580\u2588\u2584\u2584\u2584\u2584  \u2584\u2580\u2584\u2584\u2584\u2584   \u2584\u2580\u2580\u2584 \u2584\u2584             *\n *      \u2590  \u2584\u2580   \u2590 \u2588   \u2588   \u2588 \u2588   \u2588  \u2588  \u2588    \u2588  \u2590 \u2590  \u2584\u2580   \u2590 \u2588 \u2588    \u258c \u2588  \u2588   \u2584\u2580            *\n *        \u2588\u2584\u2584\u2584\u2584\u2584  \u2590  \u2588\u2580\u2580\u2580\u2580  \u2590   \u2588  \u2590  \u2590   \u2588       \u2588\u2584\u2584\u2584\u2584\u2584  \u2590 \u2588      \u2590  \u2588\u2584\u2584\u2584\u2588             *\n *        \u2588    \u258c     \u2588          \u2588        \u2588        \u2588    \u258c    \u2588         \u2588   \u2588             *\n *       \u2584\u2580\u2584\u2584\u2584\u2584    \u2584\u2580        \u2584\u2580\u2580\u2580\u2580\u2580\u2584   \u2584\u2580        \u2584\u2580\u2584\u2584\u2584\u2584    \u2584\u2580\u2584\u2584\u2584\u2584\u2580   \u2584\u2580  \u2584\u2580             *\n *       \u2588    \u2590   \u2588         \u2588       \u2588 \u2588          \u2588    \u2590   \u2588     \u2590   \u2588   \u2588               *\n *       \u2590        \u2590         \u2590       \u2590 \u2590          \u2590        \u2590         \u2590   \u2590               *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#ifndef INCLUDED_COLORS_HPP\n    #define INCLUDED_COLORS_HPP\n\n    #include \"../Headers.hpp\"\n\nnamespace Flint\n{\n    /**\n      * This class defined a good set of ANSI colors.\n      *\n      * @ingroup flint\n      *\n      * @tip\n      * It is recomended to use those through streams :\n      * std::cout &lt;&lt; Flint::Colors::GREEN &lt;&lt; \"Hacker time\" &lt;&lt; Flint::Colors::RESET &lt;&lt; std::endl;\n      *\n      * @info\n      * Please ALWAYS remember to close your colors with Flint::Colors::RESET.\n      * Failure to do si might result in broken displays, with weird colors everywhere\n    */\n    class Colors\n    {\n        public:\n            static const std::string RESET;\n            static const std::string BOLD;\n            static const std::string DISABLED;\n            static const std::string ITALIC;\n            static const std::string UNDERLINE;\n            static const std::string BLINK;\n            static const std::string HIGHLIGHTED;\n            static const std::string STRIPED;\n            static const std::string BLACK;\n            static const std::string RED;\n            static const std::string GREEN;\n            static const std::string YELLOW;\n            static const std::string BLUE;\n            static const std::string PURPLE;\n            static const std::string CYAN;\n            static const std::string GREY;\n            static const std::string F_BLACK;\n            static const std::string F_RED;\n            static const std::string F_GREEN;\n            static const std::string F_YELLOW;\n            static const std::string F_BLUE;\n            static const std::string F_PURPLE;\n            static const std::string F_CYAN;\n            static const std::string F_GREY;\n    };\n}\n\n#endif\n</code></pre>"},{"location":"coverage/flint/src/CxxABI/","title":"CxxABI","text":"Name Lines Covered Uncovered Coverage CxxABI.cpp 34 26 8 76.5% CxxABI.hpp 0 0 0 100.0% Summary 34 26 8 76.5%"},{"location":"coverage/flint/src/CxxABI/CxxABI.cpp/","title":"CxxABI.cpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Thu, May, 2024                                                     *\n * Title           - CppLib                                                             *\n * Description     -                                                                    *\n *     CxxABI                                                                           *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *       _|_|_|_|  _|_|_|    _|_|_|  _|_|_|_|_|  _|_|_|_|    _|_|_|  _|    _|           *\n *       _|        _|    _|    _|        _|      _|        _|        _|    _|           *\n *       _|_|_|    _|_|_|      _|        _|      _|_|_|    _|        _|_|_|_|           *\n *       _|        _|          _|        _|      _|        _|        _|    _|           *\n *       _|_|_|_|  _|        _|_|_|      _|      _|_|_|_|    _|_|_|  _|    _|           *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#include \"CxxABI.hpp\"\n\nnamespace Flint\n{\n    std::string CxxABI::demangle(const char* name)\n    {\n        int status = -4;\n        char* _out = abi::__cxa_demangle(name, nullptr, nullptr, &amp;status);\n        if (status != 0 &amp;&amp; _out)\n            free(_out);\n        if (status != 0)\n            return std::string(name);\n        std::string result(_out);\n        free(_out);\n        return result;\n    }\n\n    std::pair&lt;std::string, std::size_t&gt; CxxABI::getFuncInfos(const char* symbolInfos)\n    {\n        std::pair&lt;std::string, std::size_t&gt; output;\n        std::string entry(symbolInfos);\n\n        std::size_t openP  = entry.find('(');\n        std::size_t closeP = entry.find(')');\n\n        if (openP == std::string::npos ||\n            closeP == std::string::npos)\n            return output;\n\n        std::string functionAndOffset = entry.substr(openP + 1, closeP);\n        std::size_t plusP  = functionAndOffset.find('+');\n\n        if (functionAndOffset.empty() ||\n            plusP == std::string::npos)\n            return output;\n\n        output.first  = CxxABI::demangle(functionAndOffset.substr(0, plusP).c_str());\n        std::stringstream ss;\n        ss &lt;&lt; std::hex &lt;&lt; functionAndOffset.substr(plusP + 1);\n        ss &gt;&gt; output.second;\n\n        return output;\n    }\n\n    // std::vector&lt;std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt;&gt; CxxABI::getBacktrace()\n    std::vector&lt;std::pair&lt;std::string, std::size_t&gt;&gt; CxxABI::getBacktrace()\n    {\n        std::vector&lt;std::pair&lt;std::string, std::size_t&gt;&gt; out;\n        int TRACE_CHUNCK = 128;\n\n        int size = 0, out_size = 0;\n        do {\n            size += TRACE_CHUNCK;\n            void* trace[size + 1];\n            out_size = (int)backtrace(trace, size);\n        } while (out_size == size);\n        void* trace[out_size + 1];\n\n        backtrace(trace, out_size);\n        char** symbols = backtrace_symbols(trace, out_size);\n        if (symbols) {\n            for (int i = 0; i &lt; out_size; ++i) {\n                std::pair&lt;std::string, std::size_t&gt; symbol = CxxABI::getFuncInfos(symbols[i]);\n                if (symbol.first.empty())\n                    break;\n                out.push_back(symbol);\n            }\n            free(symbols);\n        }\n\n        return out;\n    }\n}\n</code></pre>"},{"location":"coverage/flint/src/CxxABI/CxxABI.hpp/","title":"CxxABI.hpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Thu, May, 2024                                                     *\n * Title           - CppLib                                                             *\n * Description     -                                                                    *\n *     CxxABI                                                                           *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *       \u2584\u2580\u2580\u2588\u2584\u2584\u2584\u2584  \u2584\u2580\u2580\u2584\u2580\u2580\u2580\u2584  \u2584\u2580\u2580\u2588\u2580\u2584    \u2584\u2580\u2580\u2580\u2588\u2580\u2580\u2584  \u2584\u2580\u2580\u2588\u2584\u2584\u2584\u2584  \u2584\u2580\u2584\u2584\u2584\u2584   \u2584\u2580\u2580\u2584 \u2584\u2584             *\n *      \u2590  \u2584\u2580   \u2590 \u2588   \u2588   \u2588 \u2588   \u2588  \u2588  \u2588    \u2588  \u2590 \u2590  \u2584\u2580   \u2590 \u2588 \u2588    \u258c \u2588  \u2588   \u2584\u2580            *\n *        \u2588\u2584\u2584\u2584\u2584\u2584  \u2590  \u2588\u2580\u2580\u2580\u2580  \u2590   \u2588  \u2590  \u2590   \u2588       \u2588\u2584\u2584\u2584\u2584\u2584  \u2590 \u2588      \u2590  \u2588\u2584\u2584\u2584\u2588             *\n *        \u2588    \u258c     \u2588          \u2588        \u2588        \u2588    \u258c    \u2588         \u2588   \u2588             *\n *       \u2584\u2580\u2584\u2584\u2584\u2584    \u2584\u2580        \u2584\u2580\u2580\u2580\u2580\u2580\u2584   \u2584\u2580        \u2584\u2580\u2584\u2584\u2584\u2584    \u2584\u2580\u2584\u2584\u2584\u2584\u2580   \u2584\u2580  \u2584\u2580             *\n *       \u2588    \u2590   \u2588         \u2588       \u2588 \u2588          \u2588    \u2590   \u2588     \u2590   \u2588   \u2588               *\n *       \u2590        \u2590         \u2590       \u2590 \u2590          \u2590        \u2590         \u2590   \u2590               *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#ifndef INCLUDED_CXXABI_HPP\n    #define INCLUDED_CXXABI_HPP\n\n    #include \"../Headers.hpp\"\n\nnamespace Flint\n{\n    /**\n      * Wrapper around usefull C++/C low level functions\n      *\n      * @ingroup flint\n      *\n      * Got demangle, backtrace...\n      *\n      * @tip\n      * This class is only made of static functions. It does not contain constructor, nor destructor\n      * This means that you don't need to instanciate it, and only use it as if it was a namespace.\n    */\n    class CxxABI\n    {\n        public:\n            CxxABI() = delete;\n\n            /**\n              * Demangle a C++ name.\n              *\n              * This is usefull for : Class names, backtrace...\n              *\n              * @return string containing : demangled name, or original name, if demangle did not work\n            */\n            static std::string demangle(const char* name);\n\n            /**\n              * Get functions infos from symbol extraction\n              *\n              * @return A pair with the function names demangled, and the offset from the function\n              *\n              * @warning\n              * The function name is not EXACTLY the real name of the function.\n              * Also, the offset DOES NOT correspond to the line number, but the offset of asm instructions\n            */\n            static std::pair&lt;std::string, std::size_t&gt; getFuncInfos(const char* symbolInfos);\n\n            /**\n              * Retreive the execution trace\n              *\n              * @return Vector of pair&lt;pair&lt;string, size_t&gt;, string&gt;. I'll explain\n              *\n              * The idea is to retrieive the file, line, and function. So that's what we do :\n              * pair or : (file, line), function\n              *\n              * @warning\n              * To correctly grab function names, you will need to add compilation flag \"-rdynamic\"\n              * See this lib's CMakeLists.txt for implementation.\n              * This will export ALL symbols.\n              * If NOT done, you will get offsets from binary. It's ok, but quite disgusting on output.\n            */\n            static std::vector&lt;std::pair&lt;std::string, std::size_t&gt;&gt; getBacktrace();\n    };\n}\n\n#endif\n</code></pre>"},{"location":"coverage/flint/src/Exceptions/","title":"Exceptions","text":"Name Lines Covered Uncovered Coverage Exceptions.cpp 43 17 26 39.5% Exceptions.hpp 1 0 1 0.0% Summary 44 17 27 38.6%"},{"location":"coverage/flint/src/Exceptions/Exceptions.cpp/","title":"Exceptions.cpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Sun, Apr, 2024                                                     *\n * Title           - CppLib                                                             *\n * Description     -                                                                    *\n *     Exceptions                                                                       *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *       _|_|_|_|  _|_|_|    _|_|_|  _|_|_|_|_|  _|_|_|_|    _|_|_|  _|    _|           *\n *       _|        _|    _|    _|        _|      _|        _|        _|    _|           *\n *       _|_|_|    _|_|_|      _|        _|      _|_|_|    _|        _|_|_|_|           *\n *       _|        _|          _|        _|      _|        _|        _|    _|           *\n *       _|_|_|_|  _|        _|_|_|      _|      _|_|_|_|    _|_|_|  _|    _|           *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#include \"Exceptions.hpp\"\n\nnamespace Flint::Exceptions\n{\n    Exception::Exception(const std::string&amp; what, std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; infos):\n        _infos(infos)\n    {\n        std::vector&lt;std::pair&lt;std::string, std::size_t&gt;&gt; stackTrace = CxxABI::getBacktrace();\n        std::stringstream ss;\n\n        ss &lt;&lt; \"[\" &lt;&lt; Flint::Colors::F_PURPLE &lt;&lt; this-&gt;getClassNameFromStackTrace(stackTrace) &lt;&lt; Flint::Colors::RESET;\n\n        if (!infos.first.first.empty() &amp;&amp; !infos.second.empty()) {\n            ss &lt;&lt; \" in \" &lt;&lt;\n                Flint::Colors::F_YELLOW &lt;&lt; infos.second &lt;&lt; Flint::Colors::RESET &lt;&lt;\n                \" at \" &lt;&lt;\n                Flint::Colors::F_BLUE &lt;&lt; infos.first.first.substr(infos.first.first.find_last_of(\"/\\\\\") + 1) &lt;&lt; Flint::Colors::RESET &lt;&lt;\n                \":\" &lt;&lt;\n                Flint::Colors::F_RED &lt;&lt; infos.first.second &lt;&lt; Flint::Colors::RESET;\n        }\n        ss &lt;&lt; \"] \" &lt;&lt; what;\n\n        for (std::size_t i = 2; i &lt; stackTrace.size(); i++) {\n            std::string funcName = stackTrace[i].first;\n            std::size_t openP    = funcName.find('(');\n            if (openP == std::string::npos)\n                funcName += \"()\";\n            funcName = funcName.substr(0, funcName.find(\"(\") + 1) + \"[...])\";\n            ss &lt;&lt; std::endl &lt;&lt; \" -&gt; \" &lt;&lt;\n            Flint::Colors::CYAN &lt;&lt; funcName &lt;&lt; Flint::Colors::RESET &lt;&lt;\n            \":\" &lt;&lt;\n            Flint::Colors::YELLOW &lt;&lt; \"0x\" &lt;&lt; std::hex &lt;&lt; stackTrace[i].second &lt;&lt; Flint::Colors::RESET;\n        }\n\n        this-&gt;_what = ss.str();\n    }\n\n    std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; Exception::getInfos() const\n    {\n        return this-&gt;_infos;\n    }\n\n    std::string Exception::getClassNameFromStackTrace(const std::vector&lt;std::pair&lt;std::string, std::size_t&gt;&gt;&amp; stackTrace) const\n    {\n        if (stackTrace.size() &lt;= 2)\n            return \"[Class name undefined]\";\n\n        std::string classNameSymbol = stackTrace[2].first.substr();\n        std::size_t openP           = classNameSymbol.find('(');\n        if (openP == std::string::npos)\n            return \"[Class name undefined]\";\n\n        std::string functionName = classNameSymbol.substr(0, openP);\n        std::size_t lastColon    = functionName.rfind(\"::\");\n        if (lastColon == std::string::npos)\n            return \"[Class name undefined]\";\n        // Remove duplicate\n        return functionName.substr(0, lastColon);\n    }\n\n    std::string Exception::show(std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; fileInfos) const\n    {\n        std::stringstream ss;\n        ss &lt;&lt; \"Exception caught on \" &lt;&lt;\n              Flint::Colors::F_GREEN &lt;&lt; fileInfos.second       &lt;&lt; Flint::Colors::RESET &lt;&lt; \" at \" &lt;&lt;\n              Flint::Colors::F_BLUE  &lt;&lt; fileInfos.first.first  &lt;&lt; Flint::Colors::RESET &lt;&lt; \":\" &lt;&lt;\n              Flint::Colors::F_RED   &lt;&lt; fileInfos.first.second &lt;&lt; Flint::Colors::RESET &lt;&lt; std::endl &lt;&lt; std::endl;\n\n        ss &lt;&lt; this-&gt;_what;\n        return ss.str();\n    }\n\n    const char* Exception::what() const noexcept\n    {\n        return this-&gt;_what.c_str();\n    }\n\n    std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Exceptions::Exception&amp; obj)\n    {\n        os &lt;&lt; obj.what();\n        return os;\n    }\n}\n</code></pre>"},{"location":"coverage/flint/src/Exceptions/Exceptions.hpp/","title":"Exceptions.hpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Sun, Apr, 2024                                                     *\n * Title           - CppLib                                                             *\n * Description     -                                                                    *\n *     Exceptions                                                                       *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557  \u2588\u2588\u2557                     *\n *             \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551  \u2588\u2588\u2551                     *\n *             \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551                     *\n *             \u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551                     *\n *             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551                     *\n *             \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d     \u255a\u2550\u255d   \u255a\u2550\u255d   \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d                     *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#ifndef INCLUDED_EXCEPTIONS_HPP\n    #define INCLUDED_EXCEPTIONS_HPP\n\n    #include \"../Headers.hpp\"\n    #include \"../CxxABI/CxxABI.hpp\"\n    #include \"../Colors/Colors.hpp\"\n    #include \"../hpp/Preprocessor.hpp\"\n\nnamespace Flint::Exceptions\n{\n    /**\n      * Wrapper arround default [std::exception](https://en.cppreference.com/w/cpp/error/exception)\n      *\n      * @ingroup flint\n      *\n      * Store the the exception description as [std::string](https://en.cppreference.com/w/cpp/string/basic_string),\n      * and store some usefull localisation informations: Filename, Line, and Function Name.\n      * This is automated using the throw_exception preprocessor directive.\n      *\n      * @tip\n      * Take a look at the NotImplementedError to see how easy it is to implmeent your own Flint::Exception.\n    */\n    class Exception: public std::exception\n    {\n        protected:\n            std::string _what;\n            std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; _infos;\n        public:\n            /**\n              * Exception constructor. This need to be called, even on child classes.\n              *\n              * @param what Define the exception's description\n              * @param infos Might contain positional infos\n              *\n              * @warning\n              * You should **NOT** use any excpetion constructor manually.\n              * While they might work, the prefered way is to use the throw_exception preprocessor directive.\n              * Using it will only require you to register what type of excpetion you want to throw, and what message you want to add, and will take care of putting file name, line, and function name\n            */\n            Exception(const std::string&amp; what = \"An exception occured !\",\n                      std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; infos = {{\"\", 0}, \"\"});\n\n            /**\n              * Retreive given infos (filename, line, and function name)\n              *\n              * @return The actual infos\n            */\n            std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; getInfos() const;\n\n            /**\n              * Try to retreive the Exception class name from the StackTrace.\n              *\n              * @param stackTrace A stack trace, formated like CxxABI::getBacktrace()\n              *\n              * @warning\n              * This function **DOES NOT WORK 100% OF THE TIME**.\n              * It is really dependant on the environement, and can return undefined without aparent reason.\n              * It should **NOT** be used for anything else than debug or display.\n              *\n              * @return The actual class name or \"[Class name undefined]\"\n            */\n            std::string getClassNameFromStackTrace(const std::vector&lt;std::pair&lt;std::string, std::size_t&gt;&gt;&amp; stackTrace) const;\n\n            /**\n              * Display the error, given specific positional infos (like the constructor).\n              *\n              * @param infos Positional informations, like the constructor, used to display the infos.\n              *\n              * @note\n              * This function, while being usable without, should be used through the catch_exception preprocessor directive.\n              * This preprocessor directive let you display Python like excpetion trace.\n              *\n              * @return The formated exception, ready to be displayed.\n            */\n            std::string show(std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; infos) const;\n\n            /**\n              * Required override, deprecated by show and catch_exception.\n              *\n              * @info\n              * This is the required std::exception override.\n              * It'll return the _what as a const char*.\n              * While this will work, prefer using the show function or the catch_excpetion preprocessor directive :\n              *\n              * @example\n              * ```cpp\n              * try {\n              *     throw_exception(Flint::Exceptions::Exception, \"Sample testing exception\");\n              * } catch (const Flint::Exceptions::Exception&amp; e) {\n              *     std::cerr &lt;&lt; catch_exception(e) &lt;&lt; std::endl;\n              * }\n              * ```\n              *\n              * @return The _what as a C string\n            */\n            const char* what() const noexcept override;\n\n            /**\n              * operator&lt;&lt; override\n              *\n              * @abstract\n              * This will simply append the _what to the ostream\n            */\n            friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Exceptions::Exception&amp; obj);\n    };\n\n    /**\n      * Sample Flint::Exceptions::Exception to register NotImplemented features\n      *\n      * @ingroup flint\n      *\n      * @tip\n      * You should use that Exception as a C++ Implementation of the Rust todo!() macro.\n      *\n      * @example\n      * ```cpp\n      * throw_exception(Flint::Exceptions::NotImplementedError, \"This function haven't been implemented as of today !\");\n      * ```\n    */\n    class NotImplementedError:\n        public Flint::Exceptions::Exception\n    {\n        public:\n            NotImplementedError(const std::string&amp; what = \"Asked action haven't been implemented yet.\",\n                                std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; infos = {{\"\", 0}, \"\"}):\n                Exception(what, infos)\n            {}\n    };\n}\n\n#endif\n</code></pre>"},{"location":"coverage/flint/src/Init/","title":"Init","text":"Name Lines Covered Uncovered Coverage Init.cpp 6 1 5 16.7% Init.hpp 0 0 0 100.0% Summary 6 1 5 16.7%"},{"location":"coverage/flint/src/Init/Init.cpp/","title":"Init.cpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Thu, May, 2024                                                     *\n * Title           - Flint                                                              *\n * Description     -                                                                    *\n *     Init                                                                             *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *       \u2584\u2580\u2580\u2588\u2584\u2584\u2584\u2584  \u2584\u2580\u2580\u2584\u2580\u2580\u2580\u2584  \u2584\u2580\u2580\u2588\u2580\u2584    \u2584\u2580\u2580\u2580\u2588\u2580\u2580\u2584  \u2584\u2580\u2580\u2588\u2584\u2584\u2584\u2584  \u2584\u2580\u2584\u2584\u2584\u2584   \u2584\u2580\u2580\u2584 \u2584\u2584             *\n *      \u2590  \u2584\u2580   \u2590 \u2588   \u2588   \u2588 \u2588   \u2588  \u2588  \u2588    \u2588  \u2590 \u2590  \u2584\u2580   \u2590 \u2588 \u2588    \u258c \u2588  \u2588   \u2584\u2580            *\n *        \u2588\u2584\u2584\u2584\u2584\u2584  \u2590  \u2588\u2580\u2580\u2580\u2580  \u2590   \u2588  \u2590  \u2590   \u2588       \u2588\u2584\u2584\u2584\u2584\u2584  \u2590 \u2588      \u2590  \u2588\u2584\u2584\u2584\u2588             *\n *        \u2588    \u258c     \u2588          \u2588        \u2588        \u2588    \u258c    \u2588         \u2588   \u2588             *\n *       \u2584\u2580\u2584\u2584\u2584\u2584    \u2584\u2580        \u2584\u2580\u2580\u2580\u2580\u2580\u2584   \u2584\u2580        \u2584\u2580\u2584\u2584\u2584\u2584    \u2584\u2580\u2584\u2584\u2584\u2584\u2580   \u2584\u2580  \u2584\u2580             *\n *       \u2588    \u2590   \u2588         \u2588       \u2588 \u2588          \u2588    \u2590   \u2588     \u2590   \u2588   \u2588               *\n *       \u2590        \u2590         \u2590       \u2590 \u2590          \u2590        \u2590         \u2590   \u2590               *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#include \"Init.hpp\"\n\nnamespace Flint\n{\n    static void unhandeled_exception()\n    {\n        try {\n            std::rethrow_exception(std::current_exception());\n        } catch (const std::exception&amp; e) {\n            const Flint::Exceptions::Exception* exception = dynamic_cast&lt;const Flint::Exceptions::Exception*&gt;(&amp;e);\n            if (exception != nullptr) {\n                std::cerr &lt;&lt; Flint::Colors::RED &lt;&lt; \"/!\\\\\" &lt;&lt; Flint::Colors::RESET &lt;&lt; \" Uncaught Flint exception \" &lt;&lt; Flint::Colors::RED &lt;&lt; \"/!\\\\\" &lt;&lt; Flint::Colors::RESET &lt;&lt; std::endl &lt;&lt; std::endl &lt;&lt; *exception &lt;&lt; std::endl;\n            } else {\n                std::cerr &lt;&lt; Flint::Colors::RED &lt;&lt; \"/!\\\\\" &lt;&lt; Flint::Colors::RESET &lt;&lt; \" Uncaught exception \" &lt;&lt; Flint::Colors::RED &lt;&lt; \"/!\\\\\" &lt;&lt; Flint::Colors::RESET &lt;&lt; std::endl &lt;&lt; std::endl &lt;&lt; e.what() &lt;&lt; std::endl;\n            }\n        }\n    }\n\n    void Init()\n    {\n        std::set_terminate(unhandeled_exception);\n    }\n}\n</code></pre>"},{"location":"coverage/flint/src/Init/Init.hpp/","title":"Init.hpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Thu, May, 2024                                                     *\n * Title           - Flint                                                              *\n * Description     -                                                                    *\n *     Init                                                                             *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557  \u2588\u2588\u2557                     *\n *             \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551  \u2588\u2588\u2551                     *\n *             \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551                     *\n *             \u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551                     *\n *             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551                     *\n *             \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d     \u255a\u2550\u255d   \u255a\u2550\u255d   \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d                     *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#ifndef INCLUDED_INIT_HPP\n    #define INCLUDED_INIT_HPP\n\n    #include \"../Exceptions/Exceptions.hpp\"\n\nnamespace Flint\n{\n    [[gnu::constructor]] void Init();\n}\n\n#endif\n</code></pre>"},{"location":"coverage/flint/src/Logging/","title":"Logging","text":"Name Lines Covered Uncovered Coverage Logging.cpp 8 0 8 0.0% Logging.hpp 1 0 1 0.0% Summary 9 0 9 0.0%"},{"location":"coverage/flint/src/Logging/Logging.cpp/","title":"Logging.cpp","text":"<pre><code>#include \"Logging.hpp\"\n\nnamespace Flint\n{\n    Logging&amp; Logging::get()\n    {\n        static Logging instance;\n        return instance;\n    }\n\n    void Logging::set_log_on_stderr(bool log_on_stderr)\n    {\n        Logging::get().log_on_stderr = log_on_stderr;\n    }\n\n    void Logging::set_log_level(LogLevel level)\n    {\n        Logging::get().display_level = level;\n    }\n\n    void Logging::set_error_level(LogLevel level)\n    {\n        Logging::get().error_level = level;\n    }\n\n    void Logging::debug(const std::string&amp; message)\n    {\n        auto some_data = Flint::CxxABI::getBacktrace();\n        std::cout &lt;&lt; some_data.size() &lt;&lt; std::endl;\n        for (auto entry: some_data)\n            std::cout &lt;&lt; entry.first &lt;&lt; \" - \" &lt;&lt; entry.second &lt;&lt; std::endl;\n    }\n\n    void Logging::info(const std::string&amp; message)\n    {\n\n    }\n\n    void Logging::warning(const std::string&amp; message)\n    {\n\n    }\n\n    void Logging::error(const std::string&amp; message)\n    {\n\n    }\n\n    void Logging::critical(const std::string&amp; message)\n    {\n\n    }\n}\n</code></pre>"},{"location":"coverage/flint/src/Logging/Logging.hpp/","title":"Logging.hpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Sun, Apr, 2024                                                     *\n * Title           - CppLib                                                             *\n * Description     -                                                                    *\n *     Exceptions                                                                       *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557  \u2588\u2588\u2557                     *\n *             \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551  \u2588\u2588\u2551                     *\n *             \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551                     *\n *             \u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551                     *\n *             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551                     *\n *             \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d     \u255a\u2550\u255d   \u255a\u2550\u255d   \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d                     *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#ifndef INCLUDED_LOGGING_HPP\n    #define INCLUDED_LOGGING_HPP\n\n    #include \"../Headers.hpp\"\n    #include \"../CxxABI/CxxABI.hpp\"\n    #include \"../Colors/Colors.hpp\"\n    #include \"../Exceptions/Exceptions.hpp\"\n\nnamespace Flint\n{\n    enum LogLevel\n    {\n        Debug       = 0,\n        Info        = 1,\n        Warning     = 2,\n        Error       = 3,\n        Critical    = 4,\n    };\n\n    class TooHighLevelLoggingError:\n        public Flint::Exceptions::Exception\n    {\n        public:\n            TooHighLevelLoggingError(const std::string&amp; what = \"The message logged is of criticly high level.\",\n                                     std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; infos = {{\"\", 0}, \"\"}):\n                Exception(what, infos)\n            {}\n    };\n\n    class Logging\n    {\n        private:\n            Logging() {}\n\n            bool log_on_stderr      = false;\n            LogLevel display_level  = LogLevel::Info;\n            LogLevel error_level    = LogLevel::Critical;\n\n            static Logging&amp; get();\n\n        public:\n            Logging(const Logging&amp;)         = delete;\n            void operator=(const Logging&amp;)  = delete;\n\n            static void set_log_on_stderr(bool log_on_stderr);\n            static void set_log_level(LogLevel level);\n            static void set_error_level(LogLevel level);\n\n            static void debug(const std::string&amp; message);\n            static void info(const std::string&amp; message);\n            static void warning(const std::string&amp; message);\n            static void error(const std::string&amp; message);\n            static void critical(const std::string&amp; message);\n    };\n}\n\n#endif\n</code></pre>"},{"location":"coverage/flint/src/hpp/","title":"hpp","text":"Name Lines Covered Uncovered Coverage Inspection.hpp 8 0 8 0.0% Preprocessor.hpp 0 0 0 100.0% Summary 8 0 8 0.0%"},{"location":"coverage/flint/src/hpp/Inspection.hpp/","title":"Inspection.hpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Thu, May, 2024                                                     *\n * Title           - CppLib                                                             *\n * Description     -                                                                    *\n *     Inspection                                                                       *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *         \u2591        \u2591       \u2591\u2591        \u2591        \u2591        \u2591\u2591      \u2591\u2591  \u2591\u2591\u2591\u2591  \u2591             *\n *         \u2592  \u2592\u2592\u2592\u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592  \u2592  \u2592\u2592\u2592\u2592  \u2592             *\n *         \u2593      \u2593\u2593\u2593       \u2593\u2593\u2593\u2593\u2593  \u2593\u2593\u2593\u2593\u2593\u2593\u2593  \u2593\u2593\u2593\u2593      \u2593\u2593\u2593  \u2593\u2593\u2593\u2593\u2593\u2593\u2593        \u2593             *\n *         \u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588  \u2588  \u2588\u2588\u2588\u2588  \u2588             *\n *         \u2588        \u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588        \u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588        \u2588\u2588      \u2588\u2588  \u2588\u2588\u2588\u2588  \u2588             *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#ifndef INCLUDED_INSPECTION_HPP\n    #define INCLUDED_INSPECTION_HPP\n\n    #include \"../Headers.hpp\"\n    #include \"../CxxABI/CxxABI.hpp\"\n\nnamespace Flint\n{\n    /**\n      * Base class to implement simplet self-reflexion in C++\n      *\n      * @ingroup flint\n      *\n      * @tparam T Child class itself\n      *\n      * @tip\n      * When creating a child class, define as follow :\n      * ```cpp\n      * class ChildClass: public Inspection&lt;ChildClass&gt;\n      * ```\n      * This will extand the ChildClass with the self-reflexion class Inspection\n      *\n      * @warning\n      * If the class you want to extand as a reflected class will be a parent class\n      * (I.E. You will create childs of this \"target\" class), you might want to\n      * mark inheritence as **virtual**.\n      * This is needed if your child class _also_ need to be reflected.\n      * This way, there is no confilict between the parent reflexion, and the child reflexion.\n    */\n    template &lt;typename T&gt;\n    class Inspection\n    {\n        public:\n            /**\n              * Return the name of the reflected class\n              *\n              * @return The demangled name of the class, or just the name, if demangleing failed\n            */\n            virtual std::string getClassName() const final\n            {\n                return CxxABI::demangle(typeid(T).name());\n            }\n\n            // virtual std::unordered_set&lt;std::pair&lt;std::string, std::string&gt;&gt; getAttributes();\n\n            /**\n              * Return a string representation of the class\n              *\n              * @tip\n              * This function is not intended to be used.\n              * This is because this functions display the reflection.\n              * You might prefer to override this function in yout child\n              * class to display informations that are more relevant to\n              * your specific class.\n              *\n              * @example\n              * You have a Macro available to make the str function really\n              * easilly :\n              * ```cpp\n              * display_attr(attribute)\n              * ```\n              * Which will automaticly translate to\n              * ```cpp\n              * Flint::Colors::F_BLUE &lt;&lt; \"attribute\" &lt;&lt; Flint::Colors::RESET &lt;&lt; \"=\" &lt;&lt; Flint::Colors::RED &lt;&lt; this-&gt;attribute &lt;&lt; Flint::Colors::RESET\n              * ```\n              * There is also a `make_str` macro, which you can use as follow :\n              * ```cpp\n              * return make_str(\"a=12\" &lt;&lt; \", \" &lt;&lt; \"b=5\");\n              * ```\n              * that becomes\n              * ```cpp\n              * return ({std::stringstream ss; ss &lt;&lt; \"&lt;\" &lt;&lt; this-&gt;getClassName() &lt;&lt; \" at \" &lt;&lt; std::hex &lt;&lt; this &lt;&lt; \": \" &lt;&lt; \"a=12\" &lt;&lt; \", \" &lt;&lt; \"b=5\" &lt;&lt; \"&gt;\"; ss.str()})\n              * ```\n              * It means you can define the str function of your class as like that :\n              * ```cpp\n              * // Provided you have 3 attributes called a, b and c\n              * return make_str(display_attr(a) &lt;&lt; \", \" &lt;&lt; display_attr(b) &lt;&lt; \", \" &lt;&lt; display_attr(c));\n              * ```\n              *\n              * @return The string representation of the class\n            */\n            virtual std::string str() const\n            {\n                std::stringstream ss;\n\n                ss &lt;&lt; \"&lt;\" &lt;&lt;\n                    Flint::Colors::F_PURPLE &lt;&lt; this-&gt;getClassName() &lt;&lt; Flint::Colors::RESET &lt;&lt;\n                    \" at \" &lt;&lt;\n                    Flint::Colors::YELLOW   &lt;&lt; std::hex &lt;&lt; this     &lt;&lt; Flint::Colors::RESET &lt;&lt;\n                    \"&gt;\";\n\n                return ss.str();\n            }\n\n            /** Overload the operator &lt;&lt; to use the str method of the object\n              *\n              * @tparam T Reflected class\n              *\n              * @param os Reference of ostream (I.E. std::cout, std::cerr...)\n              *\n              * @param obj Object reference to be displayed\n              *\n              * @return Param os\n            */\n            friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Inspection&lt;T&gt;&amp; obj)\n            {\n                os &lt;&lt; obj.str();\n                return os;\n            }\n    };\n}\n\n\n#endif\n</code></pre>"},{"location":"coverage/flint/src/hpp/Preprocessor.hpp/","title":"Preprocessor.hpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Thu, May, 2024                                                     *\n * Title           - CppLib                                                             *\n * Description     -                                                                    *\n *     Preprocessor                                                                     *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *       \u2584\u2580\u2580\u2588\u2584\u2584\u2584\u2584  \u2584\u2580\u2580\u2584\u2580\u2580\u2580\u2584  \u2584\u2580\u2580\u2588\u2580\u2584    \u2584\u2580\u2580\u2580\u2588\u2580\u2580\u2584  \u2584\u2580\u2580\u2588\u2584\u2584\u2584\u2584  \u2584\u2580\u2584\u2584\u2584\u2584   \u2584\u2580\u2580\u2584 \u2584\u2584             *\n *      \u2590  \u2584\u2580   \u2590 \u2588   \u2588   \u2588 \u2588   \u2588  \u2588  \u2588    \u2588  \u2590 \u2590  \u2584\u2580   \u2590 \u2588 \u2588    \u258c \u2588  \u2588   \u2584\u2580            *\n *        \u2588\u2584\u2584\u2584\u2584\u2584  \u2590  \u2588\u2580\u2580\u2580\u2580  \u2590   \u2588  \u2590  \u2590   \u2588       \u2588\u2584\u2584\u2584\u2584\u2584  \u2590 \u2588      \u2590  \u2588\u2584\u2584\u2584\u2588             *\n *        \u2588    \u258c     \u2588          \u2588        \u2588        \u2588    \u258c    \u2588         \u2588   \u2588             *\n *       \u2584\u2580\u2584\u2584\u2584\u2584    \u2584\u2580        \u2584\u2580\u2580\u2580\u2580\u2580\u2584   \u2584\u2580        \u2584\u2580\u2584\u2584\u2584\u2584    \u2584\u2580\u2584\u2584\u2584\u2584\u2580   \u2584\u2580  \u2584\u2580             *\n *       \u2588    \u2590   \u2588         \u2588       \u2588 \u2588          \u2588    \u2590   \u2588     \u2590   \u2588   \u2588               *\n *       \u2590        \u2590         \u2590       \u2590 \u2590          \u2590        \u2590         \u2590   \u2590               *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#ifndef INCLUDED_PREPROCESSOR_HPP\n    #define INCLUDED_PREPROCESSOR_HPP\n\n#if defined(__GNUC__)\n    #define __FUNCTION__ __PRETTY_FUNCTION__\n#elif defined(_MSC_VER)\n    #define __FUNCTION__ __FUNCSIG__\n#else\n    #define __FUNCTION__ __func__\n#endif\n\n    #define __POSITION_INFOS__ {{std::string(__FILE__), __LINE__}, std::string(__FUNCTION__)}\n    #define throw_exception(exception, message) throw(exception(message, __POSITION_INFOS__))\n    #define catch_exception(exception) exception.show(__POSITION_INFOS__)\n\n// Inspection\n    #define display_attr(attribute) Flint::Colors::F_BLUE &lt;&lt; #attribute &lt;&lt; Flint::Colors::RESET &lt;&lt; \"=\" &lt;&lt; Flint::Colors::RED &lt;&lt; this-&gt;attribute &lt;&lt; Flint::Colors::RESET\n    #define make_str(display) ({std::stringstream ss; ss &lt;&lt; Flint::Colors::RESET &lt;&lt; \"&lt;\" &lt;&lt; Flint::Colors::F_PURPLE &lt;&lt; this-&gt;getClassName() &lt;&lt; Flint::Colors::RESET &lt;&lt; \" at \" &lt;&lt; Flint::Colors::YELLOW &lt;&lt; std::hex &lt;&lt; this &lt;&lt; std::dec &lt;&lt; Flint::Colors::RESET &lt;&lt; \": \" &lt;&lt; display &lt;&lt; \"&gt;\"; ss.str();})\n\n#endif\n</code></pre>"},{"location":"coverage/network/","title":"network","text":"Name Lines Covered Uncovered Coverage src 91 0 91 0.0% Client 0 0 0 100.0% UDP 0 0 0 100.0% UDPClient.cpp 0 0 0 100.0% UDPClient.hpp 0 0 0 100.0% Security 71 0 71 0.0% DecodeError.hpp 3 0 3 0.0% GaloisField.cpp 8 0 8 0.0% GaloisField.hpp 1 0 1 0.0% HammingCodes.cpp 55 0 55 0.0% HammingCodes.hpp 1 0 1 0.0% ReedSolomon.cpp 2 0 2 0.0% ReedSolomon.hpp 1 0 1 0.0% Serialized 4 0 4 0.0% PlayerPosition.cpp 4 0 4 0.0% PlayerPosition.hpp 0 0 0 100.0% Server 16 0 16 0.0% UDP 16 0 16 0.0% UDPServer.cpp 16 0 16 0.0% UDPServer.hpp 0 0 0 100.0% Summary 0 0 0 100.0% Summary 0 0 0 100.0% Summary 71 0 71 0.0% Summary 4 0 4 0.0% Summary 16 0 16 0.0% Summary 16 0 16 0.0% Summary 91 0 91 0.0% Summary 91 0 91 0.0%"},{"location":"coverage/network/src/","title":"src","text":"Name Lines Covered Uncovered Coverage Client 0 0 0 100.0% UDP 0 0 0 100.0% UDPClient.cpp 0 0 0 100.0% UDPClient.hpp 0 0 0 100.0% Security 71 0 71 0.0% DecodeError.hpp 3 0 3 0.0% GaloisField.cpp 8 0 8 0.0% GaloisField.hpp 1 0 1 0.0% HammingCodes.cpp 55 0 55 0.0% HammingCodes.hpp 1 0 1 0.0% ReedSolomon.cpp 2 0 2 0.0% ReedSolomon.hpp 1 0 1 0.0% Serialized 4 0 4 0.0% PlayerPosition.cpp 4 0 4 0.0% PlayerPosition.hpp 0 0 0 100.0% Server 16 0 16 0.0% UDP 16 0 16 0.0% UDPServer.cpp 16 0 16 0.0% UDPServer.hpp 0 0 0 100.0% Summary 0 0 0 100.0% Summary 0 0 0 100.0% Summary 71 0 71 0.0% Summary 4 0 4 0.0% Summary 16 0 16 0.0% Summary 16 0 16 0.0% Summary 91 0 91 0.0%"},{"location":"coverage/network/src/Client/","title":"Client","text":"Name Lines Covered Uncovered Coverage UDP 0 0 0 100.0% UDPClient.cpp 0 0 0 100.0% UDPClient.hpp 0 0 0 100.0% Summary 0 0 0 100.0% Summary 0 0 0 100.0%"},{"location":"coverage/network/src/Client/UDP/","title":"UDP","text":"Name Lines Covered Uncovered Coverage UDPClient.cpp 0 0 0 100.0% UDPClient.hpp 0 0 0 100.0% Summary 0 0 0 100.0%"},{"location":"coverage/network/src/Client/UDP/UDPClient.cpp/","title":"UDPClient.cpp","text":""},{"location":"coverage/network/src/Client/UDP/UDPClient.hpp/","title":"UDPClient.hpp","text":"<pre><code>#ifndef INCLUDED_NETWORK_UDP_CLIENT_HPP\n    #define INCLUDED_NETWORK_UDP_CLIENT_HPP\n\n    #include &lt;boost/asio.hpp&gt;\n    #include &lt;boost/archive/binary_iarchive.hpp&gt;\n    #include &lt;boost/archive/binary_oarchive.hpp&gt;\n\nnamespace Network::Client::UDP\n{\n    class UDPClient\n    {\n\n    };\n}\n\n#endif\n</code></pre>"},{"location":"coverage/network/src/Security/","title":"Security","text":"Name Lines Covered Uncovered Coverage DecodeError.hpp 3 0 3 0.0% GaloisField.cpp 8 0 8 0.0% GaloisField.hpp 1 0 1 0.0% HammingCodes.cpp 55 0 55 0.0% HammingCodes.hpp 1 0 1 0.0% ReedSolomon.cpp 2 0 2 0.0% ReedSolomon.hpp 1 0 1 0.0% Summary 71 0 71 0.0%"},{"location":"coverage/network/src/Security/DecodeError.hpp/","title":"DecodeError.hpp","text":"<pre><code>#ifndef INCLUDED_NETWORK_DECODE_ERROR_HPP\n    #define INCLUDED_NETWORK_DECODE_ERROR_HPP\n\n    #include \"Flint.hpp\"\n    #include \"../export.hpp\"\n\nnamespace Network::Security\n{\n    class NETWORK_API DecodingError:\n        public Flint::Exceptions::Exception\n    {\n        public:\n            DecodingError(const std::string&amp; what = \"Could not decode/verify received data.\",\n                          std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; infos = {{\"\", 0}, \"\"}):\n                Exception(what, infos)\n            {}\n    };\n}\n\n#endif\n</code></pre>"},{"location":"coverage/network/src/Security/GaloisField.cpp/","title":"GaloisField.cpp","text":"<pre><code>#include \"GaloisField.hpp\"\n\nnamespace Network::Security\n{\n    GaloisField::GaloisField(int primitive, int field_size):\n        primitive(primitive), field_size(field_size)\n    {\n        throw_exception(Flint::Exceptions::NotImplementedError, \"GaloisField haven't been implemented yet !\");\n        this-&gt;exp_table.resize(this-&gt;field_size);\n        this-&gt;log_table.resize(this-&gt;field_size);\n\n        unsigned char x = 1;\n        for (unsigned char i = 0; i &lt; this-&gt;field_size; ++i) {\n            this-&gt;exp_table[i] = x;\n            this-&gt;log_table[x] = i;\n            x = (x * 2) % field_size;\n        }\n    }\n}\n</code></pre>"},{"location":"coverage/network/src/Security/GaloisField.hpp/","title":"GaloisField.hpp","text":"<pre><code>#ifndef INCLUDED_NETWORK_GALOIS_FIELD_HPP\n    #define INCLUDED_NETWORK_GALOIS_FIELD_HPP\n\n    #include \"Flint.hpp\"\n    #include \"DecodeError.hpp\"\n    #include \"../export.hpp\"\n\nnamespace Network::Security\n{\n    class NETWORK_API GaloisField\n    {\n        private:\n            unsigned char primitive;\n            unsigned char field_size;\n            std::string exp_table;\n            std::string log_table;\n\n        public:\n            GaloisField(int primitive, int field_size);\n            void generate_field(int primitive);\n            int add(int a, int b);\n            int multiply(int a, int b);\n            int inverse(int a);\n            int divide(int a, int b);\n    };\n}\n\n#endif\n</code></pre>"},{"location":"coverage/network/src/Security/HammingCodes.cpp/","title":"HammingCodes.cpp","text":"<pre><code>#include \"HammingCodes.hpp\"\n\nnamespace Network::Security\n{\n    unsigned HammingCodes::get_nb_parity(unsigned size)\n    {\n        int p = 0;\n        while (pow(2, p) &lt; size + p + 1)\n            ++p;\n        return p;\n    }\n\n    unsigned HammingCodes::get_nb_parity_from_final_size(unsigned size)\n    {\n        int p = 0;\n        while (pow(2, p) &lt;= size)\n            ++p;\n        return p - 1;\n    }\n\n    void HammingCodes::setBit(std::string&amp; data, std::size_t pos, bool value)\n    {\n        size_t indx = pos / 8;\n        size_t ofst = pos % 8;\n        if (indx &gt;= data.size())\n            throw_exception(Network::Security::DecodingError, \"Position is outsize of the data !\");\n        if (value)\n            data[indx] |= (1 &lt;&lt; ofst);\n        else\n            data[indx] &amp;= ~(1 &lt;&lt; ofst);\n    }\n\n    bool HammingCodes::getBit(const std::string&amp; data, std::size_t pos)\n    {\n        size_t indx = pos / 8;\n        size_t ofst = pos % 8;\n        if (indx &gt;= data.size())\n            throw_exception(Network::Security::DecodingError, \"Position is outsize of the data !\");\n        return (data[indx] &gt;&gt; ofst) &amp; 1;\n    }\n\n    void HammingCodes::setParityBits(std::string&amp; data, unsigned size)\n    {\n        unsigned p = get_nb_parity(size);\n        for (unsigned i = 0; i &lt; p; ++i) {\n            unsigned p_pos = (1 &lt;&lt; i) - 1;\n            bool parity = false;\n\n            for (unsigned j = p_pos; j &lt; size; j += 2 * (p_pos + 1))\n                for (unsigned k = j; k &lt; j + (p_pos + 1) &amp;&amp; k &lt; size; ++k)\n                    if (k != p_pos)\n                        parity ^= HammingCodes::getBit(data, k);\n\n            HammingCodes::setBit(data, p_pos, parity);\n        }\n    }\n\n    std::string HammingCodes::encode(const std::string&amp; data)\n    {\n        unsigned dataBits = data.size() * 8;\n        unsigned parityBits = get_nb_parity(dataBits);\n        unsigned totalBits = dataBits + parityBits;\n\n        std::string coded_data((totalBits + 7) / 8, 0);\n\n        unsigned dataIndex = 0;\n        for (unsigned i = 0; i &lt; totalBits; ++i) {\n            if ((i &amp; (i + 1)) == 0)\n                continue;\n            setBit(coded_data, i, getBit(data, dataIndex));\n            ++dataIndex;\n        }\n\n        setParityBits(coded_data, totalBits);\n\n        return coded_data;\n    }\n\n    std::string HammingCodes::decode(const std::string&amp; data)\n    {\n        std::string output = data;\n        unsigned totalBits = output.size() * 8;\n        unsigned parityBits = get_nb_parity_from_final_size(totalBits);\n        unsigned dataBits = totalBits - parityBits;\n\n        unsigned errorPos = 0;\n        for (unsigned i = 0; i &lt; parityBits; ++i) {\n            unsigned parityPos = (1 &lt;&lt; i) - 1;\n            bool parity = false;\n\n            for (unsigned j = parityPos; j &lt; totalBits; j += 2 * (parityPos + 1))\n                for (unsigned k = j; k &lt; j + (parityPos + 1) &amp;&amp; k &lt; totalBits; ++k)\n                    parity ^= getBit(output, k);\n\n            if (parity)\n                errorPos |= (1 &lt;&lt; i);\n        }\n\n        if (errorPos)\n            HammingCodes::setBit(output, errorPos, !getBit(output, errorPos));\n\n        std::string decoded_data((dataBits + 7) / 8, 0);\n        unsigned dataIndex = 0;\n        for (unsigned i = 0; i &lt; totalBits; ++i) {\n            if ((i &amp; (i + 1)) == 0)\n                continue;\n            setBit(decoded_data, dataIndex, getBit(output, i));\n            ++dataIndex;\n        }\n\n        size_t last_non_null = decoded_data.find_last_not_of('\\0');\n        if (last_non_null != std::string::npos)\n            decoded_data.resize(last_non_null + 1);\n        else\n            decoded_data.clear();\n\n        return decoded_data;\n    }\n}\n</code></pre>"},{"location":"coverage/network/src/Security/HammingCodes.hpp/","title":"HammingCodes.hpp","text":"<pre><code>#ifndef INCLUDED_NETWORK_HAMMING_CODE_HPP\n    #define INCLUDED_NETWORK_HAMMING_CODE_HPP\n\n    #include \"Flint.hpp\"\n    #include \"DecodeError.hpp\"\n    #include \"../export.hpp\"\n\nnamespace Network::Security\n{\n    const int PRIMITIVE = 0x11d;\n    const int FIELD_SIZE = 256;\n    const int N = 255;\n    const int K = 223;\n\n    class NETWORK_API HammingCodes\n    {\n        private:\n            static unsigned get_nb_parity(unsigned size);\n            static unsigned get_nb_parity_from_final_size(unsigned size);\n            static void setBit(std::string&amp; byte, std::size_t pos, bool value);\n            static bool getBit(const std::string&amp; byte, std::size_t pos);\n            static void setParityBits(std::string&amp; data, unsigned size);\n        public:\n            static std::string encode(const std::string&amp; data);\n            static std::string decode(const std::string&amp; data);\n    };\n}\n\n\n#endif\n</code></pre>"},{"location":"coverage/network/src/Security/ReedSolomon.cpp/","title":"ReedSolomon.cpp","text":"<pre><code>#include \"ReedSolomon.hpp\"\n\nnamespace Network::Security\n{\n    ReedSolomon::ReedSolomon(int primitive, int field_size, int n, int k):\n        gf(primitive, field_size), primitive(primitive), field_size(field_size), n(n), k(k)\n    {\n        throw_exception(Flint::Exceptions::NotImplementedError, \"ReedSolomon haven't been implemented yet !\");\n    }\n}\n</code></pre>"},{"location":"coverage/network/src/Security/ReedSolomon.hpp/","title":"ReedSolomon.hpp","text":"<pre><code>#ifndef INCLUDED_NETWORK_REED_SOLOMON_HPP\n    #define INCLUDED_NETWORK_REED_SOLOMON_HPP\n\n    #include \"Flint.hpp\"\n    #include \"DecodeError.hpp\"\n    #include \"GaloisField.hpp\"\n    #include \"../export.hpp\"\n\nnamespace Network::Security\n{\n    class NETWORK_API ReedSolomon\n    {\n        private:\n            GaloisField gf;\n            int primitive;\n            int field_size;\n            int n, k;\n\n        public:\n            ReedSolomon(int primitive, int field_size, int n, int k);\n            std::string encode(const std::string&amp; message);\n    };\n}\n#endif\n</code></pre>"},{"location":"coverage/network/src/Serialized/","title":"Serialized","text":"Name Lines Covered Uncovered Coverage PlayerPosition.cpp 4 0 4 0.0% PlayerPosition.hpp 0 0 0 100.0% Summary 4 0 4 0.0%"},{"location":"coverage/network/src/Serialized/PlayerPosition.cpp/","title":"PlayerPosition.cpp","text":"<pre><code>#include \"PlayerPosition.hpp\"\n\nnamespace Network::Serialized\n{\n    std::string PlayerPosition::str() const\n    {\n        return make_str(display_attr(user_id) &lt;&lt; \", \" &lt;&lt; display_attr(x) &lt;&lt; \", \" &lt;&lt; display_attr(y));\n    }\n\n    template&lt;typename Archive&gt;\n    void PlayerPosition::serialize(Archive&amp; ar, const unsigned int version)\n    {\n        ar &amp; this-&gt;user_id;\n        ar &amp; this-&gt;x;\n        ar &amp; this-&gt;y;\n    }\n}\n</code></pre>"},{"location":"coverage/network/src/Serialized/PlayerPosition.hpp/","title":"PlayerPosition.hpp","text":"<pre><code>#ifndef INCLUDED_NETWORK_PLAYER_POSITION_HPP\n    #define INCLUDED_NETWORK_PLAYER_POSITION_HPP\n\n    #include \"Flint.hpp\"\n\nnamespace Network::Serialized\n{\n    /*\n     * This class contains a serialized version of the player's position.\n     *\n     * This is used as temporary \"hard coded\" version of transmitting informations within the network.\n     *\n     * @note\n     * When the network will get updated, this will get thanos snaped in order to be replaced by the actual components:\n     *\n     * The goal is to be able to send direct components, to ease the network and integration process.\n     *\n     * @warning\n     * This class does NOT contain every parts of the actual game !\n     * It only contains the position.\n    */\n    class PlayerPosition:\n        public Flint::Inspection&lt;PlayerPosition&gt;\n    {\n        private:\n            unsigned user_id;\n            float x;\n            float y;\n\n        public:\n            /**\n              * This class being a child of Flint::Inspection, overriding the str function also override the operator&lt;&lt;.\n              * This is done for debugging purposes.\n            */\n            std::string str() const override;\n\n            template&lt;typename Archive&gt;\n            void serialize(Archive&amp; ar, const unsigned int version);\n    };\n}\n\n#endif\n</code></pre>"},{"location":"coverage/network/src/Server/","title":"Server","text":"Name Lines Covered Uncovered Coverage UDP 16 0 16 0.0% UDPServer.cpp 16 0 16 0.0% UDPServer.hpp 0 0 0 100.0% Summary 16 0 16 0.0% Summary 16 0 16 0.0%"},{"location":"coverage/network/src/Server/UDP/","title":"UDP","text":"Name Lines Covered Uncovered Coverage UDPServer.cpp 16 0 16 0.0% UDPServer.hpp 0 0 0 100.0% Summary 16 0 16 0.0%"},{"location":"coverage/network/src/Server/UDP/UDPServer.cpp/","title":"UDPServer.cpp","text":"<pre><code>// #include \"UDPServer.hpp\"\n\n// namespace Network::Server::UDP\n// {\n//     UDPServer::UDPServer(boost::asio::io_context&amp; context, ushort port):\n//         _socket(context, boost::asio::udp::endpoint(boost::asio::udp::v4(), port))\n//     {\n//         this-&gt;start_receive();\n//     }\n\n//     UDPServer::start_receive()\n//     {\n//         this-&gt;_socket.async_receive_from(\n//             boost::asio::buffer(this-&gt;_buffer),\n//             this-&gt;_endpoint,\n//             std::bind(\n//                 &amp;boost::asio::udp::udp_server::handle_receive,\n//                 this,\n//                 std::placeholders::_1,\n//                 std::placeholders::_2\n//             )\n//         );\n//     }\n\n//     void UDPServer::handle_receive(const boost::system::error_code&amp; error, std::size_t bytes_transferred)\n//     {\n//         if (!error)\n//         {\n//             std::stringstream ss;\n//             ss.write(this-&gt;_buffer.data(), bytes_transferred);\n\n//             boost::archive::binary_iarchive ia(ss);\n//             MyData data;\n//             ia &gt;&gt; data;\n\n//             std::cout &lt;&lt; \"Received: \" &lt;&lt; data.some_value &lt;&lt; std::endl;\n\n//             MyData response_data;\n\n//             std::stringstream ss_out;\n//             boost::archive::binary_oarchive oa(ss_out);\n//             oa &lt;&lt; response_data;\n\n//             socket_.async_send_to(boost::asio::buffer(ss_out.str()), sender_endpoint_,\n//                                 [](const boost::system::error_code&amp; error, std::size_t bytes_transferred) {});\n\n//             this-&gt;start_receive();\n//         }\n//         else\n//         {\n//             std::cerr &lt;&lt; \"Error receiving from client: \" &lt;&lt; error.message() &lt;&lt; std::endl;\n//         }\n//     }\n// }\n\n#include \"UDPServer.hpp\"\n\nnamespace Network::Server::UDP\n{\n    UDPServer::UDPServer(boost::asio::io_service&amp; service, unsigned short port)\n        : _socket(service, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port))\n    {\n        this-&gt;start_receive();\n    }\n\n    void UDPServer::start_receive()\n    {\n        _socket.async_receive_from(\n            boost::asio::buffer(this-&gt;_buffer),\n            _endpoint,\n            [this](const boost::system::error_code&amp; error, std::size_t bytes_transferred)\n            {\n                this-&gt;handle_receive(error, bytes_transferred);\n            }\n            // boost::bind(\n            //     &amp;UDPServer::handle_receive,\n            //     this,\n            //     boost::asio::placeholders::error,\n            //     boost::asio::placeholders::bytes_transferred\n            // )\n        );\n    }\n\n    void UDPServer::handle_receive(const boost::system::error_code&amp; error, std::size_t bytes_transferred)\n    {\n        if (!error || error == boost::asio::error::message_size) {\n            try {\n                std::stringstream ss;\n                ss.write(_buffer.data(), bytes_transferred);\n\n                boost::archive::binary_iarchive ia(ss);\n                Network::Serialized::PlayerPosition data;\n                ia &gt;&gt; data;\n\n                std::cout &lt;&lt; \"Received: \" &lt;&lt; data &lt;&lt; std::endl;\n\n                Network::Serialized::PlayerPosition response_data;\n\n                std::stringstream ss_out;\n                boost::archive::binary_oarchive oa(ss_out);\n                oa &lt;&lt; response_data;\n\n                _socket.async_send_to(\n                    boost::asio::buffer(ss_out.str()),\n                    _endpoint,\n                    [](const boost::system::error_code&amp; send_error, std::size_t) {\n                        if (send_error) {\n                            std::cerr &lt;&lt; \"Error sending response: \" &lt;&lt; send_error.message() &lt;&lt; std::endl;\n                        }\n                    }\n                );\n\n                this-&gt;start_receive();\n            } catch (const std::exception&amp; e) {\n                std::cerr &lt;&lt; \"Exception during handling receive: \" &lt;&lt; e.what() &lt;&lt; std::endl;\n            }\n        } else {\n            std::cerr &lt;&lt; \"Error receiving from client: \" &lt;&lt; error.message() &lt;&lt; std::endl;\n        }\n    }\n\n    void handle_send(boost::shared_ptr&lt;std::string&gt;, const boost::system::error_code&amp;, std::size_t)\n    {}\n}\n</code></pre>"},{"location":"coverage/network/src/Server/UDP/UDPServer.hpp/","title":"UDPServer.hpp","text":"<pre><code>// #ifndef INCLUDED_NETWORK_UDP_SERVER_HPP\n//     #define INCLUDED_NETWORK_UDP_SERVER_HPP\n\n//     #include &lt;boost/asio.hpp&gt;\n//     #include &lt;boost/archive/binary_iarchive.hpp&gt;\n//     #include &lt;boost/archive/binary_oarchive.hpp&gt;\n\n// #include \"Flint.hpp\"\n\n// namespace Network::Server::UDP\n// {\n//     class UDPServer\n//     {\n//         private:\n//             boost::asio::udp::socket _socket;\n//             std::array&lt;char, 1024&gt; _buffer;\n//             boost::asio::udp::endpoit _endpoit;\n\n//         public:\n//             UDPServer(boost::asio::io_context&amp;, ushort);\n//             void start_receive();\n//             void handle_receive(const boost::system::error_code&amp;, std::size_t);\n//     };\n// }\n\n// #endif\n\n#ifndef INCLUDED_NETWORK_UDP_SERVER_HPP\n    #define INCLUDED_NETWORK_UDP_SERVER_HPP\n\n    #include &lt;boost/asio.hpp&gt;\n    #include &lt;boost/bind.hpp&gt;\n    #include &lt;boost/array.hpp&gt;\n    #include &lt;boost/shared_ptr.hpp&gt;\n    #include &lt;boost/archive/binary_iarchive.hpp&gt;\n    #include &lt;boost/archive/binary_oarchive.hpp&gt;\n    #include &lt;iostream&gt;\n    #include &lt;array&gt;\n    #include &lt;sstream&gt;\n\n    #include \"../../Serialized/PlayerPosition.hpp\"\n    #include \"Flint.hpp\"\n\nnamespace Network::Server::UDP\n{\n    class UDPServer\n    {\n        private:\n            boost::asio::ip::udp::socket _socket;\n            boost::asio::ip::udp::endpoint _endpoint;\n            boost::array&lt;char, 1024&gt; _buffer;\n\n        public:\n            UDPServer(boost::asio::io_context&amp; context, unsigned short port);\n        private:\n            void start_receive();\n            void handle_receive(const boost::system::error_code&amp; error, std::size_t bytes_transferred);\n            void handle_send(boost::shared_ptr&lt;std::string&gt;, const boost::system::error_code&amp;, std::size_t);\n    };\n}\n\n#endif\n</code></pre>"},{"location":"ecs/","title":"Entity Component System","text":"<p>While not a required part of the project, the Entity Component System (or ECS) is quite important. That is why it is built as a separate library</p>"},{"location":"flint/","title":"Flint","text":"<p>A custom implementation of the Flint library</p>"},{"location":"flint/#types","title":"Types","text":"Name Description Colors This class defined a good set of ANSI colors. CxxABI Wrapper around usefull C++/C low level functions Got demangle, backtrace... !!! tip This class is only made of static functions. It does not contain constructor, nor destructor This means that you don't need to instanciate it, and only use it as if it was a namespace. Exception Wrapper arround default std::exception Store the the exception description as std::string, and store some usefull localisation informations: Filename, Line, and Function Name. This is automated using the throw_exception preprocessor directive. !!! tip Take a look at the NotImplementedError to see how easy it is to implmeent your own Flint::Exception. Inspection Base class to implement simplet self-reflexion in C++  <code>T</code> :    Child class itself !!! tip When creating a child class, define as follow : <code>cpp class ChildClass: public Inspection&lt;ChildClass&gt;</code> This will extand the ChildClass with the self-reflexion class Inspection !!! warning If the class you want to extand as a reflected class will be a parent class (I.E. You will create childs of this \"target\" class), you might want to mark inheritence as virtual. This is needed if your child class also need to be reflected. This way, there is no confilict between the parent reflexion, and the child reflexion. NotImplementedError Sample Flint::Exceptions::Exception to register NotImplemented features !!! tip You should use that Exception as a C++ Implementation of the Rust todo!() macro. !!! example <code>cpp throw_exception(Flint::Exceptions::NotImplementedError, \"This function haven't been implemented as of today !\");</code>"},{"location":"flint/Colors/","title":"Colors","text":"<p>class Colors</p> <p>This class defined a good set of ANSI colors.</p> <p>Tip</p> <p>It is recomended to use those through streams : std::cout &lt;&lt; Flint::Colors::GREEN &lt;&lt; \"Hacker time\" &lt;&lt; Flint::Colors::RESET &lt;&lt; std::endl;</p> <p>Info</p> <p>Please ALWAYS remember to close your colors with Flint::Colors::RESET. Failure to do si might result in broken displays, with weird colors everywhere</p>"},{"location":"flint/CxxABI/","title":"CxxABI","text":"<p>class CxxABI</p> <p>Wrapper around usefull C++/C low level functions</p> <p>Got demangle, backtrace...</p> <p>Tip</p> <p>This class is only made of static functions. It does not contain constructor, nor destructor This means that you don't need to instanciate it, and only use it as if it was a namespace.</p>"},{"location":"flint/CxxABI/#functions","title":"Functions","text":"Name Description demangle Demangle a C++ name. getFuncInfos Get functions infos from symbol extraction  Return :    A pair with the function names demangled, and the offset from the function !!! warning The function name is not EXACTLY the real name of the function. Also, the offset DOES NOT correspond to the line number, but the offset of asm instructions getBacktrace Retreive the execution trace  Return :    Vector of pair, string&gt;. I'll explain The idea is to retrieive the file, line, and function. So that's what we do : pair or : (file, line), function !!! warning To correctly grab function names, you will need to add compilation flag \"-rdynamic\" See this lib's CMakeLists.txt for implementation. This will export ALL symbols. If NOT done, you will get offsets from binary. It's ok, but quite disgusting on output."},{"location":"flint/CxxABI/#function-details","title":"Function Details","text":""},{"location":"flint/CxxABI/#demangle","title":"demangle","text":"<p>static std::string demangle(const char* name)</p> <p>Demangle a C++ name.</p> <p>This is usefull for : Class names, backtrace...</p> Return string containing : demangled name, or original name, if demangle did not work"},{"location":"flint/CxxABI/#getfuncinfos","title":"getFuncInfos","text":"<p>static std::pair&lt;std::string, std::size_t&gt; getFuncInfos(const char* symbolInfos)</p> <p>Get functions infos from symbol extraction</p> Return A pair with the function names demangled, and the offset from the function <p>Warning</p> <p>The function name is not EXACTLY the real name of the function. Also, the offset DOES NOT correspond to the line number, but the offset of asm instructions</p>"},{"location":"flint/CxxABI/#getbacktrace","title":"getBacktrace","text":"<p>static std::vector&lt;std::pair&lt;std::string, std::size_t&gt;&gt; getBacktrace()</p> <p>Retreive the execution trace</p> Return Vector of pair, string&gt;. I'll explain <p>The idea is to retrieive the file, line, and function. So that's what we do : pair or : (file, line), function</p> <p>Warning</p> <p>To correctly grab function names, you will need to add compilation flag \"-rdynamic\" See this lib's CMakeLists.txt for implementation. This will export ALL symbols. If NOT done, you will get offsets from binary. It's ok, but quite disgusting on output.</p>"},{"location":"flint/Exception/","title":"Exception","text":"<p>class Exception: public std::exception</p> <p>Wrapper arround default std::exception</p> <p>Store the the exception description as std::string, and store some usefull localisation informations: Filename, Line, and Function Name. This is automated using the throw_exception preprocessor directive.</p> <p>Tip</p> <p>Take a look at the NotImplementedError to see how easy it is to implmeent your own Flint::Exception.</p>"},{"location":"flint/Exception/#operators","title":"Operators","text":"Name Description operator&lt;&lt; operator&lt;&lt; override !!! abstract This will simply append the _what to the ostream"},{"location":"flint/Exception/#functions","title":"Functions","text":"Name Description Exception Exception constructor. getInfos Retreive given infos (filename, line, and function name)  Return :    The actual infos getClassNameFromStackTrace Try to retreive the Exception class name from the StackTrace. show Display the error, given specific positional infos (like the constructor). what Required override, deprecated by show and catch_exception."},{"location":"flint/Exception/#operator-details","title":"Operator Details","text":""},{"location":"flint/Exception/#operator","title":"operator&lt;&lt;","text":"<p>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Exceptions::Exception&amp; obj)</p> <p>operator&lt;&lt; override</p> <p>Abstract</p> <p>This will simply append the _what to the ostream</p>"},{"location":"flint/Exception/#function-details","title":"Function Details","text":""},{"location":"flint/Exception/#exception_1","title":"Exception","text":"<p>Exception(const std::string&amp; what = \"An exception occured !\", std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; infos = {{\"\", 0}, \"\"})</p> <p>Exception constructor. This need to be called, even on child classes.</p> <code>what</code> Define the exception's description <code>infos</code> Might contain positional infos <p>Warning</p> <p>You should NOT use any excpetion constructor manually. While they might work, the prefered way is to use the throw_exception preprocessor directive. Using it will only require you to register what type of excpetion you want to throw, and what message you want to add, and will take care of putting file name, line, and function name</p>"},{"location":"flint/Exception/#getinfos","title":"getInfos","text":"<p>std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; getInfos() const</p> <p>Retreive given infos (filename, line, and function name)</p> Return The actual infos"},{"location":"flint/Exception/#getclassnamefromstacktrace","title":"getClassNameFromStackTrace","text":"<p>std::string getClassNameFromStackTrace(const std::vector&lt;std::pair&lt;std::string, std::size_t&gt;&gt;&amp; stackTrace) const</p> <p>Try to retreive the Exception class name from the StackTrace.</p> <code>stackTrace</code> A stack trace, formated like CxxABI::getBacktrace() <p>Warning</p> <p>This function DOES NOT WORK 100% OF THE TIME. It is really dependant on the environement, and can return undefined without aparent reason. It should NOT be used for anything else than debug or display.</p> Return The actual class name or \"[Class name undefined]\""},{"location":"flint/Exception/#show","title":"show","text":"<p>std::string show(std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; infos) const</p> <p>Display the error, given specific positional infos (like the constructor).</p> <code>infos</code> Positional informations, like the constructor, used to display the infos. <p>Note</p> <p>This function, while being usable without, should be used through the catch_exception preprocessor directive. This preprocessor directive let you display Python like excpetion trace.</p> Return The formated exception, ready to be displayed."},{"location":"flint/Exception/#what","title":"what","text":"<p>const char* what() const noexcept override</p> <p>Required override, deprecated by show and catch_exception.</p> <p>Info</p> <p>This is the required std::exception override. It'll return the _what as a const char*. While this will work, prefer using the show function or the catch_excpetion preprocessor directive :</p> <p>Example</p> <pre><code>try {\n    throw_exception(Flint::Exceptions::Exception, \"Sample testing exception\");\n} catch (const Flint::Exceptions::Exception&amp; e) {\n    std::cerr &lt;&lt; catch_exception(e) &lt;&lt; std::endl;\n}\n</code></pre> Return The _what as a C string"},{"location":"flint/Inspection/","title":"Inspection","text":"<p>template &lt;typename T&gt; class Inspection</p> <p>Base class to implement simplet self-reflexion in C++</p> <code>T</code> Child class itself <p>Tip</p> <p>When creating a child class, define as follow : <pre><code>class ChildClass: public Inspection&lt;ChildClass&gt;\n</code></pre> This will extand the ChildClass with the self-reflexion class Inspection</p> <p>Warning</p> <p>If the class you want to extand as a reflected class will be a parent class (I.E. You will create childs of this \"target\" class), you might want to mark inheritence as virtual. This is needed if your child class also need to be reflected. This way, there is no confilict between the parent reflexion, and the child reflexion.</p>"},{"location":"flint/Inspection/#operators","title":"Operators","text":"Name Description operator&lt;&lt; Overload the operator &lt;&lt; to use the str method of the object  <code>T</code> :    Reflected class  <code>os</code> :    Reference of ostream (I.E. std::cout, std::cerr...)  <code>obj</code> :    Object reference to be displayed  Return :    Param os"},{"location":"flint/Inspection/#functions","title":"Functions","text":"Name Description getClassName Return the name of the reflected class  Return :    The demangled name of the class, or just the name, if demangleing failed str Return a string representation of the class !!! tip This function is not intended to be used. This is because this functions display the reflection. You might prefer to override this function in yout child class to display informations that are more relevant to your specific class. !!! example You have a Macro available to make the str function really easilly : <code>cpp display_attr(attribute)</code> Which will automaticly translate to <code>cpp Flint::Colors::F_BLUE &lt;&lt; \"attribute\" &lt;&lt; Flint::Colors::RESET &lt;&lt; \"=\" &lt;&lt; Flint::Colors::RED &lt;&lt; this-&gt;attribute &lt;&lt; Flint::Colors::RESET</code> There is also a <code>make_str</code> macro, which you can use as follow : <code>cpp return make_str(\"a=12\" &lt;&lt; \", \" &lt;&lt; \"b=5\");</code> that becomes <code>cpp return ({std::stringstream ss; ss &lt;&lt; \"&lt;\" &lt;&lt; this-&gt;getClassName() &lt;&lt; \" at \" &lt;&lt; std::hex &lt;&lt; this &lt;&lt; \": \" &lt;&lt; \"a=12\" &lt;&lt; \", \" &lt;&lt; \"b=5\" &lt;&lt; \"&gt;\"; ss.str()})</code> It means you can define the str function of your class as like that : <code>cpp // Provided you have 3 attributes called a, b and c return make_str(display_attr(a) &lt;&lt; \", \" &lt;&lt; display_attr(b) &lt;&lt; \", \" &lt;&lt; display_attr(c));</code> Return :    The string representation of the class"},{"location":"flint/Inspection/#operator-details","title":"Operator Details","text":""},{"location":"flint/Inspection/#operator","title":"operator&lt;&lt;","text":"<p>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Inspection&lt;T&gt;&amp; obj)</p> <p>Overload the operator &lt;&lt; to use the str method of the object</p> <code>T</code> Reflected class <code>os</code> Reference of ostream (I.E. std::cout, std::cerr...) <code>obj</code> Object reference to be displayed Return Param os"},{"location":"flint/Inspection/#function-details","title":"Function Details","text":""},{"location":"flint/Inspection/#getclassname","title":"getClassName","text":"<p>virtual std::string getClassName() const final</p> <p>Return the name of the reflected class</p> Return The demangled name of the class, or just the name, if demangleing failed"},{"location":"flint/Inspection/#str","title":"str","text":"<p>virtual std::string str() const</p> <p>Return a string representation of the class</p> <p>Tip</p> <p>This function is not intended to be used. This is because this functions display the reflection. You might prefer to override this function in yout child class to display informations that are more relevant to your specific class.</p> <p>Example</p> <p>You have a Macro available to make the str function really easilly : <pre><code>display_attr(attribute)\n</code></pre> Which will automaticly translate to <pre><code>Flint::Colors::F_BLUE &lt;&lt; \"attribute\" &lt;&lt; Flint::Colors::RESET &lt;&lt; \"=\" &lt;&lt; Flint::Colors::RED &lt;&lt; this-&gt;attribute &lt;&lt; Flint::Colors::RESET\n</code></pre> There is also a <code>make_str</code> macro, which you can use as follow : <pre><code>return make_str(\"a=12\" &lt;&lt; \", \" &lt;&lt; \"b=5\");\n</code></pre> that becomes <pre><code>return ({std::stringstream ss; ss &lt;&lt; \"&lt;\" &lt;&lt; this-&gt;getClassName() &lt;&lt; \" at \" &lt;&lt; std::hex &lt;&lt; this &lt;&lt; \": \" &lt;&lt; \"a=12\" &lt;&lt; \", \" &lt;&lt; \"b=5\" &lt;&lt; \"&gt;\"; ss.str()})\n</code></pre> It means you can define the str function of your class as like that : <pre><code>// Provided you have 3 attributes called a, b and c\nreturn make_str(display_attr(a) &lt;&lt; \", \" &lt;&lt; display_attr(b) &lt;&lt; \", \" &lt;&lt; display_attr(c));\n</code></pre></p> Return The string representation of the class"},{"location":"flint/NotImplementedError/","title":"NotImplementedError","text":"<p>class NotImplementedError: public Flint::Exceptions::Exception</p> <p>Sample Flint::Exceptions::Exception to register NotImplemented features</p> <p>Tip</p> <p>You should use that Exception as a C++ Implementation of the Rust todo!() macro.</p> <p>Example</p> <pre><code>throw_exception(Flint::Exceptions::NotImplementedError, \"This function haven't been implemented as of today !\");\n</code></pre>"},{"location":"network/","title":"Network","text":"<p>Custom classes handeling all the networking. This allows you to create your own network wrapper (Hell, you could play through HTTP WebSockets if you want ! (Don't do that please)).</p>"},{"location":"server/","title":"Server","text":"<p>As important as all of the other parts (if not more), the server is the masterchief of the orchestra. It connect all players, and handle all the game logic.</p>"}]}