{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"RType","text":"<p>A GAME ENGINE THAT ROARS !</p> ECS Flint <p> Code Coverage</p>"},{"location":"ECS/","title":"ECS","text":"Component"},{"location":"ECS/Component/","title":"Component","text":""},{"location":"ECS/Component/#types","title":"Types","text":"Name Description Acceleration Acceleration of entity  <code>x</code> :    X acceleration.  <code>y</code> :    Y acceleration. Active Defines if the component is active or not (skips all systems for Entity)  <code>active</code> :    is the component Active. Animation Animation rect of entity  <code>rect</code> :    Frame for sprite.  <code>fps</code> :    Frame per second. Drawable Visual for entity  <code>sprite</code> :    Sprite. Hitbox Rectangle box for collisions/zone/etc...  <code>x</code> :    X outset.  <code>y</code> :    Y outset.  <code>w</code> :    width.  <code>h</code> :    height. LuaScript Lua Scripting on entity  <code>filepath</code> :    State name. Position Position inside world space  <code>x</code> :    X position.  <code>y</code> :    Y position. SpriteSheet Spritesheet info for selecting Sprite part on One line  <code>nbrOfState</code> :    nbr of different states avaliable.  <code>state</code> :    state selected. State State value usable for StateMachine  <code>name</code> :    State name. Velocity Velocity of entity  <code>x</code> :    X speed.  <code>y</code> :    Y speed."},{"location":"ECS/Component/Acceleration/","title":"Acceleration","text":"<p>struct Acceleration</p> <p>Acceleration of entity</p> <code>x</code> X acceleration. <code>y</code> Y acceleration."},{"location":"ECS/Component/Active/","title":"Active","text":"<p>struct Active</p> <p>Defines if the component is active or not (skips all systems for Entity)</p> <code>active</code> is the component Active."},{"location":"ECS/Component/Animation/","title":"Animation","text":"<p>struct Animation</p> <p>Animation rect of entity</p> <code>rect</code> Frame for sprite. <code>fps</code> Frame per second."},{"location":"ECS/Component/Drawable/","title":"Drawable","text":"<p>struct Drawable</p> <p>Visual for entity</p> <code>sprite</code> Sprite."},{"location":"ECS/Component/Hitbox/","title":"Hitbox","text":"<p>struct Hitbox</p> <p>Rectangle box for collisions/zone/etc...</p> <code>x</code> X outset. <code>y</code> Y outset. <code>w</code> width. <code>h</code> height."},{"location":"ECS/Component/LuaScript/","title":"LuaScript","text":"<p>struct LuaScript</p> <p>Lua Scripting on entity</p> <code>filepath</code> State name."},{"location":"ECS/Component/Position/","title":"Position","text":"<p>struct Position</p> <p>Position inside world space</p> <code>x</code> X position. <code>y</code> Y position."},{"location":"ECS/Component/SpriteSheet/","title":"SpriteSheet","text":"<p>struct SpriteSheet</p> <p>Spritesheet info for selecting Sprite part on One line</p> <code>nbrOfState</code> nbr of different states avaliable. <code>state</code> state selected."},{"location":"ECS/Component/State/","title":"State","text":"<p>struct State</p> <p>State value usable for StateMachine</p> <code>name</code> State name."},{"location":"ECS/Component/Velocity/","title":"Velocity","text":"<p>struct Velocity</p> <p>Velocity of entity</p> <code>x</code> X speed. <code>y</code> Y speed."},{"location":"Flint/","title":"Flint","text":"Exceptions"},{"location":"Flint/#types","title":"Types","text":"Name Description Colors This class defined a good set of ANSI colors. CxxABI Wrapper around usefull C++/C low level functions Got demangle, backtrace... !!! tip This class is only made of static functions. It does not contain constructor, nor destructor This means that you don't need to instanciate it, and only use it as if it was a namespace. Inspection Base class to implement simplet self-reflexion in C++  <code>T</code> :    Child class itself !!! tip When creating a child class, define as follow : <code>cpp class ChildClass: public Inspection&lt;ChildClass&gt;</code> This will extand the ChildClass with the self-reflexion class Inspection !!! warning If the class you want to extand as a reflected class will be a parent class (I.E. You will create childs of this \"target\" class), you might want to mark inheritence as virtual. This is needed if your child class also need to be reflected. This way, there is no confilict between the parent reflexion, and the child reflexion."},{"location":"Flint/Colors/","title":"Colors","text":"<p>class Colors</p> <p>This class defined a good set of ANSI colors.</p> <p>Tip</p> <p>It is recomended to use those through streams : std::cout &lt;&lt; Flint::Colors::GREEN &lt;&lt; \"Hacker time\" &lt;&lt; Flint::Colors::RESET &lt;&lt; std::endl;</p> <p>Info</p> <p>Please ALWAYS remember to close your colors with Flint::Colors::RESET. Failure to do si might result in broken displays, with weird colors everywhere</p>"},{"location":"Flint/CxxABI/","title":"CxxABI","text":"<p>class CxxABI</p> <p>Wrapper around usefull C++/C low level functions</p> <p>Got demangle, backtrace...</p> <p>Tip</p> <p>This class is only made of static functions. It does not contain constructor, nor destructor This means that you don't need to instanciate it, and only use it as if it was a namespace.</p>"},{"location":"Flint/CxxABI/#functions","title":"Functions","text":"Name Description demangle Demangle a C++ name. getFuncInfos Get functions infos from symbol extraction  Return :    A pair with the function names demangled, and the offset from the function !!! warning The function name is not EXACTLY the real name of the function. Also, the offset DOES NOT correspond to the line number, but the offset of asm instructions getBacktrace Retreive the execution trace  Return :    Vector of pair, string&gt;. I'll explain The idea is to retrieive the file, line, and function. So that's what we do : pair or : (file, line), function !!! warning To correctly grab function names, you will need to add compilation flag \"-rdynamic\" See this lib's CMakeLists.txt for implementation. This will export ALL symbols. If NOT done, you will get offsets from binary. It's ok, but quite disgusting on output."},{"location":"Flint/CxxABI/#function-details","title":"Function Details","text":""},{"location":"Flint/CxxABI/#demangle","title":"demangle","text":"<p>static std::string demangle(const char* name)</p> <p>Demangle a C++ name.</p> <p>This is usefull for : Class names, backtrace...</p> Return string containing : demangled name, or original name, if demangle did not work"},{"location":"Flint/CxxABI/#getfuncinfos","title":"getFuncInfos","text":"<p>static std::pair&lt;std::string, std::size_t&gt; getFuncInfos(const char* symbolInfos)</p> <p>Get functions infos from symbol extraction</p> Return A pair with the function names demangled, and the offset from the function <p>Warning</p> <p>The function name is not EXACTLY the real name of the function. Also, the offset DOES NOT correspond to the line number, but the offset of asm instructions</p>"},{"location":"Flint/CxxABI/#getbacktrace","title":"getBacktrace","text":"<p>static std::vector&lt;std::pair&lt;std::string, std::size_t&gt;&gt; getBacktrace()</p> <p>Retreive the execution trace</p> Return Vector of pair, string&gt;. I'll explain <p>The idea is to retrieive the file, line, and function. So that's what we do : pair or : (file, line), function</p> <p>Warning</p> <p>To correctly grab function names, you will need to add compilation flag \"-rdynamic\" See this lib's CMakeLists.txt for implementation. This will export ALL symbols. If NOT done, you will get offsets from binary. It's ok, but quite disgusting on output.</p>"},{"location":"Flint/Inspection/","title":"Inspection","text":"<p>template &lt;typename T&gt; class Inspection</p> <p>Base class to implement simplet self-reflexion in C++</p> <code>T</code> Child class itself <p>Tip</p> <p>When creating a child class, define as follow : <pre><code>class ChildClass: public Inspection&lt;ChildClass&gt;\n</code></pre> This will extand the ChildClass with the self-reflexion class Inspection</p> <p>Warning</p> <p>If the class you want to extand as a reflected class will be a parent class (I.E. You will create childs of this \"target\" class), you might want to mark inheritence as virtual. This is needed if your child class also need to be reflected. This way, there is no confilict between the parent reflexion, and the child reflexion.</p>"},{"location":"Flint/Inspection/#operators","title":"Operators","text":"Name Description operator&lt;&lt; Overload the operator &lt;&lt; to use the str method of the object  <code>T</code> :    Reflected class  <code>os</code> :    Reference of ostream (I.E. std::cout, std::cerr...)  <code>obj</code> :    Object reference to be displayed  Return :    Param os"},{"location":"Flint/Inspection/#functions","title":"Functions","text":"Name Description getClassName Return the name of the reflected class  Return :    The demangled name of the class, or just the name, if demangleing failed str Return a string representation of the class !!! tip This function is not intended to be used. This is because this functions display the reflection. You might prefer to override this function in yout child class to display informations that are more relevant to your specific class. !!! example You have a Macro available to make the str function really easilly : <code>cpp display_attr(attribute)</code> Which will automaticly translate to <code>cpp Flint::Colors::F_BLUE &lt;&lt; \"attribute\" &lt;&lt; Flint::Colors::RESET &lt;&lt; \"=\" &lt;&lt; Flint::Colors::RED &lt;&lt; this-&gt;attribute &lt;&lt; Flint::Colors::RESET</code> There is also a <code>make_str</code> macro, which you can use as follow : <code>cpp return make_str(\"a=12\" &lt;&lt; \", \" &lt;&lt; \"b=5\");</code> that becomes <code>cpp return ({std::stringstream ss; ss &lt;&lt; \"&lt;\" &lt;&lt; this-&gt;getClassName() &lt;&lt; \" at \" &lt;&lt; std::hex &lt;&lt; this &lt;&lt; \": \" &lt;&lt; \"a=12\" &lt;&lt; \", \" &lt;&lt; \"b=5\" &lt;&lt; \"&gt;\"; ss.str()})</code> It means you can define the str function of your class as like that : <code>cpp // Provided you have 3 attributes called a, b and c return make_str(display_attr(a) &lt;&lt; \", \" &lt;&lt; display_attr(b) &lt;&lt; \", \" &lt;&lt; display_attr(c));</code> Return :    The string representation of the class"},{"location":"Flint/Inspection/#operator-details","title":"Operator Details","text":""},{"location":"Flint/Inspection/#operator","title":"operator&lt;&lt;","text":"<p>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Inspection&lt;T&gt;&amp; obj)</p> <p>Overload the operator &lt;&lt; to use the str method of the object</p> <code>T</code> Reflected class <code>os</code> Reference of ostream (I.E. std::cout, std::cerr...) <code>obj</code> Object reference to be displayed Return Param os"},{"location":"Flint/Inspection/#function-details","title":"Function Details","text":""},{"location":"Flint/Inspection/#getclassname","title":"getClassName","text":"<p>virtual std::string getClassName() const final</p> <p>Return the name of the reflected class</p> Return The demangled name of the class, or just the name, if demangleing failed"},{"location":"Flint/Inspection/#str","title":"str","text":"<p>virtual std::string str() const</p> <p>Return a string representation of the class</p> <p>Tip</p> <p>This function is not intended to be used. This is because this functions display the reflection. You might prefer to override this function in yout child class to display informations that are more relevant to your specific class.</p> <p>Example</p> <p>You have a Macro available to make the str function really easilly : <pre><code>display_attr(attribute)\n</code></pre> Which will automaticly translate to <pre><code>Flint::Colors::F_BLUE &lt;&lt; \"attribute\" &lt;&lt; Flint::Colors::RESET &lt;&lt; \"=\" &lt;&lt; Flint::Colors::RED &lt;&lt; this-&gt;attribute &lt;&lt; Flint::Colors::RESET\n</code></pre> There is also a <code>make_str</code> macro, which you can use as follow : <pre><code>return make_str(\"a=12\" &lt;&lt; \", \" &lt;&lt; \"b=5\");\n</code></pre> that becomes <pre><code>return ({std::stringstream ss; ss &lt;&lt; \"&lt;\" &lt;&lt; this-&gt;getClassName() &lt;&lt; \" at \" &lt;&lt; std::hex &lt;&lt; this &lt;&lt; \": \" &lt;&lt; \"a=12\" &lt;&lt; \", \" &lt;&lt; \"b=5\" &lt;&lt; \"&gt;\"; ss.str()})\n</code></pre> It means you can define the str function of your class as like that : <pre><code>// Provided you have 3 attributes called a, b and c\nreturn make_str(display_attr(a) &lt;&lt; \", \" &lt;&lt; display_attr(b) &lt;&lt; \", \" &lt;&lt; display_attr(c));\n</code></pre></p> Return The string representation of the class"},{"location":"Flint/Exceptions/","title":"Exceptions","text":""},{"location":"Flint/Exceptions/#types","title":"Types","text":"Name Description Exception Wrapper arround default std::exception Store the the exception description as std::string, and store some usefull localisation informations: Filename, Line, and Function Name. This is automated using the throw_exception preprocessor directive. !!! tip Take a look at the NotImplementedError to see how easy it is to implmeent your own Flint::Exception. NotImplementedError Sample Flint::Exceptions::Exception to register NotImplemented features !!! tip You should use that Exception as a C++ Implementation of the Rust todo!() macro. !!! example <code>cpp throw_exception(Flint::Exceptions::NotImplementedError, \"This function haven't been implemented as of today !\");</code>"},{"location":"Flint/Exceptions/Exception/","title":"Exception","text":"<p>class Exception: public std::exception</p> <p>Wrapper arround default std::exception</p> <p>Store the the exception description as std::string, and store some usefull localisation informations: Filename, Line, and Function Name. This is automated using the throw_exception preprocessor directive.</p> <p>Tip</p> <p>Take a look at the NotImplementedError to see how easy it is to implmeent your own Flint::Exception.</p>"},{"location":"Flint/Exceptions/Exception/#operators","title":"Operators","text":"Name Description operator&lt;&lt; operator&lt;&lt; override !!! abstract This will simply append the _what to the ostream"},{"location":"Flint/Exceptions/Exception/#functions","title":"Functions","text":"Name Description Exception Exception constructor. getInfos Retreive given infos (filename, line, and function name)  Return :    The actual infos getClassNameFromStackTrace Try to retreive the Exception class name from the StackTrace. show Display the error, given specific positional infos (like the constructor). what Required override, deprecated by show and catch_exception."},{"location":"Flint/Exceptions/Exception/#operator-details","title":"Operator Details","text":""},{"location":"Flint/Exceptions/Exception/#operator","title":"operator&lt;&lt;","text":"<p>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Exceptions::Exception&amp; obj)</p> <p>operator&lt;&lt; override</p> <p>Abstract</p> <p>This will simply append the _what to the ostream</p>"},{"location":"Flint/Exceptions/Exception/#function-details","title":"Function Details","text":""},{"location":"Flint/Exceptions/Exception/#exception_1","title":"Exception","text":"<p>Exception(const std::string&amp; what = \"An exception occured !\", std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; infos = {{\"\", 0}, \"\"})</p> <p>Exception constructor. This need to be called, even on child classes.</p> <code>what</code> Define the exception's description <code>infos</code> Might contain positional infos <p>Warning</p> <p>You should NOT use any excpetion constructor manually. While they might work, the prefered way is to use the throw_exception preprocessor directive. Using it will only require you to register what type of excpetion you want to throw, and what message you want to add, and will take care of putting file name, line, and function name</p>"},{"location":"Flint/Exceptions/Exception/#getinfos","title":"getInfos","text":"<p>std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; getInfos() const</p> <p>Retreive given infos (filename, line, and function name)</p> Return The actual infos"},{"location":"Flint/Exceptions/Exception/#getclassnamefromstacktrace","title":"getClassNameFromStackTrace","text":"<p>std::string getClassNameFromStackTrace(const std::vector&lt;std::pair&lt;std::string, std::size_t&gt;&gt;&amp; stackTrace) const</p> <p>Try to retreive the Exception class name from the StackTrace.</p> <code>stackTrace</code> A stack trace, formated like CxxABI::getBacktrace() <p>Warning</p> <p>This function DOES NOT WORK 100% OF THE TIME. It is really dependant on the environement, and can return undefined without aparent reason. It should NOT be used for anything else than debug or display.</p> Return The actual class name or \"[Class name undefined]\""},{"location":"Flint/Exceptions/Exception/#show","title":"show","text":"<p>std::string show(std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; infos) const</p> <p>Display the error, given specific positional infos (like the constructor).</p> <code>infos</code> Positional informations, like the constructor, used to display the infos. <p>Note</p> <p>This function, while being usable without, should be used through the catch_exception preprocessor directive. This preprocessor directive let you display Python like excpetion trace.</p> Return The formated exception, ready to be displayed."},{"location":"Flint/Exceptions/Exception/#what","title":"what","text":"<p>const char* what() const noexcept override</p> <p>Required override, deprecated by show and catch_exception.</p> <p>Info</p> <p>This is the required std::exception override. It'll return the _what as a const char*. While this will work, prefer using the show function or the catch_excpetion preprocessor directive :</p> <p>Example</p> <pre><code>try {\n    throw_exception(Flint::Exceptions::Exception, \"Sample testing exception\");\n} catch (const Flint::Exceptions::Exception&amp; e) {\n    std::cerr &lt;&lt; catch_exception(e) &lt;&lt; std::endl;\n}\n</code></pre> Return The _what as a C string"},{"location":"Flint/Exceptions/NotImplementedError/","title":"NotImplementedError","text":"<p>class NotImplementedError: public Flint::Exceptions::Exception</p> <p>Sample Flint::Exceptions::Exception to register NotImplemented features</p> <p>Tip</p> <p>You should use that Exception as a C++ Implementation of the Rust todo!() macro.</p> <p>Example</p> <pre><code>throw_exception(Flint::Exceptions::NotImplementedError, \"This function haven't been implemented as of today !\");\n</code></pre>"},{"location":"coverage/","title":"Code Coverage","text":"Name Lines Covered Uncovered Coverage ecs 203 0 203 0.0% src 203 0 203 0.0% Component 39 0 39 0.0% ComponentStorage.hpp 9 0 9 0.0% Components.hpp 30 0 30 0.0% SparceArray 16 0 16 0.0% SparceArray.hpp 16 0 16 0.0% AssetStorage.cpp 0 0 0 100.0% AssetStorage.hpp 0 0 0 100.0% ComponentManager.cpp 0 0 0 100.0% ComponentManager.hpp 18 0 18 0.0% ECSManager.cpp 7 0 7 0.0% ECSManager.hpp 5 0 5 0.0% Entity.hpp 2 0 2 0.0% EntityManager.cpp 11 0 11 0.0% EntityManager.hpp 0 0 0 100.0% ErrorException.hpp 2 0 2 0.0% EventManager.cpp 0 0 0 100.0% EventManager.hpp 0 0 0 100.0% GUI_SFML_Graphics.hpp 0 0 0 100.0% Headers.hpp 0 0 0 100.0% Registry.hpp 19 0 19 0.0% SystemManager.cpp 5 0 5 0.0% SystemManager.hpp 3 0 3 0.0% Systems.hpp 76 0 76 0.0% flint 93 44 49 47.3% src 93 44 49 47.3% Colors 0 0 0 100.0% Colors.cpp 0 0 0 100.0% Colors.hpp 0 0 0 100.0% CxxABI 34 26 8 76.5% CxxABI.cpp 34 26 8 76.5% CxxABI.hpp 0 0 0 100.0% Exceptions 44 17 27 38.6% Exceptions.cpp 43 17 26 39.5% Exceptions.hpp 1 0 1 0.0% Init 6 1 5 16.7% Init.cpp 6 1 5 16.7% Init.hpp 0 0 0 100.0% hpp 8 0 8 0.0% Debug.hpp 0 0 0 100.0% Inspection.hpp 8 0 8 0.0% Preprocessor.hpp 0 0 0 100.0% Flint.hpp 0 0 0 100.0% Headers.hpp 1 0 1 0.0% network 58 25 33 43.1% src 58 25 33 43.1% Security 58 25 33 43.1% DecodeError.hpp 3 0 3 0.0% GaloisField.cpp 8 0 8 0.0% GaloisField.hpp 1 0 1 0.0% HammingCodes.cpp 42 25 17 59.5% HammingCodes.hpp 1 0 1 0.0% ReedSolomon.cpp 2 0 2 0.0% ReedSolomon.hpp 1 0 1 0.0% export.hpp 0 0 0 100.0% server 67 0 67 0.0% bak 21 0 21 0.0% main.cpp 21 0 21 0.0% src 46 0 46 0.0% ConfigParser.cpp 15 0 15 0.0% ConfigParser.hpp 0 0 0 100.0% Romm.cpp 25 0 25 0.0% Room.hpp 0 0 0 100.0% main.cpp 6 0 6 0.0% Summary 39 0 39 0.0% Summary 16 0 16 0.0% Summary 203 0 203 0.0% Summary 203 0 203 0.0% Summary 0 0 0 100.0% Summary 34 26 8 76.5% Summary 44 17 27 38.6% Summary 6 1 5 16.7% Summary 8 0 8 0.0% Summary 93 44 49 47.3% Summary 93 44 49 47.3% Summary 58 25 33 43.1% Summary 58 25 33 43.1% Summary 58 25 33 43.1% Summary 21 0 21 0.0% Summary 46 0 46 0.0% Summary 67 0 67 0.0% Summary 421 69 352 16.4%"},{"location":"coverage/ecs/","title":"ecs","text":"Name Lines Covered Uncovered Coverage src 203 0 203 0.0% Component 39 0 39 0.0% ComponentStorage.hpp 9 0 9 0.0% Components.hpp 30 0 30 0.0% SparceArray 16 0 16 0.0% SparceArray.hpp 16 0 16 0.0% AssetStorage.cpp 0 0 0 100.0% AssetStorage.hpp 0 0 0 100.0% ComponentManager.cpp 0 0 0 100.0% ComponentManager.hpp 18 0 18 0.0% ECSManager.cpp 7 0 7 0.0% ECSManager.hpp 5 0 5 0.0% Entity.hpp 2 0 2 0.0% EntityManager.cpp 11 0 11 0.0% EntityManager.hpp 0 0 0 100.0% ErrorException.hpp 2 0 2 0.0% EventManager.cpp 0 0 0 100.0% EventManager.hpp 0 0 0 100.0% GUI_SFML_Graphics.hpp 0 0 0 100.0% Headers.hpp 0 0 0 100.0% Registry.hpp 19 0 19 0.0% SystemManager.cpp 5 0 5 0.0% SystemManager.hpp 3 0 3 0.0% Systems.hpp 76 0 76 0.0% Summary 39 0 39 0.0% Summary 16 0 16 0.0% Summary 203 0 203 0.0% Summary 203 0 203 0.0%"},{"location":"coverage/ecs/src/","title":"src","text":"Name Lines Covered Uncovered Coverage Component 39 0 39 0.0% ComponentStorage.hpp 9 0 9 0.0% Components.hpp 30 0 30 0.0% SparceArray 16 0 16 0.0% SparceArray.hpp 16 0 16 0.0% AssetStorage.cpp 0 0 0 100.0% AssetStorage.hpp 0 0 0 100.0% ComponentManager.cpp 0 0 0 100.0% ComponentManager.hpp 18 0 18 0.0% ECSManager.cpp 7 0 7 0.0% ECSManager.hpp 5 0 5 0.0% Entity.hpp 2 0 2 0.0% EntityManager.cpp 11 0 11 0.0% EntityManager.hpp 0 0 0 100.0% ErrorException.hpp 2 0 2 0.0% EventManager.cpp 0 0 0 100.0% EventManager.hpp 0 0 0 100.0% GUI_SFML_Graphics.hpp 0 0 0 100.0% Headers.hpp 0 0 0 100.0% Registry.hpp 19 0 19 0.0% SystemManager.cpp 5 0 5 0.0% SystemManager.hpp 3 0 3 0.0% Systems.hpp 76 0 76 0.0% Summary 39 0 39 0.0% Summary 16 0 16 0.0% Summary 203 0 203 0.0%"},{"location":"coverage/ecs/src/AssetStorage.cpp/","title":"AssetStorage.cpp","text":""},{"location":"coverage/ecs/src/AssetStorage.hpp/","title":"AssetStorage.hpp","text":"<pre><code>// /*\n// ** EPITECH PROJECT, 2024\n// ** RType\n// ** File description:\n// ** EntityManager Class\n// */\n\n// #ifndef SPARCE_ARRAY_HPP_\n//     #define SPARCE_ARRAY_HPP_\n\n//     #include &lt;memory&gt;\n//     #include &lt;queue&gt;\n//     #include &lt;map&gt;\n//     #include &lt;unordered_map&gt;\n\n//     namespace ECS\n//     {\n\n//         class AssetStorage {\n\n//             public:\n\n\n//             private:\n//                 std::unordered_map&lt;std::string, sf::Sprite&gt; _data;\n\n//         }\n\n//     };\n// #endif\n</code></pre>"},{"location":"coverage/ecs/src/ComponentManager.cpp/","title":"ComponentManager.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** ComponentManager\n** File description:\n** Component Manager\n*/\n\n#include \"ComponentManager.hpp\"\n\nECS::ComponentManager::ComponentManager()\n{\n\n}\n</code></pre>"},{"location":"coverage/ecs/src/ComponentManager.hpp/","title":"ComponentManager.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** RType\n** File description:\n** EntityManager Class\n*/\n\n#ifndef COMPONENT_MANAGER_HPP_\n    #define COMPONENT_MANAGER_HPP_\n\n    #include &lt;typeindex&gt;\n    #include &lt;any&gt;\n    #include &lt;iostream&gt;\n    #include &lt;optional&gt;\n    #include &lt;memory&gt;\n    #include &lt;queue&gt;\n    #include &lt;map&gt;\n    #include &lt;unordered_map&gt;\n\n    #include \"Entity.hpp\"\n    #include \"Component/Components.hpp\"\n    #include \"Component/ComponentStorage.hpp\"\n\n    namespace ECS\n    {\n        class ComponentManager {\n\n            public:\n                ComponentManager();\n\n                template &lt;typename Component&gt;\n                void addComponent(ECS::entity_id id, Component component) {\n                    std::type_index index = typeid(Component);\n                    if (this-&gt;_components.find(index) == this-&gt;_components.end()) {\n                        this-&gt;registerComponentStorage&lt;Component&gt;();\n                    }\n                    auto&amp; storage = getComponentStorage&lt;Component&gt;();\n                    storage.add(id, std::move(std::make_shared&lt;Component&gt;(component)));\n                    this-&gt;_entityWithComponent[index].push_back(id);\n                }\n\n                template &lt;typename Component&gt;\n                void removeComponent(ECS::entity_id id) {\n                    std::type_index index = typeid(Component);\n                    auto&amp; storage = getComponentStorage&lt;Component&gt;();\n                    storage.remove(id);\n                    this-&gt;_entityWithComponent[index].erase(std::remove(this-&gt;_entityWithComponent[index].begin(), this-&gt;_entityWithComponent[index].end(), id), this-&gt;_entityWithComponent[index].end());\n                }\n\n                void removeAllComponents(ECS::entity_id id)\n                {\n                    for (auto &amp;e : this-&gt;_components) {\n                        this-&gt;_components[e.first]-&gt;remove(id);\n                        this-&gt;_entityWithComponent[e.first].erase(std::remove(this-&gt;_entityWithComponent[e.first].begin(), this-&gt;_entityWithComponent[e.first].end(), id), this-&gt;_entityWithComponent[e.first].end());\n                    }\n                }\n\n                template &lt;typename Component&gt;\n                std::optional&lt;std::shared_ptr&lt;Component&gt;&gt; getComponent(ECS::entity_id id) {\n                    return getComponentStorage&lt;Component&gt;().get(id);\n                }\n\n                template &lt;typename Component&gt;\n                std::shared_ptr&lt;ComponentStorage&lt;Component&gt;&gt; getComponents() {\n                    return getComponentStorage&lt;Component&gt;();\n                }\n\n                template &lt;typename Component&gt;\n                std::vector&lt;ECS::entity_id&gt; getEntitiesWithComponent()\n                {\n                    return _entityWithComponent[typeid(Component)];\n                }\n\n                template &lt;typename Component&gt;\n                ComponentStorage&lt;Component&gt;&amp; getComponentStorage() {\n                    return *static_cast&lt;ComponentStorage&lt;Component&gt;*&gt;(_components[typeid(Component)].get());\n                }\n\n                template &lt;typename Component&gt;\n                void registerComponentStorage() {\n                    _components[typeid(Component)] = std::make_shared&lt;ComponentStorage&lt;Component&gt;&gt;();\n                }\n\n            private:\n                std::unordered_map&lt;std::type_index, std::vector&lt;ECS::entity_id&gt;&gt; _entityWithComponent;\n                std::unordered_map&lt;std::type_index, std::shared_ptr&lt;ComponentStorageBase&gt;&gt; _components;\n        };\n    }\n\n#endif\n</code></pre>"},{"location":"coverage/ecs/src/ECSManager.cpp/","title":"ECSManager.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** EpiGimp\n** File description:\n** main\n*/\n\n#include \"ECSManager.hpp\"\n\nECS::ECSManager::ECSManager()\n{\n    this-&gt;_registry = std::make_unique&lt;ECS::Registry&gt;();\n    this-&gt;_systemManager = std::make_unique&lt;ECS::SystemManager&gt;();\n}\nECS::ECSManager::~ECSManager()\n{\n\n}\n\nconst ECS::entity_id &amp;ECS::ECSManager::createEntity()\n{\n    return this-&gt;_registry-&gt;createEntity();\n}\n\nvoid ECS::ECSManager::destroyEntity(const entity_id &amp;id)\n{\n    this-&gt;_registry-&gt;destroyEntity(id);\n}\n\nstd::vector&lt;ECS::entity_id&gt; ECS::ECSManager::getAllEntities()\n{\n    return this-&gt;_registry-&gt;getAllEntities();\n}\n\nvoid ECS::ECSManager::removeAllComponents(ECS::entity_id id)\n{\n    this-&gt;_registry-&gt;removeAllComponents(id);\n}\n\nvoid ECS::ECSManager::runAllSystems()\n{\n    this-&gt;_systemManager-&gt;runAllSystems(*this-&gt;_registry);\n}\n</code></pre>"},{"location":"coverage/ecs/src/ECSManager.hpp/","title":"ECSManager.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** RType\n** File description:\n** EntityManager Class\n*/\n\n#ifndef ECSMANAGER_HPP_\n    #define ECSMANAGER_HPP_\n\n    #include &lt;memory&gt;\n\n    #include \"Registry.hpp\"\n    #include \"SystemManager.hpp\"\n\n    namespace ECS\n    {\n        class ECSManager {\n\n            public:\n                ECSManager();\n                ~ECSManager();\n\n                const ECS::entity_id &amp;createEntity();\n                void destroyEntity(const entity_id &amp;id);\n                std::vector&lt;ECS::entity_id&gt; getAllEntities();\n\n                template &lt;typename Component&gt;\n                void addComponent(ECS::entity_id id, Component comp)\n                {\n                    this-&gt;_registry-&gt;addComponent(id, comp);\n                }\n\n                template &lt;typename Component&gt;\n                void removeComponent(ECS::entity_id id)\n                {\n                    this-&gt;_registry-&gt;removeComponent&lt;Component&gt;(id);\n                }\n\n                void removeAllComponents(ECS::entity_id id);\n\n                template &lt;typename Component&gt;\n                std::shared_ptr&lt;Component&gt; getComponent(ECS::entity_id id)\n                {\n                    return this-&gt;_registry-&gt;getComponent&lt;Component&gt;(id);\n                }\n\n                template &lt;typename Component&gt;\n                std::vector&lt;ECS::entity_id&gt; getEntitiesWithComponent()\n                {\n                    return this-&gt;_registry-&gt;getEntitiesWithComponent&lt;Component&gt;();\n                }\n\n                template &lt;typename System, typename... Args&gt;\n                void addSystem(Args&amp;&amp;... args)\n                {\n                    this-&gt;_systemManager-&gt;addSystem&lt;System&gt;(std::forward&lt;Args&gt;(args)...);\n                }\n\n\n                void runAllSystems();\n\n\n            private:\n                std::unique_ptr&lt;ECS::Registry&gt; _registry;\n                std::unique_ptr&lt;ECS::SystemManager&gt; _systemManager;\n\n        };\n    }\n\n#endif\n</code></pre>"},{"location":"coverage/ecs/src/Entity.hpp/","title":"Entity.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** RType\n** File description:\n** Entity Class\n*/\n\n#ifndef ENTITY_HPP_\n    #define ENTITY_HPP_\n\n    #include &lt;memory&gt;\n\n    namespace ECS\n    {\n        using entity_id = std::size_t;\n\n        class Entity {\n\n            public:\n                // Explicit constructor to prevent implicit construction from size_t\n                explicit Entity(entity_id val) : _id(val) {}\n\n                // Implicit conversion operator to size_t\n                operator size_t() const { return _id; }\n\n            protected:\n                entity_id _id;\n        };\n    }\n\n#endif\n</code></pre>"},{"location":"coverage/ecs/src/EntityManager.cpp/","title":"EntityManager.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** EpiGimp\n** File description:\n** main\n*/\n\n#include &lt;iostream&gt;\n#include \"EntityManager.hpp\"\n\nECS::EntityManager::EntityManager()\n{\n    for (ECS::entity_id id = 0; id &lt; ECS_MAX_ENTITY; id++) {\n        this-&gt;_emptyIDs.push(id);\n    }\n}\n\nconst ECS::entity_id &amp;ECS::EntityManager::createEntity()\n{\n    const ECS::entity_id &amp;newID = this-&gt;_emptyIDs.front();\n    this-&gt;_emptyIDs.pop();\n\n    ECS::Entity newEntity(newID);\n    this-&gt;_entities[newID] = newEntity;\n    return newID;\n}\n\nvoid ECS::EntityManager::destroyEntity(const ECS::entity_id &amp;id)\n{\n    this-&gt;_emptyIDs.push(id);\n    this-&gt;_entities[id].reset();\n}\n\nstd::vector&lt;ECS::entity_id&gt; ECS::EntityManager::getAllEntities()\n{\n    std::vector&lt;ECS::entity_id&gt; list;\n    for (auto &amp;e : this-&gt;_entities) {\n        list.push_back(e.first);\n    }\n\n    return list;\n}\n</code></pre>"},{"location":"coverage/ecs/src/EntityManager.hpp/","title":"EntityManager.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** RType\n** File description:\n** EntityManager Class\n*/\n\n#ifndef ENTITY_MANAGER_HPP_\n    #define ENTITY_MANAGER_HPP_\n\n    #include &lt;memory&gt;\n    #include &lt;queue&gt;\n    #include &lt;map&gt;\n    #include &lt;unordered_map&gt;\n\n    #include \"Entity.hpp\"\n\n    namespace ECS\n    {\n        class EntityManager {\n\n            public:\n                EntityManager();\n\n                const entity_id &amp;createEntity();\n                void destroyEntity(const entity_id &amp;id);\n                std::vector&lt;ECS::entity_id&gt; getAllEntities();\n\n            private:\n                std::queue&lt;ECS::entity_id&gt; _emptyIDs;\n                std::unordered_map&lt;ECS::entity_id, std::optional&lt;ECS::Entity&gt;&gt; _entities;\n                std::vector&lt;ECS::entity_id&gt; _usedIDs;\n\n        };\n\n    }\n\n#endif\n\n#define ECS_MAX_ENTITY 32000\n</code></pre>"},{"location":"coverage/ecs/src/ErrorException.hpp/","title":"ErrorException.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** EpiGimp\n** File description:\n** ErrorException\n*/\n\n#pragma once\n\nclass ErrorException : public std::exception {\n    public:\n        ErrorException(const std::string &amp;message) : _message(message) {}\n        ~ErrorException() = default;\n        const char *what() const noexcept override { return _message.c_str(); }\n\n    private:\n        std::string _message;\n};\n</code></pre>"},{"location":"coverage/ecs/src/EventManager.cpp/","title":"EventManager.cpp","text":"<pre><code>// /*\n// ** EPITECH PROJECT, 2024\n// ** EpiGimp\n// ** File description:\n// ** main\n// */\n\n// #include \"EventManager.hpp\"\n\n// ECS::EventManager::EventManager(lua_State* state)\n// {\n//     this-&gt;_luaState = state\n// }\n\n// // Registers a Lua function to be called on an event\n// void ECS::EventManager::registerEvent(const std::string&amp; eventName, const std::string&amp; luaFunction)\n// {\n//     eventCallbacks[eventName] = luaFunction;\n// }\n// // Trigger an event, invoking the Lua function if registered\n// void ECS::EventManager::triggerEvent(const std::string&amp; eventName)\n// {\n//     auto it = eventCallbacks.find(eventName);\n//     if (it != eventCallbacks.end()) {\n//         const std::string&amp; luaFunction = it-&gt;second;\n//         // Call the Lua function with the event name as an argument\n//         lua_getglobal(_luaState, luaFunction.c_str());\n//         lua_pushstring(_luaState, eventName.c_str());\n//         if (lua_pcall(L, 1, 0, 0) != 0) {\n//             std::cerr &lt;&lt; \"Error calling Lua function: \" &lt;&lt; lua_tostring(L, -1) &lt;&lt; std::endl;\n//         }\n//     } else {\n//         std::cerr &lt;&lt; \"No handler for event: \" &lt;&lt; eventName &lt;&lt; std::endl;\n//     }\n// }\n</code></pre>"},{"location":"coverage/ecs/src/EventManager.hpp/","title":"EventManager.hpp","text":"<pre><code>/*\n// ** EPITECH PROJECT, 2024\n// ** RType\n// ** File description:\n// ** EntityManager Class\n// */\n\n// #ifndef EVENT_MANAGER_HPP_\n//     #define EVENT_MANAGER_HPP_\n\n//     #include \"&lt;sol/sol.hpp&gt;\"\n//     #include &lt;string&gt;\n//     #include &lt;unordered_map&gt;\n//     #include &lt;memory&gt;\n//     #include &lt;functional&gt;\n//     #include &lt;iostream&gt;\n\n//     namespace ECS\n//     {\n\n//         class EventManager {\n//             public:\n//                 EventManager(lua_State* state);\n\n//                 // Registers a Lua function to be called on an event\n//                 void registerEvent(const std::string&amp; eventName, const std::string&amp; luaFunction);\n\n//                 // Trigger an event, invoking the Lua function if registered\n//                 void triggerEvent(const std::string&amp; eventName);\n\n//                 private:\n//                     lua_State* _luaState;\n//                     std::unordered_map&lt;std::string, std::string&gt; eventCallbacks;  // Maps event names to Lua function names\n//             };\n\n//     }\n\n// #endif\n</code></pre>"},{"location":"coverage/ecs/src/GUI_SFML_Graphics.hpp/","title":"GUI_SFML_Graphics.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Cpp-Project-Template\n** File description:\nEpiGimp\n*/\n\n#ifndef GRAPHICS_H_\n    #define GRAPHICS_H_\n\n    #include &lt;SFML/Graphics.hpp&gt;\n    #include &lt;SFML/Audio.hpp&gt;\n    #include &lt;SFML/System.hpp&gt;\n    #include &lt;SFML/Window.hpp&gt;\n\n#endif\n</code></pre>"},{"location":"coverage/ecs/src/Headers.hpp/","title":"Headers.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Cpp-Project-Template\n** File description:\nEpiGimp\n*/\n\n#ifndef HEADERS_H_\n    #define HEADERS_H_\n\n    #include &lt;fstream&gt;\n    #include &lt;iomanip&gt;\n    #include &lt;iostream&gt;\n    #include &lt;memory&gt;\n    #include &lt;stdlib.h&gt;\n    #include &lt;sstream&gt;\n    #include &lt;string&gt;\n    #include &lt;vector&gt;\n    #include &lt;exception&gt;\n    #include &lt;map&gt;\n    #include &lt;queue&gt;\n    #include &lt;functional&gt;\n    #include &lt;sys/types.h&gt;\n    #include &lt;arpa/inet.h&gt;\n    #include &lt;unistd.h&gt;\n    #include &lt;regex&gt;\n    #include &lt;unordered_map&gt;\n    #include &lt;math.h&gt;\n    #include &lt;random&gt;\n    #include &lt;filesystem&gt;\n    #include &lt;cstdlib&gt;\n\n    #include \"ErrorException.hpp\"\n\n#endif\n</code></pre>"},{"location":"coverage/ecs/src/Registry.hpp/","title":"Registry.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** RType\n** File description:\n** EntityManager Class\n*/\n\n#ifndef REGISTRY_HPP_\n    #define REGISTRY_HPP_\n\n    #include &lt;memory&gt;\n\n    #include \"Component/Components.hpp\"\n\n    #include \"EntityManager.hpp\"\n    #include \"ComponentManager.hpp\"\n\n    namespace ECS\n    {\n        class Registry {\n\n            public:\n                Registry()\n                {\n                    this-&gt;_entityManager = std::make_unique&lt;ECS::EntityManager&gt;();\n                    this-&gt;_componentManager = std::make_unique&lt;ECS::ComponentManager&gt;();\n                }\n\n                ~Registry()\n                {\n                    std::vector&lt;ECS::entity_id&gt; allEntities = this-&gt;_entityManager-&gt;getAllEntities();\n                    for (auto &amp;e : allEntities) {\n                        this-&gt;removeAllComponents(e);\n                        this-&gt;destroyEntity(e);\n                    }\n                }\n\n                const ECS::entity_id &amp;createEntity()\n                {\n                    return this-&gt;_entityManager-&gt;createEntity();\n                }\n\n                void destroyEntity(const entity_id &amp;id)\n                {\n                    this-&gt;_entityManager-&gt;destroyEntity(id);\n                    this-&gt;removeAllComponents(id);\n                }\n\n                std::vector&lt;ECS::entity_id&gt; getAllEntities()\n                {\n                    return this-&gt;_entityManager-&gt;getAllEntities();\n                }\n\n                template &lt;typename Component&gt;\n                void addComponent(ECS::entity_id id, Component comp)\n                {\n                    this-&gt;_componentManager-&gt;addComponent(id, comp);\n                }\n\n                template &lt;typename Component&gt;\n                void removeComponent(ECS::entity_id id)\n                {\n                    this-&gt;_componentManager-&gt;removeComponent&lt;Component&gt;(id);\n                }\n\n                void removeAllComponents(ECS::entity_id id)\n                {\n                    this-&gt;_componentManager-&gt;removeAllComponents(id);\n                }\n\n                template &lt;typename Component&gt;\n                std::shared_ptr&lt;Component&gt; getComponent(ECS::entity_id id)\n                {\n                    std::optional&lt;std::shared_ptr&lt;Component&gt;&gt; comp = this-&gt;_componentManager-&gt;getComponent&lt;Component&gt;(id);\n                    if (comp == std::nullopt) {\n                        return nullptr;\n                    }\n                    return comp.value();\n                }\n\n                template &lt;typename Component&gt;\n                std::vector&lt;ECS::entity_id&gt; getEntitiesWithComponent()\n                {\n                    return this-&gt;_componentManager-&gt;getEntitiesWithComponent&lt;Component&gt;();\n                }\n\n                template &lt;typename Component&gt;\n                ComponentStorage&lt;Component&gt; getComponents() {\n                    // auto&amp; storage = getComponentStorage&lt;Component&gt;();\n                    return this-&gt;_componentManager-&gt;getComponentStorage&lt;Component&gt;();\n                }\n\n\n            private:\n                std::unique_ptr&lt;ECS::ComponentManager&gt; _componentManager;\n                std::unique_ptr&lt;ECS::EntityManager&gt; _entityManager;\n\n        };\n    }\n\n#endif\n</code></pre>"},{"location":"coverage/ecs/src/SystemManager.cpp/","title":"SystemManager.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** SystemManager\n** File description:\n** System Manager\n*/\n\n#include \"SystemManager.hpp\"\n\nECS::SystemManager::SystemManager()\n{\n\n}\n\nECS::SystemManager::~SystemManager()\n{\n\n}\n\nvoid ECS::SystemManager::runAllSystems(ECS::Registry &amp;R)\n{\n    auto currentTime = std::chrono::high_resolution_clock::now();\n    std::chrono::duration&lt;float&gt; dt = currentTime - _lastTime;\n    _lastTime = currentTime;\n\n    for (auto &amp;system : this-&gt;_systems) {\n        system(R, dt.count());\n    }\n}\n</code></pre>"},{"location":"coverage/ecs/src/SystemManager.hpp/","title":"SystemManager.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** RType\n** File description:\n** SystemManager Class\n*/\n\n#ifndef SYSTEM_MANAGER_HPP_\n    #define SYSTEM_MANAGER_HPP_\n\n    #include &lt;memory&gt;\n    #include &lt;functional&gt;\n    #include &lt;chrono&gt;\n\n    #include \"Systems.hpp\"\n    #include \"Registry.hpp\"\n\n    namespace ECS\n    {\n        class SystemManager {\n\n            public:\n                SystemManager();\n                ~SystemManager();\n\n                template &lt;typename System, typename... Args&gt;\n                void addSystem(Args&amp;&amp;... args)\n                {\n                    // Capture the arguments by reference to respect const correctness\n                    this-&gt;_systems.push_back([&amp;args...](ECS::Registry&amp; R, float dt) {\n                        // Forward the arguments to the system constructor\n                        System system(std::forward&lt;Args&gt;(args)...);\n                        system(R, dt);  // Call operator() on the system\n                    });\n                }\n\n                void runAllSystems(ECS::Registry &amp;R);\n\n\n            private:\n                std::vector&lt;std::function&lt;void(ECS::Registry&amp;, float dt)&gt;&gt; _systems;\n                std::chrono::high_resolution_clock::time_point _lastTime;\n\n        };\n    }\n\n#endif\n</code></pre>"},{"location":"coverage/ecs/src/Systems.hpp/","title":"Systems.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** RType\n** File description:\n** ECS Components\n*/\n\n#ifndef SYSTEMS_HPP_\n    #define SYSTEMS_HPP_\n\n    #include &lt;iostream&gt;\n    #include \"GUI_SFML_Graphics.hpp\"\n\n    #include \"Registry.hpp\"\n\n    namespace ECS::System\n    {\n\n        struct Movement {\n\n            void operator()(ECS::Registry &amp;R, float dt)\n            {\n                std::vector&lt;ECS::entity_id&gt; allEntities = R.getEntitiesWithComponent&lt;ECS::Component::Position&gt;();\n                for (auto &amp;entity : allEntities) {\n                    auto pos = R.getComponent&lt;ECS::Component::Position&gt;(entity);\n                    auto vel = R.getComponent&lt;ECS::Component::Velocity&gt;(entity);\n                    if (vel != nullptr) {\n                        pos-&gt;x += vel-&gt;x * dt;\n                        pos-&gt;y += vel-&gt;y * dt;\n                    }\n                }\n            }\n        };\n\n        struct Collision {\n\n            bool checkCollision(const ECS::Component::Hitbox &amp;a, const ECS::Component::Hitbox &amp;b) {\n                return !(a.x + a.w &lt; b.x || a.x &gt; b.x + b.w || a.y + a.h &lt; b.y || a.y &gt; b.y + b.h);\n            }\n\n            void operator()(ECS::Registry &amp;R, float dt)\n            {\n                std::vector&lt;ECS::entity_id&gt; allEntities = R.getEntitiesWithComponent&lt;ECS::Component::Hitbox&gt;();\n                ECS::Component::Hitbox a;\n                ECS::Component::Hitbox b;\n\n                for (size_t i = 0; i &lt; allEntities.size(); ++i) {\n                    auto &amp;entity = allEntities[i];\n                    auto aHitbox = R.getComponent&lt;ECS::Component::Hitbox&gt;(entity);\n                    auto aPos = R.getComponent&lt;ECS::Component::Position&gt;(entity);\n\n                    if (aPos == nullptr) {\n                        continue;\n                    }\n\n                    a = *aHitbox;\n                    a.x += aPos-&gt;x;\n                    a.y += aPos-&gt;y;\n\n                    // Only check entities that come after the current one to avoid double-checking pairs\n                    for (size_t j = i + 1; j &lt; allEntities.size(); ++j) {\n                        auto &amp;otherEntity = allEntities[j];\n                        auto bHitbox = R.getComponent&lt;ECS::Component::Hitbox&gt;(otherEntity);\n                        auto bPos = R.getComponent&lt;ECS::Component::Position&gt;(otherEntity);\n\n                        if (bPos == nullptr) {\n                            continue;\n                        }\n\n                        b = *bHitbox;\n                        b.x += bPos-&gt;x;\n                        b.y += bPos-&gt;y;\n\n                        if (checkCollision(a, b)) {\n                            std::cout &lt;&lt; \"Collision between \" &lt;&lt; entity &lt;&lt; \" and \" &lt;&lt; otherEntity &lt;&lt; std::endl;\n                        }\n                    }\n                }\n            }\n        };\n\n        // struct LuaScript {\n\n        //     void operator()(ECS::Registry &amp;R) {\n        //         std::vector&lt;ECS::entity_id&gt; allEntities = R.getEntitiesWithComponent&lt;ECS::Component::L&gt;();\n\n        //         for (auto &amp;entity : allEntities) {\n        //             auto pos = R.getComponent&lt;ECS::Component::Position&gt;(entity);\n        //             auto vel = R.getComponent&lt;ECS::Component::Velocity&gt;(entity);\n\n        //             if (vel != nullptr &amp;&amp; pos != nullptr) {\n        //                 // Call the Lua function for movement\n        //                 sol::function moveFunc = lua[\"Update\"];\n        //                 moveFunc(entity, *pos, *vel);  // Passing the entity, position, and velocity to Lua\n        //             }\n        //         }\n        //     }\n        // };\n\n        struct Draw {\n\n            std::shared_ptr&lt;sf::RenderWindow&gt; _win;\n\n            Draw( std::shared_ptr&lt;sf::RenderWindow&gt;&amp; winPtr) : _win(winPtr) {}\n\n            void operator()(ECS::Registry &amp;R, float dt)\n            {\n                std::vector&lt;ECS::entity_id&gt; allEntities = R.getEntitiesWithComponent&lt;ECS::Component::Drawable&gt;();\n                for (auto &amp;entity : allEntities) {\n                    auto pos = R.getComponent&lt;ECS::Component::Position&gt;(entity);\n                    auto drawable = R.getComponent&lt;ECS::Component::Drawable&gt;(entity);\n                    if (pos != nullptr) {\n                        drawable-&gt;sprite.setPosition(pos-&gt;x, pos-&gt;y);\n                        _win-&gt;draw(drawable-&gt;sprite);\n                    }\n                }\n            }\n        };\n\n        struct Animate {\n\n            void operator()(ECS::Registry &amp;R, float dt)\n            {\n                std::vector&lt;ECS::entity_id&gt; allEntities = R.getEntitiesWithComponent&lt;ECS::Component::Animation&gt;();\n                sf::Vector2u size;\n                for (auto &amp;entity : allEntities) {\n                    auto anim = R.getComponent&lt;ECS::Component::Animation&gt;(entity);\n                    auto drawable = R.getComponent&lt;ECS::Component::Drawable&gt;(entity);\n                    if (drawable != nullptr) {\n                        anim-&gt;currentFps++;\n                        if (!anim-&gt;animating) {\n                            anim-&gt;animating = true;\n                            drawable-&gt;sprite.setTextureRect(anim-&gt;rect);\n                            continue;\n                        }\n                        if (anim-&gt;currentFps &lt; anim-&gt;fps) {\n                            continue;\n                        }\n                        anim-&gt;currentFps = 0;\n                        size = drawable-&gt;sprite.getTexture()-&gt;getSize();\n                        anim-&gt;rect.left += anim-&gt;rect.width;\n                        if (anim-&gt;rect.left &gt;= size.x) {\n                            anim-&gt;rect.left = 0;\n                        }\n                        drawable-&gt;sprite.setTextureRect(anim-&gt;rect);\n                    }\n                }\n            }\n        };\n\n\n\n        struct ParallaxSystem {\n\n            void operator()(ECS::Registry &amp;R, float dt)\n            {\n                // Get all entities with a Parallax component\n                std::vector&lt;ECS::entity_id&gt; allEntities = R.getEntitiesWithComponent&lt;ECS::Component::Parallax&gt;();\n                sf::IntRect newRect;\n\n                // Iterate over all entities with a Parallax component\n                for (auto &amp;entity : allEntities) {\n                    auto parallax = R.getComponent&lt;ECS::Component::Parallax&gt;(entity);\n                    auto drawable = R.getComponent&lt;ECS::Component::Drawable&gt;(entity);\n\n                    if (drawable != nullptr &amp;&amp; parallax != nullptr) {\n                        newRect = drawable-&gt;sprite.getTextureRect();\n                        newRect.left += parallax-&gt;speed;\n                        if (newRect.left &gt; newRect.width) {\n                            newRect.left = 0;\n                        }\n                        drawable-&gt;sprite.setTextureRect(newRect);\n                    }\n                }\n            }\n        };\n\n\n        struct PlayerControl {\n\n            std::shared_ptr&lt;sf::RenderWindow&gt; _win;\n            sf::Event event;\n\n            PlayerControl( std::shared_ptr&lt;sf::RenderWindow&gt;&amp; winPtr) : _win(winPtr) {}\n\n            void operator()(ECS::Registry &amp;R, float dt)\n            {\n                std::vector&lt;ECS::entity_id&gt; allEntities = R.getEntitiesWithComponent&lt;ECS::Component::PlayerInput&gt;();\n                for (auto &amp;entity : allEntities) {\n                    auto inputs = R.getComponent&lt;ECS::Component::PlayerInput&gt;(entity);\n                    inputs-&gt;action = sf::Keyboard::isKeyPressed(sf::Keyboard::Space);\n                    inputs-&gt;left = sf::Keyboard::isKeyPressed(sf::Keyboard::Left);\n                    inputs-&gt;up = sf::Keyboard::isKeyPressed(sf::Keyboard::Up);\n                    inputs-&gt;down = sf::Keyboard::isKeyPressed(sf::Keyboard::Down);\n                    inputs-&gt;right = sf::Keyboard::isKeyPressed(sf::Keyboard::Right);\n                }\n            }\n        };\n\n        struct PlayerMovement {\n\n            void operator()(ECS::Registry &amp;R, float dt)\n            {\n                std::vector&lt;ECS::entity_id&gt; allEntities = R.getEntitiesWithComponent&lt;ECS::Component::PlayerInput&gt;();\n                for (auto &amp;entity : allEntities) {\n                    auto inputs = R.getComponent&lt;ECS::Component::PlayerInput&gt;(entity);\n                    auto vel = R.getComponent&lt;ECS::Component::Velocity&gt;(entity);\n                    if (vel) {\n                        vel-&gt;x = (inputs-&gt;left * -100) + (inputs-&gt;right * 100);\n                        vel-&gt;y = (inputs-&gt;up * -100) + (inputs-&gt;down * 100);\n                    }\n                }\n            }\n        };\n\n    }\n\n#endif\n</code></pre>"},{"location":"coverage/ecs/src/Component/","title":"Component","text":"Name Lines Covered Uncovered Coverage ComponentStorage.hpp 9 0 9 0.0% Components.hpp 30 0 30 0.0% Summary 39 0 39 0.0%"},{"location":"coverage/ecs/src/Component/ComponentStorage.hpp/","title":"ComponentStorage.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** RType\n** File description:\n** EntityManager Class\n*/\n\n#ifndef COMPONENTSTORAGE_HPP_\n    #define COMPONENTSTORAGE_HPP_\n\n    #include \"../Entity.hpp\"\n\n    class ComponentStorageBase {\n        public:\n            virtual ~ComponentStorageBase() = default;\n            virtual void remove(ECS::entity_id id) = 0;\n        };\n\n    template &lt;typename Component&gt;\n    class ComponentStorage : public ComponentStorageBase {\n    public:\n        std::vector&lt;std::shared_ptr&lt;Component&gt;&gt; storage;\n\n        void resize(size_t entity_count) {\n            if (entity_count &gt;= storage.size()) {\n                storage.resize(entity_count + 1);\n            }\n        }\n\n        std::optional&lt;std::shared_ptr&lt;Component&gt;&gt; get(ECS::entity_id id) {\n            if (id &gt;= storage.size()) {\n                return std::nullopt;\n            }\n            return storage[id];\n        }\n\n        void add(ECS::entity_id id, std::shared_ptr&lt;Component&gt; component) {\n            resize(id);\n            storage[id] = std::move(component);\n        }\n\n        void remove(ECS::entity_id id) {\n            if (id &lt; storage.size()) {\n                storage[id] = nullptr;\n            }\n        }\n    };\n\n#endif\n</code></pre>"},{"location":"coverage/ecs/src/Component/Components.hpp/","title":"Components.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** RType\n** File description:\n** ECS Components\n*/\n\n#ifndef COMPONENTS_HPP_\n    #define COMPONENTS_HPP_\n\n    #include &lt;iostream&gt;\n\n    #include \"../GUI_SFML_Graphics.hpp\"\n\n    namespace ECS::Component\n    {\n        /**\n        * Defines if the component is active or not (skips all systems for Entity)\n        *\n        * @param active is the component Active.\n        */\n        struct Active {\n            bool active = true;\n\n            bool operator==(const Active &amp;other) const\n            {\n                return active == other.active;\n            }\n\n            friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Active&amp; p) {\n                std::string info;\n                if (p.active) {\n                    info = \"true\";\n                } else {\n                    info = \"false\";\n                }\n                os &lt;&lt; \"Active(\" &lt;&lt; info &lt;&lt; \")\";\n                return os;\n            }\n        };\n\n        /**\n        * Position inside world space\n        *\n        * @param x X position.\n        * @param y Y position.\n        */\n        struct Position {\n            float x, y = 0;\n\n            bool operator==(const Position &amp;other) const\n            {\n                return x == other.x &amp;&amp; y == other.y;\n            }\n\n            friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Position&amp; p) {\n                os &lt;&lt; \"Position(x: \" &lt;&lt; p.x &lt;&lt; \", y: \" &lt;&lt; p.y &lt;&lt; \")\";\n                return os;\n            }\n        };\n\n        /**\n        * Velocity of entity\n        *\n        * @param x X speed.\n        * @param y Y speed.\n        */\n        struct Velocity {\n            float x, y = 0;\n\n            bool operator==(const Position &amp;other) const\n            {\n                return x == other.x &amp;&amp; y == other.y;\n            }\n\n            friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Velocity&amp; p) {\n                os &lt;&lt; \"Velocity(x: \" &lt;&lt; p.x &lt;&lt; \", y: \" &lt;&lt; p.y &lt;&lt; \")\";\n                return os;\n            }\n        };\n\n        /**\n        * Acceleration of entity\n        *\n        * @param x X acceleration.\n        * @param y Y acceleration.\n        */\n        struct Acceleration {\n            float x, y = 0;\n\n            bool operator==(const Acceleration &amp;other) const\n            {\n                return x == other.x &amp;&amp; y == other.y;\n            }\n\n            friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Acceleration&amp; p) {\n                os &lt;&lt; \"Acceleration(x: \" &lt;&lt; p.x &lt;&lt; \", y: \" &lt;&lt; p.y &lt;&lt; \")\";\n                return os;\n            }\n        };\n\n        /**\n        * Rectangle box for collisions/zone/etc...\n        *\n        * @param x X outset.\n        * @param y Y outset.\n        * @param w width.\n        * @param h height.\n        */\n        struct Hitbox {\n            float x, y, w, h = 0;\n\n            friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Hitbox&amp; p) {\n                os &lt;&lt; \"Hitbox(x: \" &lt;&lt; p.x &lt;&lt; \", y: \" &lt;&lt; p.y &lt;&lt; \", w: \" &lt;&lt; p.w &lt;&lt; \", h: \" &lt;&lt; p.h &lt;&lt; \")\";\n                return os;\n            }\n        };\n\n        /**\n        * State value usable for StateMachine\n        *\n        * @param name State name.\n        */\n        struct State {\n            std::string value = \"\";\n\n            friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const State&amp; p) {\n                os &lt;&lt; \"State(\" &lt;&lt; p.value &lt;&lt; \")\";\n                return os;\n            }\n        };\n\n        /**\n        * Lua Scripting on entity\n        *\n        * @param filepath State name.\n        */\n        struct LuaScript {\n            std::string file = \"\";\n\n            friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const LuaScript&amp; p) {\n                os &lt;&lt; \"Script(\" &lt;&lt; p.file &lt;&lt; \")\";\n                return os;\n            }\n        };\n\n        /**\n        * Visual for entity\n        *\n        * @param sprite Sprite.\n        */\n        struct Drawable {\n            sf::Sprite sprite;\n\n            friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Drawable&amp; p) {\n                os &lt;&lt; \"Sprite()\";\n                return os;\n            }\n        };\n\n\n        /**\n        * Animation rect of entity\n        *\n        * @param rect Frame for sprite.\n        * @param fps Frame per second.\n        */\n        struct Animation {\n            sf::IntRect rect;\n            int fps;\n            int currentFps = 0;\n            bool animating = false;\n\n            friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Animation&amp; p) {\n                os &lt;&lt; \"Animation()\";\n                return os;\n            }\n        };\n\n        /**\n        * Spritesheet info for selecting Sprite part on One line\n        *\n        * @param nbrOfState nbr of different states avaliable.\n        * @param state state selected.\n        */\n        struct SpriteSheet {\n            int nbrOfState;\n            int state;\n\n            friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const SpriteSheet&amp; p) {\n                os &lt;&lt; \"SpriteSheet()\";\n                return os;\n            }\n        };\n\n\n        struct Parallax {\n            float speed = 0.5f;\n\n            bool operator==(const Parallax&amp; other) const {\n                return speed == other.speed;\n            }\n\n            friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Parallax&amp; p) {\n                os &lt;&lt; \"Parallax(speed: \" &lt;&lt; p.speed &lt;&lt; \")\";\n                return os;\n            }\n        };\n\n        struct PlayerInput {\n            bool up, down, left, right, action = false;\n        };\n\n        struct Health {\n            int health = 1;\n        };\n\n        struct Ennemy {\n\n        };\n\n    }\n\n#endif\n</code></pre>"},{"location":"coverage/ecs/src/SparceArray/","title":"SparceArray","text":"Name Lines Covered Uncovered Coverage SparceArray.hpp 16 0 16 0.0% Summary 16 0 16 0.0%"},{"location":"coverage/ecs/src/SparceArray/SparceArray.hpp/","title":"SparceArray.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** RType\n** File description:\n** EntityManager Class\n*/\n\n#ifndef SPARCE_ARRAY_HPP_\n    #define SPARCE_ARRAY_HPP_\n\n    #include &lt;memory&gt;\n    #include &lt;queue&gt;\n    #include &lt;map&gt;\n    #include &lt;unordered_map&gt;\n\n    template &lt;typename Index, typename Content&gt;\n    class SparceArray {\n\n        public:\n            SparceArray() = default;\n            // SparceArray(SparceArray const &amp;); // copy constructor\n            // SparceArray(SparceArray &amp;&amp;) noexcept; // move constructor\n            ~SparceArray() = default;\n\n            void insert(const Index &amp;index, const Content &amp;value)\n            {\n                if (this-&gt;contains(index)) {\n                    return;\n                }\n                this-&gt;_data[index] = value;\n            }\n\n            void erase(Index index)\n            {\n                this-&gt;_data.erase(index);\n            }\n\n            void update(Index index, Content value)\n            {\n                if (this-&gt;contains(index)) {\n                    return;\n                }\n                this-&gt;_data[index] = value;\n            }\n\n            std::optional&lt;Content&gt; get(Index index)\n            {\n                if (this-&gt;contains(index)) {\n                    return this-&gt;_data[index];\n                }\n                return std::nullopt;\n            }\n\n            std::size_t size()\n            {\n                return this-&gt;_data.size();\n            }\n\n            bool contains(Index index) const\n            {\n                return this-&gt;_data.find(index) != this-&gt;_data.end();\n            }\n\n            // Begin iterator (non-const)\n            typename std::unordered_map&lt;Index, Content&gt;::iterator begin()\n            {\n                return _data.begin();\n            }\n\n            // End iterator (non-const)\n            typename std::unordered_map&lt;Index, Content&gt;::iterator end()\n            {\n                return _data.end();\n            }\n\n            // Begin iterator (const)\n            typename std::unordered_map&lt;Index, Content&gt;::const_iterator begin() const\n            {\n                return _data.begin();\n            }\n\n            // End iterator (const)\n            typename std::unordered_map&lt;Index, Content&gt;::const_iterator end() const\n            {\n                return _data.end();\n            }\n\n\n        private:\n            std::unordered_map&lt;Index, Content&gt; _data;\n\n\n    };\n#endif\n</code></pre>"},{"location":"coverage/flint/","title":"flint","text":"Name Lines Covered Uncovered Coverage src 93 44 49 47.3% Colors 0 0 0 100.0% Colors.cpp 0 0 0 100.0% Colors.hpp 0 0 0 100.0% CxxABI 34 26 8 76.5% CxxABI.cpp 34 26 8 76.5% CxxABI.hpp 0 0 0 100.0% Exceptions 44 17 27 38.6% Exceptions.cpp 43 17 26 39.5% Exceptions.hpp 1 0 1 0.0% Init 6 1 5 16.7% Init.cpp 6 1 5 16.7% Init.hpp 0 0 0 100.0% hpp 8 0 8 0.0% Debug.hpp 0 0 0 100.0% Inspection.hpp 8 0 8 0.0% Preprocessor.hpp 0 0 0 100.0% Flint.hpp 0 0 0 100.0% Headers.hpp 1 0 1 0.0% Summary 0 0 0 100.0% Summary 34 26 8 76.5% Summary 44 17 27 38.6% Summary 6 1 5 16.7% Summary 8 0 8 0.0% Summary 93 44 49 47.3% Summary 93 44 49 47.3%"},{"location":"coverage/flint/src/","title":"src","text":"Name Lines Covered Uncovered Coverage Colors 0 0 0 100.0% Colors.cpp 0 0 0 100.0% Colors.hpp 0 0 0 100.0% CxxABI 34 26 8 76.5% CxxABI.cpp 34 26 8 76.5% CxxABI.hpp 0 0 0 100.0% Exceptions 44 17 27 38.6% Exceptions.cpp 43 17 26 39.5% Exceptions.hpp 1 0 1 0.0% Init 6 1 5 16.7% Init.cpp 6 1 5 16.7% Init.hpp 0 0 0 100.0% hpp 8 0 8 0.0% Debug.hpp 0 0 0 100.0% Inspection.hpp 8 0 8 0.0% Preprocessor.hpp 0 0 0 100.0% Flint.hpp 0 0 0 100.0% Headers.hpp 1 0 1 0.0% Summary 0 0 0 100.0% Summary 34 26 8 76.5% Summary 44 17 27 38.6% Summary 6 1 5 16.7% Summary 8 0 8 0.0% Summary 93 44 49 47.3%"},{"location":"coverage/flint/src/Flint.hpp/","title":"Flint.hpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Sun, Apr, 2024                                                     *\n * Title           - CppLib                                                             *\n * Description     -                                                                    *\n *     Flint                                                                            *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *       _|_|_|_|  _|_|_|    _|_|_|  _|_|_|_|_|  _|_|_|_|    _|_|_|  _|    _|           *\n *       _|        _|    _|    _|        _|      _|        _|        _|    _|           *\n *       _|_|_|    _|_|_|      _|        _|      _|_|_|    _|        _|_|_|_|           *\n *       _|        _|          _|        _|      _|        _|        _|    _|           *\n *       _|_|_|_|  _|        _|_|_|      _|      _|_|_|_|    _|_|_|  _|    _|           *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#ifndef INCLUDED_FLINT_HPP\n    #define INCLUDED_FLINT_HPP\n\n    #include \"Headers.hpp\"\n    #include \"CxxABI/CxxABI.hpp\"\n    #include \"Colors/Colors.hpp\"\n    #include \"hpp/Debug.hpp\"\n    #include \"Exceptions/Exceptions.hpp\"\n    #include \"hpp/Inspection.hpp\"\n    #include \"Init/Init.hpp\"\n\n#endif\n</code></pre>"},{"location":"coverage/flint/src/Headers.hpp/","title":"Headers.hpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Sun, Apr, 2024                                                     *\n * Title           - CppLib                                                             *\n * Description     -                                                                    *\n *     headers                                                                          *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *       _|_|_|_|  _|_|_|    _|_|_|  _|_|_|_|_|  _|_|_|_|    _|_|_|  _|    _|           *\n *       _|        _|    _|    _|        _|      _|        _|        _|    _|           *\n *       _|_|_|    _|_|_|      _|        _|      _|_|_|    _|        _|_|_|_|           *\n *       _|        _|          _|        _|      _|        _|        _|    _|           *\n *       _|_|_|_|  _|        _|_|_|      _|      _|_|_|_|    _|_|_|  _|    _|           *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#ifndef INCLUDED_HEADERS_HPP\n    #define INCLUDED_HEADERS_HPP\n\n    #include &lt;algorithm&gt;\n    #include &lt;cmath&gt;\n    #include &lt;cxxabi.h&gt;\n    #include &lt;exception&gt;\n    #include &lt;filesystem&gt;\n    #include &lt;initializer_list&gt;\n    #include &lt;iostream&gt;\n    #include &lt;map&gt;\n    #include &lt;memory&gt;\n    #include &lt;ostream&gt;\n    #include &lt;sstream&gt;\n    #include &lt;string&gt;\n    #include &lt;unordered_map&gt;\n    #include &lt;unordered_set&gt;\n    #include &lt;utility&gt;\n    #include &lt;vector&gt;\n\nnamespace fs = std::filesystem;\n\n// get break trace\n#ifdef _WIN32\n    #include &lt;windows.h&gt;\n#elif defined(__linux__) || defined(__APPLE__)\n    #include &lt;execinfo.h&gt;\n#endif\n\n#endif\n</code></pre>"},{"location":"coverage/flint/src/Colors/","title":"Colors","text":"Name Lines Covered Uncovered Coverage Colors.cpp 0 0 0 100.0% Colors.hpp 0 0 0 100.0% Summary 0 0 0 100.0%"},{"location":"coverage/flint/src/Colors/Colors.cpp/","title":"Colors.cpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Thu, May, 2024                                                     *\n * Title           - CppLib                                                             *\n * Description     -                                                                    *\n *     Colors                                                                           *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *         \u2591        \u2591       \u2591\u2591        \u2591        \u2591        \u2591\u2591      \u2591\u2591  \u2591\u2591\u2591\u2591  \u2591             *\n *         \u2592  \u2592\u2592\u2592\u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592  \u2592  \u2592\u2592\u2592\u2592  \u2592             *\n *         \u2593      \u2593\u2593\u2593       \u2593\u2593\u2593\u2593\u2593  \u2593\u2593\u2593\u2593\u2593\u2593\u2593  \u2593\u2593\u2593\u2593      \u2593\u2593\u2593  \u2593\u2593\u2593\u2593\u2593\u2593\u2593        \u2593             *\n *         \u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588  \u2588  \u2588\u2588\u2588\u2588  \u2588             *\n *         \u2588        \u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588        \u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588        \u2588\u2588      \u2588\u2588  \u2588\u2588\u2588\u2588  \u2588             *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#include \"Colors.hpp\"\n\nnamespace Flint\n{\n    const std::string Colors::RESET          = \"\\033[0m\";\n    const std::string Colors::BOLD           = \"\\033[1m\";\n    const std::string Colors::DISABLED       = \"\\033[2m\";\n    const std::string Colors::ITALIC         = \"\\033[3m\";\n    const std::string Colors::UNDERLINE      = \"\\033[4m\";\n    const std::string Colors::BLINK          = \"\\033[5m\";\n    const std::string Colors::HIGHLIGHTED    = \"\\033[7m\";\n    const std::string Colors::STRIPED        = \"\\033[9m\";\n    const std::string Colors::BLACK          = \"\\033[30m\";\n    const std::string Colors::RED            = \"\\033[31m\";\n    const std::string Colors::GREEN          = \"\\033[32m\";\n    const std::string Colors::YELLOW         = \"\\033[33m\";\n    const std::string Colors::BLUE           = \"\\033[34m\";\n    const std::string Colors::PURPLE         = \"\\033[35m\";\n    const std::string Colors::CYAN           = \"\\033[36m\";\n    const std::string Colors::GREY           = \"\\033[37m\";\n    const std::string Colors::F_BLACK        = \"\\033[90m\";\n    const std::string Colors::F_RED          = \"\\033[91m\";\n    const std::string Colors::F_GREEN        = \"\\033[92m\";\n    const std::string Colors::F_YELLOW       = \"\\033[93m\";\n    const std::string Colors::F_BLUE         = \"\\033[94m\";\n    const std::string Colors::F_PURPLE       = \"\\033[95m\";\n    const std::string Colors::F_CYAN         = \"\\033[96m\";\n    const std::string Colors::F_GREY         = \"\\033[97m\";\n}\n</code></pre>"},{"location":"coverage/flint/src/Colors/Colors.hpp/","title":"Colors.hpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Thu, May, 2024                                                     *\n * Title           - CppLib                                                             *\n * Description     -                                                                    *\n *     Colors                                                                           *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *       \u2584\u2580\u2580\u2588\u2584\u2584\u2584\u2584  \u2584\u2580\u2580\u2584\u2580\u2580\u2580\u2584  \u2584\u2580\u2580\u2588\u2580\u2584    \u2584\u2580\u2580\u2580\u2588\u2580\u2580\u2584  \u2584\u2580\u2580\u2588\u2584\u2584\u2584\u2584  \u2584\u2580\u2584\u2584\u2584\u2584   \u2584\u2580\u2580\u2584 \u2584\u2584             *\n *      \u2590  \u2584\u2580   \u2590 \u2588   \u2588   \u2588 \u2588   \u2588  \u2588  \u2588    \u2588  \u2590 \u2590  \u2584\u2580   \u2590 \u2588 \u2588    \u258c \u2588  \u2588   \u2584\u2580            *\n *        \u2588\u2584\u2584\u2584\u2584\u2584  \u2590  \u2588\u2580\u2580\u2580\u2580  \u2590   \u2588  \u2590  \u2590   \u2588       \u2588\u2584\u2584\u2584\u2584\u2584  \u2590 \u2588      \u2590  \u2588\u2584\u2584\u2584\u2588             *\n *        \u2588    \u258c     \u2588          \u2588        \u2588        \u2588    \u258c    \u2588         \u2588   \u2588             *\n *       \u2584\u2580\u2584\u2584\u2584\u2584    \u2584\u2580        \u2584\u2580\u2580\u2580\u2580\u2580\u2584   \u2584\u2580        \u2584\u2580\u2584\u2584\u2584\u2584    \u2584\u2580\u2584\u2584\u2584\u2584\u2580   \u2584\u2580  \u2584\u2580             *\n *       \u2588    \u2590   \u2588         \u2588       \u2588 \u2588          \u2588    \u2590   \u2588     \u2590   \u2588   \u2588               *\n *       \u2590        \u2590         \u2590       \u2590 \u2590          \u2590        \u2590         \u2590   \u2590               *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#ifndef INCLUDED_COLORS_HPP\n    #define INCLUDED_COLORS_HPP\n\n    #include \"../Headers.hpp\"\n\nnamespace Flint\n{\n    /**\n      * This class defined a good set of ANSI colors.\n      *\n      * @tip\n      * It is recomended to use those through streams :\n      * std::cout &lt;&lt; Flint::Colors::GREEN &lt;&lt; \"Hacker time\" &lt;&lt; Flint::Colors::RESET &lt;&lt; std::endl;\n      *\n      * @info\n      * Please ALWAYS remember to close your colors with Flint::Colors::RESET.\n      * Failure to do si might result in broken displays, with weird colors everywhere\n    */\n    class Colors\n    {\n        public:\n            static const std::string RESET;\n            static const std::string BOLD;\n            static const std::string DISABLED;\n            static const std::string ITALIC;\n            static const std::string UNDERLINE;\n            static const std::string BLINK;\n            static const std::string HIGHLIGHTED;\n            static const std::string STRIPED;\n            static const std::string BLACK;\n            static const std::string RED;\n            static const std::string GREEN;\n            static const std::string YELLOW;\n            static const std::string BLUE;\n            static const std::string PURPLE;\n            static const std::string CYAN;\n            static const std::string GREY;\n            static const std::string F_BLACK;\n            static const std::string F_RED;\n            static const std::string F_GREEN;\n            static const std::string F_YELLOW;\n            static const std::string F_BLUE;\n            static const std::string F_PURPLE;\n            static const std::string F_CYAN;\n            static const std::string F_GREY;\n    };\n}\n\n#endif\n</code></pre>"},{"location":"coverage/flint/src/CxxABI/","title":"CxxABI","text":"Name Lines Covered Uncovered Coverage CxxABI.cpp 34 26 8 76.5% CxxABI.hpp 0 0 0 100.0% Summary 34 26 8 76.5%"},{"location":"coverage/flint/src/CxxABI/CxxABI.cpp/","title":"CxxABI.cpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Thu, May, 2024                                                     *\n * Title           - CppLib                                                             *\n * Description     -                                                                    *\n *     CxxABI                                                                           *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *       _|_|_|_|  _|_|_|    _|_|_|  _|_|_|_|_|  _|_|_|_|    _|_|_|  _|    _|           *\n *       _|        _|    _|    _|        _|      _|        _|        _|    _|           *\n *       _|_|_|    _|_|_|      _|        _|      _|_|_|    _|        _|_|_|_|           *\n *       _|        _|          _|        _|      _|        _|        _|    _|           *\n *       _|_|_|_|  _|        _|_|_|      _|      _|_|_|_|    _|_|_|  _|    _|           *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#include \"CxxABI.hpp\"\n\nnamespace Flint\n{\n    std::string CxxABI::demangle(const char* name)\n    {\n        int status = -4;\n        char* _out = abi::__cxa_demangle(name, nullptr, nullptr, &amp;status);\n        if (status != 0 &amp;&amp; _out)\n            free(_out);\n        if (status != 0)\n            return std::string(name);\n        std::string result(_out);\n        free(_out);\n        return result;\n    }\n\n    std::pair&lt;std::string, std::size_t&gt; CxxABI::getFuncInfos(const char* symbolInfos)\n    {\n        std::pair&lt;std::string, std::size_t&gt; output;\n        std::string entry(symbolInfos);\n\n        std::size_t openP  = entry.find('(');\n        std::size_t closeP = entry.find(')');\n\n        if (openP == std::string::npos ||\n            closeP == std::string::npos)\n            return output;\n\n        std::string functionAndOffset = entry.substr(openP + 1, closeP);\n        std::size_t plusP  = functionAndOffset.find('+');\n\n        if (functionAndOffset.empty() ||\n            plusP == std::string::npos)\n            return output;\n\n        output.first  = CxxABI::demangle(functionAndOffset.substr(0, plusP).c_str());\n        std::stringstream ss;\n        ss &lt;&lt; std::hex &lt;&lt; functionAndOffset.substr(plusP + 1);\n        ss &gt;&gt; output.second;\n\n        return output;\n    }\n\n    // std::vector&lt;std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt;&gt; CxxABI::getBacktrace()\n    std::vector&lt;std::pair&lt;std::string, std::size_t&gt;&gt; CxxABI::getBacktrace()\n    {\n        std::vector&lt;std::pair&lt;std::string, std::size_t&gt;&gt; out;\n        int TRACE_CHUNCK = 128;\n\n        int size = 0, out_size = 0;\n        do {\n            size += TRACE_CHUNCK;\n            void* trace[size + 1];\n            out_size = (int)backtrace(trace, size);\n        } while (out_size == size);\n        void* trace[out_size + 1];\n\n        backtrace(trace, out_size);\n        char** symbols = backtrace_symbols(trace, out_size);\n        if (symbols) {\n            for (int i = 0; i &lt; out_size; ++i) {\n                std::pair&lt;std::string, std::size_t&gt; symbol = CxxABI::getFuncInfos(symbols[i]);\n                if (symbol.first.empty())\n                    break;\n                out.push_back(symbol);\n            }\n            free(symbols);\n        }\n\n        return out;\n    }\n}\n</code></pre>"},{"location":"coverage/flint/src/CxxABI/CxxABI.hpp/","title":"CxxABI.hpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Thu, May, 2024                                                     *\n * Title           - CppLib                                                             *\n * Description     -                                                                    *\n *     CxxABI                                                                           *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *       \u2584\u2580\u2580\u2588\u2584\u2584\u2584\u2584  \u2584\u2580\u2580\u2584\u2580\u2580\u2580\u2584  \u2584\u2580\u2580\u2588\u2580\u2584    \u2584\u2580\u2580\u2580\u2588\u2580\u2580\u2584  \u2584\u2580\u2580\u2588\u2584\u2584\u2584\u2584  \u2584\u2580\u2584\u2584\u2584\u2584   \u2584\u2580\u2580\u2584 \u2584\u2584             *\n *      \u2590  \u2584\u2580   \u2590 \u2588   \u2588   \u2588 \u2588   \u2588  \u2588  \u2588    \u2588  \u2590 \u2590  \u2584\u2580   \u2590 \u2588 \u2588    \u258c \u2588  \u2588   \u2584\u2580            *\n *        \u2588\u2584\u2584\u2584\u2584\u2584  \u2590  \u2588\u2580\u2580\u2580\u2580  \u2590   \u2588  \u2590  \u2590   \u2588       \u2588\u2584\u2584\u2584\u2584\u2584  \u2590 \u2588      \u2590  \u2588\u2584\u2584\u2584\u2588             *\n *        \u2588    \u258c     \u2588          \u2588        \u2588        \u2588    \u258c    \u2588         \u2588   \u2588             *\n *       \u2584\u2580\u2584\u2584\u2584\u2584    \u2584\u2580        \u2584\u2580\u2580\u2580\u2580\u2580\u2584   \u2584\u2580        \u2584\u2580\u2584\u2584\u2584\u2584    \u2584\u2580\u2584\u2584\u2584\u2584\u2580   \u2584\u2580  \u2584\u2580             *\n *       \u2588    \u2590   \u2588         \u2588       \u2588 \u2588          \u2588    \u2590   \u2588     \u2590   \u2588   \u2588               *\n *       \u2590        \u2590         \u2590       \u2590 \u2590          \u2590        \u2590         \u2590   \u2590               *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#ifndef INCLUDED_CXXABI_HPP\n    #define INCLUDED_CXXABI_HPP\n\n    #include \"../Headers.hpp\"\n\nnamespace Flint\n{\n    /**\n      * Wrapper around usefull C++/C low level functions\n      *\n      * Got demangle, backtrace...\n      *\n      * @tip\n      * This class is only made of static functions. It does not contain constructor, nor destructor\n      * This means that you don't need to instanciate it, and only use it as if it was a namespace.\n    */\n    class CxxABI\n    {\n        public:\n            CxxABI() = delete;\n\n            /**\n              * Demangle a C++ name.\n              *\n              * This is usefull for : Class names, backtrace...\n              *\n              * @return string containing : demangled name, or original name, if demangle did not work\n            */\n            static std::string demangle(const char* name);\n\n            /**\n              * Get functions infos from symbol extraction\n              *\n              * @return A pair with the function names demangled, and the offset from the function\n              *\n              * @warning\n              * The function name is not EXACTLY the real name of the function.\n              * Also, the offset DOES NOT correspond to the line number, but the offset of asm instructions\n            */\n            static std::pair&lt;std::string, std::size_t&gt; getFuncInfos(const char* symbolInfos);\n\n            /**\n              * Retreive the execution trace\n              *\n              * @return Vector of pair&lt;pair&lt;string, size_t&gt;, string&gt;. I'll explain\n              *\n              * The idea is to retrieive the file, line, and function. So that's what we do :\n              * pair or : (file, line), function\n              *\n              * @warning\n              * To correctly grab function names, you will need to add compilation flag \"-rdynamic\"\n              * See this lib's CMakeLists.txt for implementation.\n              * This will export ALL symbols.\n              * If NOT done, you will get offsets from binary. It's ok, but quite disgusting on output.\n            */\n            static std::vector&lt;std::pair&lt;std::string, std::size_t&gt;&gt; getBacktrace();\n    };\n}\n\n#endif\n</code></pre>"},{"location":"coverage/flint/src/Exceptions/","title":"Exceptions","text":"Name Lines Covered Uncovered Coverage Exceptions.cpp 43 17 26 39.5% Exceptions.hpp 1 0 1 0.0% Summary 44 17 27 38.6%"},{"location":"coverage/flint/src/Exceptions/Exceptions.cpp/","title":"Exceptions.cpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Sun, Apr, 2024                                                     *\n * Title           - CppLib                                                             *\n * Description     -                                                                    *\n *     Exceptions                                                                       *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *       _|_|_|_|  _|_|_|    _|_|_|  _|_|_|_|_|  _|_|_|_|    _|_|_|  _|    _|           *\n *       _|        _|    _|    _|        _|      _|        _|        _|    _|           *\n *       _|_|_|    _|_|_|      _|        _|      _|_|_|    _|        _|_|_|_|           *\n *       _|        _|          _|        _|      _|        _|        _|    _|           *\n *       _|_|_|_|  _|        _|_|_|      _|      _|_|_|_|    _|_|_|  _|    _|           *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#include \"Exceptions.hpp\"\n\nnamespace Flint::Exceptions\n{\n    Exception::Exception(const std::string&amp; what, std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; infos):\n        _infos(infos)\n    {\n        std::vector&lt;std::pair&lt;std::string, std::size_t&gt;&gt; stackTrace = CxxABI::getBacktrace();\n        std::stringstream ss;\n\n        ss &lt;&lt; \"[\" &lt;&lt; Flint::Colors::F_PURPLE &lt;&lt; this-&gt;getClassNameFromStackTrace(stackTrace) &lt;&lt; Flint::Colors::RESET;\n\n        if (!infos.first.first.empty() &amp;&amp; !infos.second.empty()) {\n            ss &lt;&lt; \" in \" &lt;&lt;\n                Flint::Colors::F_YELLOW &lt;&lt; infos.second &lt;&lt; Flint::Colors::RESET &lt;&lt;\n                \" at \" &lt;&lt;\n                Flint::Colors::F_BLUE &lt;&lt; infos.first.first.substr(infos.first.first.find_last_of(\"/\\\\\") + 1) &lt;&lt; Flint::Colors::RESET &lt;&lt;\n                \":\" &lt;&lt;\n                Flint::Colors::F_RED &lt;&lt; infos.first.second &lt;&lt; Flint::Colors::RESET;\n        }\n        ss &lt;&lt; \"] \" &lt;&lt; what;\n\n        for (std::size_t i = 2; i &lt; stackTrace.size(); i++) {\n            std::string funcName = stackTrace[i].first;\n            std::size_t openP    = funcName.find('(');\n            if (openP == std::string::npos)\n                funcName += \"()\";\n            funcName = funcName.substr(0, funcName.find(\"(\") + 1) + \"[...])\";\n            ss &lt;&lt; std::endl &lt;&lt; \" -&gt; \" &lt;&lt;\n            Flint::Colors::CYAN &lt;&lt; funcName &lt;&lt; Flint::Colors::RESET &lt;&lt;\n            \":\" &lt;&lt;\n            Flint::Colors::YELLOW &lt;&lt; \"0x\" &lt;&lt; std::hex &lt;&lt; stackTrace[i].second &lt;&lt; Flint::Colors::RESET;\n        }\n\n        this-&gt;_what = ss.str();\n    }\n\n    std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; Exception::getInfos() const\n    {\n        return this-&gt;_infos;\n    }\n\n    std::string Exception::getClassNameFromStackTrace(const std::vector&lt;std::pair&lt;std::string, std::size_t&gt;&gt;&amp; stackTrace) const\n    {\n        if (stackTrace.size() &lt;= 2)\n            return \"[Class name undefined]\";\n\n        std::string classNameSymbol = stackTrace[2].first.substr();\n        std::size_t openP           = classNameSymbol.find('(');\n        if (openP == std::string::npos)\n            return \"[Class name undefined]\";\n\n        std::string functionName = classNameSymbol.substr(0, openP);\n        std::size_t lastColon    = functionName.rfind(\"::\");\n        if (lastColon == std::string::npos)\n            return \"[Class name undefined]\";\n        // Remove duplicate\n        return functionName.substr(0, lastColon);\n    }\n\n    std::string Exception::show(std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; fileInfos) const\n    {\n        std::stringstream ss;\n        ss &lt;&lt; \"Exception caught on \" &lt;&lt;\n              Flint::Colors::F_GREEN &lt;&lt; fileInfos.second       &lt;&lt; Flint::Colors::RESET &lt;&lt; \" at \" &lt;&lt;\n              Flint::Colors::F_BLUE  &lt;&lt; fileInfos.first.first  &lt;&lt; Flint::Colors::RESET &lt;&lt; \":\" &lt;&lt;\n              Flint::Colors::F_RED   &lt;&lt; fileInfos.first.second &lt;&lt; Flint::Colors::RESET &lt;&lt; std::endl &lt;&lt; std::endl;\n\n        ss &lt;&lt; this-&gt;_what;\n        return ss.str();\n    }\n\n    const char* Exception::what() const noexcept\n    {\n        return this-&gt;_what.c_str();\n    }\n\n    std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Exceptions::Exception&amp; obj)\n    {\n        os &lt;&lt; obj.what();\n        return os;\n    }\n}\n</code></pre>"},{"location":"coverage/flint/src/Exceptions/Exceptions.hpp/","title":"Exceptions.hpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Sun, Apr, 2024                                                     *\n * Title           - CppLib                                                             *\n * Description     -                                                                    *\n *     Exceptions                                                                       *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557  \u2588\u2588\u2557                     *\n *             \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551  \u2588\u2588\u2551                     *\n *             \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551                     *\n *             \u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551                     *\n *             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551                     *\n *             \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d     \u255a\u2550\u255d   \u255a\u2550\u255d   \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d                     *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#ifndef INCLUDED_EXCEPTIONS_HPP\n    #define INCLUDED_EXCEPTIONS_HPP\n\n    #include \"../Headers.hpp\"\n    #include \"../CxxABI/CxxABI.hpp\"\n    #include \"../Colors/Colors.hpp\"\n    #include \"../hpp/Inspection.hpp\"\n    #include \"../hpp/Preprocessor.hpp\"\n\nnamespace Flint::Exceptions\n{\n    /**\n      * Wrapper arround default [std::exception](https://en.cppreference.com/w/cpp/error/exception)\n      *\n      * Store the the exception description as [std::string](https://en.cppreference.com/w/cpp/string/basic_string),\n      * and store some usefull localisation informations: Filename, Line, and Function Name.\n      * This is automated using the throw_exception preprocessor directive.\n      *\n      * @tip\n      * Take a look at the NotImplementedError to see how easy it is to implmeent your own Flint::Exception.\n    */\n    class Exception: public std::exception\n    {\n        protected:\n            std::string _what;\n            std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; _infos;\n        public:\n            /**\n              * Exception constructor. This need to be called, even on child classes.\n              *\n              * @param what Define the exception's description\n              * @param infos Might contain positional infos\n              *\n              * @warning\n              * You should **NOT** use any excpetion constructor manually.\n              * While they might work, the prefered way is to use the throw_exception preprocessor directive.\n              * Using it will only require you to register what type of excpetion you want to throw, and what message you want to add, and will take care of putting file name, line, and function name\n            */\n            Exception(const std::string&amp; what = \"An exception occured !\",\n                      std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; infos = {{\"\", 0}, \"\"});\n\n            /**\n              * Retreive given infos (filename, line, and function name)\n              *\n              * @return The actual infos\n            */\n            std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; getInfos() const;\n\n            /**\n              * Try to retreive the Exception class name from the StackTrace.\n              *\n              * @param stackTrace A stack trace, formated like CxxABI::getBacktrace()\n              *\n              * @warning\n              * This function **DOES NOT WORK 100% OF THE TIME**.\n              * It is really dependant on the environement, and can return undefined without aparent reason.\n              * It should **NOT** be used for anything else than debug or display.\n              *\n              * @return The actual class name or \"[Class name undefined]\"\n            */\n            std::string getClassNameFromStackTrace(const std::vector&lt;std::pair&lt;std::string, std::size_t&gt;&gt;&amp; stackTrace) const;\n\n            /**\n              * Display the error, given specific positional infos (like the constructor).\n              *\n              * @param infos Positional informations, like the constructor, used to display the infos.\n              *\n              * @note\n              * This function, while being usable without, should be used through the catch_exception preprocessor directive.\n              * This preprocessor directive let you display Python like excpetion trace.\n              *\n              * @return The formated exception, ready to be displayed.\n            */\n            std::string show(std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; infos) const;\n\n            /**\n              * Required override, deprecated by show and catch_exception.\n              *\n              * @info\n              * This is the required std::exception override.\n              * It'll return the _what as a const char*.\n              * While this will work, prefer using the show function or the catch_excpetion preprocessor directive :\n              *\n              * @example\n              * ```cpp\n              * try {\n              *     throw_exception(Flint::Exceptions::Exception, \"Sample testing exception\");\n              * } catch (const Flint::Exceptions::Exception&amp; e) {\n              *     std::cerr &lt;&lt; catch_exception(e) &lt;&lt; std::endl;\n              * }\n              * ```\n              *\n              * @return The _what as a C string\n            */\n            const char* what() const noexcept override;\n\n            /**\n              * operator&lt;&lt; override\n              *\n              * @abstract\n              * This will simply append the _what to the ostream\n            */\n            friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Exceptions::Exception&amp; obj);\n    };\n\n    /**\n      * Sample Flint::Exceptions::Exception to register NotImplemented features\n      *\n      * @tip\n      * You should use that Exception as a C++ Implementation of the Rust todo!() macro.\n      *\n      * @example\n      * ```cpp\n      * throw_exception(Flint::Exceptions::NotImplementedError, \"This function haven't been implemented as of today !\");\n      * ```\n    */\n    class NotImplementedError: public Flint::Exceptions::Exception\n    {\n        public:\n            NotImplementedError(const std::string&amp; what = \"Asked action haven't been implemented yet.\",\n                                std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; infos = {{\"\", 0}, \"\"}):\n                Exception(what, infos)\n            {}\n    };\n}\n\n#endif\n</code></pre>"},{"location":"coverage/flint/src/Init/","title":"Init","text":"Name Lines Covered Uncovered Coverage Init.cpp 6 1 5 16.7% Init.hpp 0 0 0 100.0% Summary 6 1 5 16.7%"},{"location":"coverage/flint/src/Init/Init.cpp/","title":"Init.cpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Thu, May, 2024                                                     *\n * Title           - Flint                                                              *\n * Description     -                                                                    *\n *     Init                                                                             *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *       \u2584\u2580\u2580\u2588\u2584\u2584\u2584\u2584  \u2584\u2580\u2580\u2584\u2580\u2580\u2580\u2584  \u2584\u2580\u2580\u2588\u2580\u2584    \u2584\u2580\u2580\u2580\u2588\u2580\u2580\u2584  \u2584\u2580\u2580\u2588\u2584\u2584\u2584\u2584  \u2584\u2580\u2584\u2584\u2584\u2584   \u2584\u2580\u2580\u2584 \u2584\u2584             *\n *      \u2590  \u2584\u2580   \u2590 \u2588   \u2588   \u2588 \u2588   \u2588  \u2588  \u2588    \u2588  \u2590 \u2590  \u2584\u2580   \u2590 \u2588 \u2588    \u258c \u2588  \u2588   \u2584\u2580            *\n *        \u2588\u2584\u2584\u2584\u2584\u2584  \u2590  \u2588\u2580\u2580\u2580\u2580  \u2590   \u2588  \u2590  \u2590   \u2588       \u2588\u2584\u2584\u2584\u2584\u2584  \u2590 \u2588      \u2590  \u2588\u2584\u2584\u2584\u2588             *\n *        \u2588    \u258c     \u2588          \u2588        \u2588        \u2588    \u258c    \u2588         \u2588   \u2588             *\n *       \u2584\u2580\u2584\u2584\u2584\u2584    \u2584\u2580        \u2584\u2580\u2580\u2580\u2580\u2580\u2584   \u2584\u2580        \u2584\u2580\u2584\u2584\u2584\u2584    \u2584\u2580\u2584\u2584\u2584\u2584\u2580   \u2584\u2580  \u2584\u2580             *\n *       \u2588    \u2590   \u2588         \u2588       \u2588 \u2588          \u2588    \u2590   \u2588     \u2590   \u2588   \u2588               *\n *       \u2590        \u2590         \u2590       \u2590 \u2590          \u2590        \u2590         \u2590   \u2590               *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#include \"Init.hpp\"\n\nnamespace Flint\n{\n    static void unhandeled_exception()\n    {\n        try {\n            std::rethrow_exception(std::current_exception());\n        } catch (const std::exception&amp; e) {\n            const Flint::Exceptions::Exception* exception = dynamic_cast&lt;const Flint::Exceptions::Exception*&gt;(&amp;e);\n            if (exception != nullptr) {\n                std::cerr &lt;&lt; Flint::Colors::RED &lt;&lt; \"/!\\\\\" &lt;&lt; Flint::Colors::RESET &lt;&lt; \" Uncaught Flint exception \" &lt;&lt; Flint::Colors::RED &lt;&lt; \"/!\\\\\" &lt;&lt; Flint::Colors::RESET &lt;&lt; std::endl &lt;&lt; std::endl &lt;&lt; *exception &lt;&lt; std::endl;\n            } else {\n                std::cerr &lt;&lt; Flint::Colors::RED &lt;&lt; \"/!\\\\\" &lt;&lt; Flint::Colors::RESET &lt;&lt; \" Uncaught exception \" &lt;&lt; Flint::Colors::RED &lt;&lt; \"/!\\\\\" &lt;&lt; Flint::Colors::RESET &lt;&lt; std::endl &lt;&lt; std::endl &lt;&lt; e.what() &lt;&lt; std::endl;\n            }\n        }\n    }\n\n    void Init()\n    {\n        std::set_terminate(unhandeled_exception);\n    }\n}\n</code></pre>"},{"location":"coverage/flint/src/Init/Init.hpp/","title":"Init.hpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Thu, May, 2024                                                     *\n * Title           - Flint                                                              *\n * Description     -                                                                    *\n *     Init                                                                             *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557  \u2588\u2588\u2557                     *\n *             \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551  \u2588\u2588\u2551                     *\n *             \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551                     *\n *             \u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551                     *\n *             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551                     *\n *             \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d     \u255a\u2550\u255d   \u255a\u2550\u255d   \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d                     *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#ifndef INCLUDED_INIT_HPP\n    #define INCLUDED_INIT_HPP\n\n    #include \"../Exceptions/Exceptions.hpp\"\n\nnamespace Flint\n{\n    [[gnu::constructor]] void Init();\n}\n\n#endif\n</code></pre>"},{"location":"coverage/flint/src/hpp/","title":"hpp","text":"Name Lines Covered Uncovered Coverage Debug.hpp 0 0 0 100.0% Inspection.hpp 8 0 8 0.0% Preprocessor.hpp 0 0 0 100.0% Summary 8 0 8 0.0%"},{"location":"coverage/flint/src/hpp/Debug.hpp/","title":"Debug.hpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Thu, May, 2024                                                     *\n * Title           - CppLib                                                             *\n * Description     -                                                                    *\n *     Debug                                                                            *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557  \u2588\u2588\u2557                     *\n *             \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551  \u2588\u2588\u2551                     *\n *             \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551                     *\n *             \u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551                     *\n *             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551                     *\n *             \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d     \u255a\u2550\u255d   \u255a\u2550\u255d   \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d                     *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#ifndef INCLUDED_DEBUG_HPP\n    #define INCLUDED_DEBUG_HPP\n\n    #include \"Preprocessor.hpp\"\n    #include \"../Headers.hpp\"\n\nnamespace Flint\n{\n    class Debug\n    {\n        public:\n            Debug();\n            Debug(std::string data);\n\n            template &lt;typename T&gt;\n            Debug(std::string filename, std::size_t line, T functionName);\n\n            ~Debug() = default;\n    };\n}\n\n#define Debug(data) Flint::Debug(__POSITION_INFOS__, data)\n\n#endif\n</code></pre>"},{"location":"coverage/flint/src/hpp/Inspection.hpp/","title":"Inspection.hpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Thu, May, 2024                                                     *\n * Title           - CppLib                                                             *\n * Description     -                                                                    *\n *     Inspection                                                                       *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *         \u2591        \u2591       \u2591\u2591        \u2591        \u2591        \u2591\u2591      \u2591\u2591  \u2591\u2591\u2591\u2591  \u2591             *\n *         \u2592  \u2592\u2592\u2592\u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592  \u2592  \u2592\u2592\u2592\u2592  \u2592             *\n *         \u2593      \u2593\u2593\u2593       \u2593\u2593\u2593\u2593\u2593  \u2593\u2593\u2593\u2593\u2593\u2593\u2593  \u2593\u2593\u2593\u2593      \u2593\u2593\u2593  \u2593\u2593\u2593\u2593\u2593\u2593\u2593        \u2593             *\n *         \u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588  \u2588  \u2588\u2588\u2588\u2588  \u2588             *\n *         \u2588        \u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588        \u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588        \u2588\u2588      \u2588\u2588  \u2588\u2588\u2588\u2588  \u2588             *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#ifndef INCLUDED_INSPECTION_HPP\n    #define INCLUDED_INSPECTION_HPP\n\n    #include \"../Headers.hpp\"\n    #include \"../CxxABI/CxxABI.hpp\"\n\nnamespace Flint\n{\n    /**\n      * Base class to implement simplet self-reflexion in C++\n      *\n      * @tparam T Child class itself\n      *\n      * @tip\n      * When creating a child class, define as follow :\n      * ```cpp\n      * class ChildClass: public Inspection&lt;ChildClass&gt;\n      * ```\n      * This will extand the ChildClass with the self-reflexion class Inspection\n      *\n      * @warning\n      * If the class you want to extand as a reflected class will be a parent class\n      * (I.E. You will create childs of this \"target\" class), you might want to\n      * mark inheritence as **virtual**.\n      * This is needed if your child class _also_ need to be reflected.\n      * This way, there is no confilict between the parent reflexion, and the child reflexion.\n    */\n    template &lt;typename T&gt;\n    class Inspection\n    {\n        public:\n            /**\n              * Return the name of the reflected class\n              *\n              * @return The demangled name of the class, or just the name, if demangleing failed\n            */\n            virtual std::string getClassName() const final\n            {\n                return CxxABI::demangle(typeid(T).name());\n            }\n\n            // virtual std::unordered_set&lt;std::pair&lt;std::string, std::string&gt;&gt; getAttributes();\n\n            /**\n              * Return a string representation of the class\n              *\n              * @tip\n              * This function is not intended to be used.\n              * This is because this functions display the reflection.\n              * You might prefer to override this function in yout child\n              * class to display informations that are more relevant to\n              * your specific class.\n              *\n              * @example\n              * You have a Macro available to make the str function really\n              * easilly :\n              * ```cpp\n              * display_attr(attribute)\n              * ```\n              * Which will automaticly translate to\n              * ```cpp\n              * Flint::Colors::F_BLUE &lt;&lt; \"attribute\" &lt;&lt; Flint::Colors::RESET &lt;&lt; \"=\" &lt;&lt; Flint::Colors::RED &lt;&lt; this-&gt;attribute &lt;&lt; Flint::Colors::RESET\n              * ```\n              * There is also a `make_str` macro, which you can use as follow :\n              * ```cpp\n              * return make_str(\"a=12\" &lt;&lt; \", \" &lt;&lt; \"b=5\");\n              * ```\n              * that becomes\n              * ```cpp\n              * return ({std::stringstream ss; ss &lt;&lt; \"&lt;\" &lt;&lt; this-&gt;getClassName() &lt;&lt; \" at \" &lt;&lt; std::hex &lt;&lt; this &lt;&lt; \": \" &lt;&lt; \"a=12\" &lt;&lt; \", \" &lt;&lt; \"b=5\" &lt;&lt; \"&gt;\"; ss.str()})\n              * ```\n              * It means you can define the str function of your class as like that :\n              * ```cpp\n              * // Provided you have 3 attributes called a, b and c\n              * return make_str(display_attr(a) &lt;&lt; \", \" &lt;&lt; display_attr(b) &lt;&lt; \", \" &lt;&lt; display_attr(c));\n              * ```\n              *\n              * @return The string representation of the class\n            */\n            virtual std::string str() const\n            {\n                std::stringstream ss;\n\n                ss &lt;&lt; \"&lt;\" &lt;&lt;\n                    Flint::Colors::F_PURPLE &lt;&lt; this-&gt;getClassName() &lt;&lt; Flint::Colors::RESET &lt;&lt;\n                    \" at \" &lt;&lt;\n                    Flint::Colors::YELLOW   &lt;&lt; std::hex &lt;&lt; this     &lt;&lt; Flint::Colors::RESET &lt;&lt;\n                    \"&gt;\";\n\n                return ss.str();\n            }\n\n            /** Overload the operator &lt;&lt; to use the str method of the object\n              *\n              * @tparam T Reflected class\n              *\n              * @param os Reference of ostream (I.E. std::cout, std::cerr...)\n              *\n              * @param obj Object reference to be displayed\n              *\n              * @return Param os\n            */\n            friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Inspection&lt;T&gt;&amp; obj)\n            {\n                os &lt;&lt; obj.str();\n                return os;\n            }\n    };\n}\n\n\n#endif\n</code></pre>"},{"location":"coverage/flint/src/hpp/Preprocessor.hpp/","title":"Preprocessor.hpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Thu, May, 2024                                                     *\n * Title           - CppLib                                                             *\n * Description     -                                                                    *\n *     Preprocessor                                                                     *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *       \u2584\u2580\u2580\u2588\u2584\u2584\u2584\u2584  \u2584\u2580\u2580\u2584\u2580\u2580\u2580\u2584  \u2584\u2580\u2580\u2588\u2580\u2584    \u2584\u2580\u2580\u2580\u2588\u2580\u2580\u2584  \u2584\u2580\u2580\u2588\u2584\u2584\u2584\u2584  \u2584\u2580\u2584\u2584\u2584\u2584   \u2584\u2580\u2580\u2584 \u2584\u2584             *\n *      \u2590  \u2584\u2580   \u2590 \u2588   \u2588   \u2588 \u2588   \u2588  \u2588  \u2588    \u2588  \u2590 \u2590  \u2584\u2580   \u2590 \u2588 \u2588    \u258c \u2588  \u2588   \u2584\u2580            *\n *        \u2588\u2584\u2584\u2584\u2584\u2584  \u2590  \u2588\u2580\u2580\u2580\u2580  \u2590   \u2588  \u2590  \u2590   \u2588       \u2588\u2584\u2584\u2584\u2584\u2584  \u2590 \u2588      \u2590  \u2588\u2584\u2584\u2584\u2588             *\n *        \u2588    \u258c     \u2588          \u2588        \u2588        \u2588    \u258c    \u2588         \u2588   \u2588             *\n *       \u2584\u2580\u2584\u2584\u2584\u2584    \u2584\u2580        \u2584\u2580\u2580\u2580\u2580\u2580\u2584   \u2584\u2580        \u2584\u2580\u2584\u2584\u2584\u2584    \u2584\u2580\u2584\u2584\u2584\u2584\u2580   \u2584\u2580  \u2584\u2580             *\n *       \u2588    \u2590   \u2588         \u2588       \u2588 \u2588          \u2588    \u2590   \u2588     \u2590   \u2588   \u2588               *\n *       \u2590        \u2590         \u2590       \u2590 \u2590          \u2590        \u2590         \u2590   \u2590               *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#ifndef INCLUDED_PREPROCESSOR_HPP\n    #define INCLUDED_PREPROCESSOR_HPP\n\n#if defined(__GNUC__)\n    #define __FUNCTION__ __PRETTY_FUNCTION__\n#elif defined(_MSC_VER)\n    #define __FUNCTION__ __FUNCSIG__\n#else\n    #define __FUNCTION__ __func__\n#endif\n\n    #define __POSITION_INFOS__ {{std::string(__FILE__), __LINE__}, std::string(__FUNCTION__)}\n    #define throw_exception(exception, message) throw(exception(message, __POSITION_INFOS__))\n    #define catch_exception(exception) exception.show(__POSITION_INFOS__)\n\n// Inspection\n    #define display_attr(attribute) Flint::Colors::F_BLUE &lt;&lt; #attribute &lt;&lt; Flint::Colors::RESET &lt;&lt; \"=\" &lt;&lt; Flint::Colors::RED &lt;&lt; this-&gt;attribute &lt;&lt; Flint::Colors::RESET\n    #define make_str(display) ({std::stringstream ss; ss &lt;&lt; Flint::Colors::RESET &lt;&lt; \"&lt;\" &lt;&lt; Flint::Colors::F_PURPLE &lt;&lt; this-&gt;getClassName() &lt;&lt; Flint::Colors::RESET &lt;&lt; \" at \" &lt;&lt; Flint::Colors::YELLOW &lt;&lt; std::hex &lt;&lt; this &lt;&lt; std::dec &lt;&lt; Flint::Colors::RESET &lt;&lt; \": \" &lt;&lt; display &lt;&lt; \"&gt;\"; ss.str();})\n\n#endif\n</code></pre>"},{"location":"coverage/network/","title":"network","text":"Name Lines Covered Uncovered Coverage src 58 25 33 43.1% Security 58 25 33 43.1% DecodeError.hpp 3 0 3 0.0% GaloisField.cpp 8 0 8 0.0% GaloisField.hpp 1 0 1 0.0% HammingCodes.cpp 42 25 17 59.5% HammingCodes.hpp 1 0 1 0.0% ReedSolomon.cpp 2 0 2 0.0% ReedSolomon.hpp 1 0 1 0.0% export.hpp 0 0 0 100.0% Summary 58 25 33 43.1% Summary 58 25 33 43.1% Summary 58 25 33 43.1%"},{"location":"coverage/network/src/","title":"src","text":"Name Lines Covered Uncovered Coverage Security 58 25 33 43.1% DecodeError.hpp 3 0 3 0.0% GaloisField.cpp 8 0 8 0.0% GaloisField.hpp 1 0 1 0.0% HammingCodes.cpp 42 25 17 59.5% HammingCodes.hpp 1 0 1 0.0% ReedSolomon.cpp 2 0 2 0.0% ReedSolomon.hpp 1 0 1 0.0% export.hpp 0 0 0 100.0% Summary 58 25 33 43.1% Summary 58 25 33 43.1%"},{"location":"coverage/network/src/export.hpp/","title":"export.hpp","text":"<pre><code>#ifndef INCLUDED_NETWORK_EXPORT_HPP\n    #define INCLUDED_NETWORK_EXPORT_HPP\n\n#ifdef _WIN32\n    #ifdef NETWORK_EXPORTS\n        #define NETWORK_API __declspec(dllexport)\n    #else\n        #define NETWORK_API __declspec(dllimport)\n    #endif\n#else\n    #define NETWORK_API\n#endif\n\n#endif\n</code></pre>"},{"location":"coverage/network/src/Security/","title":"Security","text":"Name Lines Covered Uncovered Coverage DecodeError.hpp 3 0 3 0.0% GaloisField.cpp 8 0 8 0.0% GaloisField.hpp 1 0 1 0.0% HammingCodes.cpp 42 25 17 59.5% HammingCodes.hpp 1 0 1 0.0% ReedSolomon.cpp 2 0 2 0.0% ReedSolomon.hpp 1 0 1 0.0% Summary 58 25 33 43.1%"},{"location":"coverage/network/src/Security/DecodeError.hpp/","title":"DecodeError.hpp","text":"<pre><code>#ifndef INCLUDED_NETWORK_DECODE_ERROR_HPP\n    #define INCLUDED_NETWORK_DECODE_ERROR_HPP\n\n    #include \"Flint.hpp\"\n    #include \"../export.hpp\"\n\nnamespace Network::Security\n{\n    class NETWORK_API DecodingError:\n        public Flint::Exceptions::Exception\n    {\n        public:\n            DecodingError(const std::string&amp; what = \"Could not decode/verify received data.\",\n                          std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; infos = {{\"\", 0}, \"\"}):\n                Exception(what, infos)\n            {}\n    };\n}\n\n#endif\n</code></pre>"},{"location":"coverage/network/src/Security/GaloisField.cpp/","title":"GaloisField.cpp","text":"<pre><code>#include \"GaloisField.hpp\"\n\nnamespace Network::Security\n{\n    GaloisField::GaloisField(int primitive, int field_size):\n        primitive(primitive), field_size(field_size)\n    {\n        throw_exception(Flint::Exceptions::NotImplementedError, \"GaloisField haven't been implemented yet !\");\n        this-&gt;exp_table.resize(this-&gt;field_size);\n        this-&gt;log_table.resize(this-&gt;field_size);\n\n        unsigned char x = 1;\n        for (unsigned char i = 0; i &lt; this-&gt;field_size; ++i) {\n            this-&gt;exp_table[i] = x;\n            this-&gt;log_table[x] = i;\n            x = (x * 2) % field_size;\n        }\n    }\n}\n</code></pre>"},{"location":"coverage/network/src/Security/GaloisField.hpp/","title":"GaloisField.hpp","text":"<pre><code>#ifndef INCLUDED_NETWORK_GALOIS_FIELD_HPP\n    #define INCLUDED_NETWORK_GALOIS_FIELD_HPP\n\n    #include \"Flint.hpp\"\n    #include \"DecodeError.hpp\"\n    #include \"../export.hpp\"\n\nnamespace Network::Security\n{\n    class NETWORK_API GaloisField\n    {\n        private:\n            unsigned char field_size;\n            unsigned char primitive;\n            std::string exp_table;\n            std::string log_table;\n\n        public:\n            GaloisField(int primitive, int field_size);\n            void generate_field(int primitive);\n            int add(int a, int b);\n            int multiply(int a, int b);\n            int inverse(int a);\n            int divide(int a, int b);\n    };\n}\n\n#endif\n</code></pre>"},{"location":"coverage/network/src/Security/HammingCodes.cpp/","title":"HammingCodes.cpp","text":"<pre><code>#include \"HammingCodes.hpp\"\n\nnamespace Network::Security\n{\n    unsigned HammingCodes::get_nb_parity(unsigned size)\n    {\n        int p = 0;\n        while (pow(2, p) &lt; size + p + 1)\n            ++p;\n        return p;\n    }\n\n    unsigned HammingCodes::get_nb_parity_from_final_size(unsigned size)\n    {\n        int p = 0;\n        while (pow(2, p) &lt;= size)\n            ++p;\n        return p - 1;\n    }\n\n    void HammingCodes::setBit(char&amp; byte, u_char pos, bool value)\n    {\n        if (pos &gt;= 8)\n            throw_exception(Network::Security::DecodingError, \"Could not modify bit level position greater than 7 !!!\");\n        if (value)\n            byte |= (1 &lt;&lt; pos);\n        else\n            byte &amp;= ~(1 &lt;&lt; pos);\n    }\n\n    bool HammingCodes::getBit(char byte, u_char pos)\n    {\n        if (pos &gt;= 8)\n            throw_exception(Network::Security::DecodingError, \"Could not modify bit level position greater than 7 !!!\");\n        return (byte &gt;&gt; pos) &amp; 1;\n    }\n\n    void HammingCodes::setParityBits(std::string&amp; data, unsigned size)\n    {\n        unsigned p = HammingCodes::get_nb_parity(size);\n\n        unsigned p_pos, parity;\n        for (unsigned i = 0; i &lt; p; ++i) {\n            p_pos = (1 &lt;&lt; i);\n            parity = 0;\n\n            for (unsigned j = p_pos - 1; j &lt; data.size(); j += (p_pos * 2))\n                for (unsigned k = j; k &lt; (j + p_pos) &amp;&amp; (k &lt; data.size()); ++k)\n                    parity ^= HammingCodes::getBit(data[k], k % 8);\n\n            HammingCodes::setBit(data[p_pos - 1], p_pos - 1, parity);\n        }\n    }\n\n    std::string HammingCodes::encode(const std::string&amp; data)\n    {\n        unsigned data_size = data.size() * 8;\n        unsigned p = HammingCodes::get_nb_parity(data_size);\n\n        std::string coded_data(data.size() + p, 0);\n\n        unsigned data_index = 0;\n        for (unsigned i = 0; i &lt; coded_data.size(); ++i) {\n            if (((i + 1) &amp; i) == 0)\n                continue;\n            HammingCodes::setBit(coded_data[i / 8], i % 8, HammingCodes::getBit(data[data_index / 8], data_index % 8));\n            ++data_index;\n        }\n\n        HammingCodes::setParityBits(coded_data, data_size);\n\n        return coded_data;\n    }\n\n    std::string HammingCodes::decode(const std::string&amp; data)\n    {\n        std::string mdata = data;\n        unsigned p = HammingCodes::get_nb_parity_from_final_size(mdata.size());\n\n        unsigned error_pos = 0;\n        unsigned par_pos, parity;\n        for (unsigned i = 0; i &lt; p; ++i) {\n            par_pos = (1 &lt;&lt; i);\n            parity = 0;\n\n            for (unsigned j = par_pos - 1; j &lt; mdata.size(); j += (par_pos * 2))\n                for (unsigned k = j; k &lt; j + par_pos &amp;&amp; k &lt; mdata.size(); k++)\n                    parity ^= HammingCodes::getBit(mdata[k], k % 8);\n\n            if (parity &amp;&amp; error_pos)\n                throw_exception(Network::Security::DecodingError, \"Retreived multiple errors in the input data\");\n            if (parity)\n                error_pos |= par_pos;\n        }\n\n        if (error_pos)\n            setBit(mdata[error_pos / 8], error_pos % 8, !getBit(mdata[error_pos / 8], error_pos % 8));\n\n        return mdata;\n    }\n}\n</code></pre>"},{"location":"coverage/network/src/Security/HammingCodes.hpp/","title":"HammingCodes.hpp","text":"<pre><code>#ifndef INCLUDED_REEDSOLOMON_HPP\n    #define INCLUDED_REEDSOLOMON_HPP\n\n    #include \"Flint.hpp\"\n    #include \"DecodeError.hpp\"\n    #include \"../export.hpp\"\n\nnamespace Network::Security\n{\n    const int PRIMITIVE = 0x11d;\n    const int FIELD_SIZE = 256;\n    const int N = 255;\n    const int K = 223;\n\n    class NETWORK_API HammingCodes\n    {\n        private:\n            static unsigned get_nb_parity(unsigned size);\n            static unsigned get_nb_parity_from_final_size(unsigned size);\n            static void setBit(char&amp; byte, u_char pos, bool value);\n            static bool getBit(char byte, u_char pos);\n            static void setParityBits(std::string&amp; data, unsigned size);\n        public:\n            static std::string encode(const std::string&amp; data);\n            static std::string decode(const std::string&amp; data);\n    };\n}\n\n\n#endif\n</code></pre>"},{"location":"coverage/network/src/Security/ReedSolomon.cpp/","title":"ReedSolomon.cpp","text":"<pre><code>#include \"ReedSolomon.hpp\"\n\nnamespace Network::Security\n{\n    ReedSolomon::ReedSolomon(int primitive, int field_size, int n, int k):\n        gf(primitive, field_size), primitive(primitive), field_size(field_size), n(n), k(k)\n    {\n        throw_exception(Flint::Exceptions::NotImplementedError, \"ReedSolomon haven't been implemented yet !\");\n    }\n}\n</code></pre>"},{"location":"coverage/network/src/Security/ReedSolomon.hpp/","title":"ReedSolomon.hpp","text":"<pre><code>#ifndef INCLUDED_NETWORK_REED_SOLOMON_HPP\n    #define INCLUDED_NETWORK_REED_SOLOMON_HPP\n\n    #include \"Flint.hpp\"\n    #include \"DecodeError.hpp\"\n    #include \"GaloisField.hpp\"\n    #include \"../export.hpp\"\n\nnamespace Network::Security\n{\n    class NETWORK_API ReedSolomon\n    {\n        private:\n            GaloisField gf;\n            int primitive;\n            int field_size;\n            int n, k;\n\n        public:\n            ReedSolomon(int primitive, int field_size, int n, int k);\n            std::string encode(const std::string&amp; message);\n    };\n}\n#endif\n</code></pre>"},{"location":"coverage/server/","title":"server","text":"Name Lines Covered Uncovered Coverage bak 21 0 21 0.0% main.cpp 21 0 21 0.0% src 46 0 46 0.0% ConfigParser.cpp 15 0 15 0.0% ConfigParser.hpp 0 0 0 100.0% Romm.cpp 25 0 25 0.0% Room.hpp 0 0 0 100.0% main.cpp 6 0 6 0.0% Summary 21 0 21 0.0% Summary 46 0 46 0.0% Summary 67 0 67 0.0%"},{"location":"coverage/server/bak/","title":"bak","text":"Name Lines Covered Uncovered Coverage main.cpp 21 0 21 0.0% Summary 21 0 21 0.0%"},{"location":"coverage/server/bak/main.cpp/","title":"main.cpp","text":"<pre><code>#include &lt;boost/asio.hpp&gt;\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;thread&gt;\n\n// RANDOM TCP SERVER AS POC\n\nusing boost::asio::ip::tcp;\n\nclass session : public std::enable_shared_from_this&lt;session&gt;\n{\n    private:\n        tcp::socket m_socket;\n        boost::asio::streambuf m_buffer;\n\n        void wait_for_request()\n        {\n            auto self(shared_from_this());\n            boost::asio::async_read_until(m_socket, m_buffer, \"\\0\",\n                [this, self](boost::system::error_code ec, std::size_t) {\n                    if (!ec)  {\n                        std::string data{\n                            std::istreambuf_iterator&lt;char&gt;(&amp;m_buffer),\n                            std::istreambuf_iterator&lt;char&gt;()\n                        };\n                        std::cout &lt;&lt; data &lt;&lt; std::endl;\n                        wait_for_request();\n                    } else {\n                        std::cerr &lt;&lt; \"error: \" &lt;&lt; ec &lt;&lt; std::endl;;\n                    }\n                });\n        }\n\n    public:\n        session(tcp::socket socket):\n            m_socket(std::move(socket)) {}\n\n        void run()\n        {\n            wait_for_request();\n        }\n};\n\nclass server\n{\n    private:\n        tcp::acceptor m_acceptor;\n\n        void do_accept()\n        {\n            m_acceptor.async_accept([this](boost::system::error_code ec, tcp::socket socket) {\n                if (!ec) {\n                    std::cout &lt;&lt; \"creating session on: \"\n                        &lt;&lt; socket.remote_endpoint().address().to_string()\n                        &lt;&lt; \":\" &lt;&lt; socket.remote_endpoint().port() &lt;&lt; std::endl;\n\n                    std::make_shared&lt;session&gt;(std::move(socket))-&gt;run();\n                } else {\n                    std::cout &lt;&lt; \"error: \" &lt;&lt; ec.message() &lt;&lt; std::endl;\n                }\n\n                do_accept();\n            });\n        }\n\n    public:\n        server(boost::asio::io_context&amp; io_context, short port):\n            m_acceptor(io_context, tcp::endpoint(tcp::v4(), port))\n        {\n            do_accept();\n        }\n};\n\nint main()\n{\n    boost::asio::io_context io_context;\n    server s(io_context, 25000);\n    io_context.run();\n\n    return 0;\n}\n</code></pre>"},{"location":"coverage/server/src/","title":"src","text":"Name Lines Covered Uncovered Coverage ConfigParser.cpp 15 0 15 0.0% ConfigParser.hpp 0 0 0 100.0% Romm.cpp 25 0 25 0.0% Room.hpp 0 0 0 100.0% main.cpp 6 0 6 0.0% Summary 46 0 46 0.0%"},{"location":"coverage/server/src/ConfigParser.cpp/","title":"ConfigParser.cpp","text":"<pre><code>#include \"ConfigParser.hpp\"\n#include &lt;fstream&gt;\n#include &lt;stdexcept&gt;\n#include &lt;sstream&gt;\n\nstd::map&lt;std::string, std::map&lt;std::string, std::string&gt;&gt; ConfigParser::parse(const std::string&amp; filePath) {\n    std::ifstream file(filePath);\n    if (!file.is_open()) {\n        throw std::runtime_error(\"Impossible d'ouvrir le fichier : \" + filePath);\n    }\n\n    std::map&lt;std::string, std::map&lt;std::string, std::string&gt;&gt; iniData;\n    std::string currentSection;\n\n    std::string line;\n    while (std::getline(file, line)) {\n        // Ignore les lignes vides ou les commentaires\n        if (line.empty() || line[0] == ';') continue;\n\n        // Section\n        if (line[0] == '[' &amp;&amp; line.back() == ']') {\n            currentSection = line.substr(1, line.size() - 2);\n            iniData[currentSection] = {};\n        } else {\n            // Cl\u00e9 = Valeur\n            size_t delimiterPos = line.find('=');\n            if (delimiterPos != std::string::npos) {\n                std::string key = line.substr(0, delimiterPos);\n                std::string value = line.substr(delimiterPos + 1);\n                iniData[currentSection][key] = value;\n            }\n        }\n    }\n\n    if (iniData.empty()) {\n        throw std::runtime_error(\"Le fichier INI est vide ou mal format\u00e9.\");\n    }\n\n    return iniData;\n}\n</code></pre>"},{"location":"coverage/server/src/ConfigParser.hpp/","title":"ConfigParser.hpp","text":"<pre><code>#ifndef CONFIGPARSER_HPP\n#define CONFIGPARSER_HPP\n\n#include &lt;string&gt;\n#include &lt;map&gt;\n\nclass ConfigParser {\npublic:\n    static std::map&lt;std::string, std::map&lt;std::string, std::string&gt;&gt; parse(const std::string&amp; filePath);\n};\n\n#endif // CONFIGPARSER_HPP\n</code></pre>"},{"location":"coverage/server/src/Romm.cpp/","title":"Romm.cpp","text":"<pre><code>#include \"Room.hpp\"\n#include \"ConfigParser.hpp\" // Inclure le parser\n#include &lt;iostream&gt;\n#include &lt;stdexcept&gt;\n\nRoom::Room(int number, const std::string&amp; type, int capacity)\n    : roomNumber(number), roomType(type) {\n    setRoomCapacity(capacity);\n}\n\nRoom::~Room() {}\n\n// Getters\nint Room::getRoomNumber() const { return roomNumber; }\n\nstd::string Room::getRoomType() const { return roomType; }\n\nint Room::getRoomCapacity() const { return roomCapacity; }\n\n// Setters\nvoid Room::setRoomNumber(int number) { roomNumber = number; }\n\nvoid Room::setRoomType(const std::string&amp; type) { roomType = type; }\n\nvoid Room::setRoomCapacity(int capacity) {\n    if (roomType == \"solo\" &amp;&amp; capacity != 1) {\n        throw std::invalid_argument(\"La capacit\u00e9 d'une salle Solo doit \u00eatre 1\");\n    } else if ((roomType == \"multi\" || roomType == \"infini\") &amp;&amp; capacity &gt; 4) {\n        throw std::invalid_argument(\"La capacit\u00e9 d'une salle Multi ou Infini doit \u00eatre au maximum 4\");\n    }\n    roomCapacity = capacity;\n}\n\n// Afficher les informations de la salle\nvoid Room::displayRoomInfo() const {\n    std::cout &lt;&lt; \"Room Number: \" &lt;&lt; roomNumber &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Room Type: \" &lt;&lt; roomType &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Room Capacity: \" &lt;&lt; roomCapacity &lt;&lt; std::endl;\n}\n\n// Charger les salles depuis le fichier INI\nstd::vector&lt;Room&gt; Room::loadRoomsFromConfig(const std::string&amp; filePath) {\n    auto config = ConfigParser::parse(filePath); // Appel du parser\n    std::vector&lt;Room&gt; rooms;\n    int roomNumber = 1;\n\n    for (const auto&amp; [section, properties] : config) {\n        if (properties.find(\"maxcapacity\") == properties.end() || properties.find(\"roomtype\") == properties.end()) {\n            throw std::invalid_argument(\"Cl\u00e9 manquante dans la section : \" + section);\n        }\n\n        std::string type = properties.at(\"roomtype\");\n        int capacity;\n\n        try {\n            capacity = std::stoi(properties.at(\"maxcapacity\"));\n        } catch (const std::invalid_argument&amp; e) {\n            throw std::invalid_argument(\"Capacit\u00e9 invalide pour la salle dans la section : \" + section);\n        } catch (const std::out_of_range&amp; e) {\n            throw std::out_of_range(\"Capacit\u00e9 trop grande pour la salle dans la section : \" + section);\n        }\n\n        rooms.emplace_back(roomNumber++, type, capacity);\n    }\n\n    return rooms;\n}\n</code></pre>"},{"location":"coverage/server/src/Room.hpp/","title":"Room.hpp","text":"<pre><code>#ifndef ROOM_HPP\n#define ROOM_HPP\n\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n\nclass Room {\nprivate:\n    int roomNumber;\n    std::string roomType; // Type sous forme de cha\u00eene\n    int roomCapacity;\n\npublic:\n    Room(int number, const std::string&amp; type, int capacity);\n    ~Room();\n\n    // Getters\n    int getRoomNumber() const;\n    std::string getRoomType() const;\n    int getRoomCapacity() const;\n\n    // Setters\n    void setRoomNumber(int number);\n    void setRoomType(const std::string&amp; type);\n    void setRoomCapacity(int capacity);\n\n    // Afficher les informations de la salle\n    void displayRoomInfo() const;\n\n    // Charger les salles depuis le fichier INI\n    static std::vector&lt;Room&gt; loadRoomsFromConfig(const std::string&amp; filePath);\n};\n\n#endif // ROOM_HPP\n</code></pre>"},{"location":"coverage/server/src/main.cpp/","title":"main.cpp","text":"<pre><code>#include \"Room.hpp\"\n#include &lt;iostream&gt;\n\nint main() {\n    try {\n        const std::string configFilePath = \"./src/config.ini\"; // Chemin relatif ou absolu\n        auto rooms = Room::loadRoomsFromConfig(configFilePath);\n\n        for (const auto&amp; room : rooms) {\n            room.displayRoomInfo();\n            std::cout &lt;&lt; \"---------------------\" &lt;&lt; std::endl;\n        }\n    } catch (const std::exception&amp; e) {\n        std::cerr &lt;&lt; \"Erreur : \" &lt;&lt; e.what() &lt;&lt; std::endl;\n    }\n\n    return 0;\n}\n</code></pre>"}]}