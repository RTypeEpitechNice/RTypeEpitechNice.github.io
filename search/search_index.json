{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"RType","text":"<p>A GAME ENGINE THAT ROARS !</p> RType Client Client side part of the RType project. Entity Component System While not a required part of the project, the Entity Component System (or ECS) is quite important. Flint A custom implementation of the Flint library Network Custom classes handeling all the networking. Server As important as all of the other parts (if not more), the server is the masterchief of the orchestra. Client ECS Network Server <p> Code Coverage</p>"},{"location":"#types","title":"Types","text":"Name Description ComponentStorageBase ComponentStorage Interface ComponentStorage Stores all of the components of a same type wrapped in a std::shared_ptr  <code>Component</code> :    Struct of the component. Socket Simple encapsulation of unistd socket It assures proper connection to the client and handles the data exchange. Socket Simple encapsulation of unistd socket It assures proper connection to the client and handles the data exchange."},{"location":"ComponentStorage/","title":"ComponentStorage","text":"<p>template &lt;typename Component&gt; class ComponentStorage : public ComponentStorageBase</p> <p>Stores all of the components of a same type wrapped in a std::shared_ptr</p> <code>Component</code> Struct of the component."},{"location":"ComponentStorage/#functions","title":"Functions","text":"Name Description get Get component wrapped in a std::optional  <code>id</code> :    Entity ID. add Add a component for an entity  <code>id</code> :    Entity ID. remove Remove component from an entity  <code>id</code> :    Entity ID."},{"location":"ComponentStorage/#function-details","title":"Function Details","text":""},{"location":"ComponentStorage/#get","title":"get","text":"<p>std::optional&lt;std::shared_ptr&lt;Component&gt;&gt; get(ECS::entity_id id)</p> <p>Get component wrapped in a std::optional</p> <code>id</code> Entity ID."},{"location":"ComponentStorage/#add","title":"add","text":"<p>void add(ECS::entity_id id, std::shared_ptr&lt;Component&gt; component)</p> <p>Add a component for an entity</p> <code>id</code> Entity ID."},{"location":"ComponentStorage/#remove","title":"remove","text":"<p>void remove(ECS::entity_id id)</p> <p>Remove component from an entity</p> <code>id</code> Entity ID."},{"location":"ComponentStorageBase/","title":"ComponentStorageBase","text":"<p>class ComponentStorageBase</p> <p>ComponentStorage Interface</p>"},{"location":"Socket/","title":"Socket","text":"<p>class Socket</p> <p>Simple encapsulation of unistd socket It assures proper connection to the client and handles the data exchange.</p>"},{"location":"Client/","title":"Client","text":""},{"location":"Client/#types","title":"Types","text":"Name Description Core Handles the core loop of the client Handles the ECSManager and the connection to the server in one thread."},{"location":"Client/Core/","title":"Core","text":"<p>class Core</p> <p>Handles the core loop of the client Handles the ECSManager and the connection to the server in one thread.</p>"},{"location":"Client/Core/#functions","title":"Functions","text":"Name Description run Run the client's loop handleEvent Handles the window's event like button press. handleServerMessage Checks the message sent by the server and executes the correct CMD method  <code>message</code> :    Message sent by the server hideNonUpdatedElements Removes all ECS elements that were not updated by the server this frame createPlayers Creates X number of player entities in the ECS based on the server's \"start\" command  <code>nbrPlayers</code> :    Number of players this game startCMD Handles the \"start\" command It switches to the game world in the ECSManager ad spawns the players endCMD Handles the \"end\" command It switches back to the title screen and cleans all entities in the game world placeCMD Handles the \"place\" command Creates entity prefabs and places them in the correct position playerCMD Handles the \"player\" command Places the correct player at the x and y positions provided by the server playerDeadCMD Handles the \"playerDead\" command It deletes the player game object and spawns an explosion animation bulletHitCMD Handles the \"bulletHit\" command spawns an explosion at the impact ennemyDeadCMD Handles the \"start\" command Spawns an explosion at the enemy's position"},{"location":"Client/Core/#function-details","title":"Function Details","text":""},{"location":"Client/Core/#run","title":"run","text":"<p>void run()</p> <p>Run the client's loop</p>"},{"location":"Client/Core/#handleevent","title":"handleEvent","text":"<p>void handleEvent()</p> <p>Handles the window's event like button press.</p>"},{"location":"Client/Core/#handleservermessage","title":"handleServerMessage","text":"<p>void handleServerMessage(std::string message)</p> <p>Checks the message sent by the server and executes the correct CMD method</p> <code>message</code> Message sent by the server"},{"location":"Client/Core/#hidenonupdatedelements","title":"hideNonUpdatedElements","text":"<p>void hideNonUpdatedElements()</p> <p>Removes all ECS elements that were not updated by the server this frame</p>"},{"location":"Client/Core/#createplayers","title":"createPlayers","text":"<p>void createPlayers(int nbrPlayers)</p> <p>Creates X number of player entities in the ECS based on the server's \"start\" command</p> <code>nbrPlayers</code> Number of players this game"},{"location":"Client/Core/#startcmd","title":"startCMD","text":"<p>void startCMD(std::vector&lt;std::string&gt; args)</p> <p>Handles the \"start\" command     It switches to the game world in the ECSManager ad spawns the players</p>"},{"location":"Client/Core/#endcmd","title":"endCMD","text":"<p>void endCMD(std::vector&lt;std::string&gt; args)</p> <p>Handles the \"end\" command     It switches back to the title screen and cleans all entities in the game world</p>"},{"location":"Client/Core/#placecmd","title":"placeCMD","text":"<p>void placeCMD(std::vector&lt;std::string&gt; args)</p> <p>Handles the \"place\" command     Creates entity prefabs and places them in the correct position</p>"},{"location":"Client/Core/#playercmd","title":"playerCMD","text":"<p>void playerCMD(std::vector&lt;std::string&gt; args)</p> <p>Handles the \"player\" command     Places the correct player at the x and y positions provided by the server</p>"},{"location":"Client/Core/#playerdeadcmd","title":"playerDeadCMD","text":"<p>void playerDeadCMD(std::vector&lt;std::string&gt; args)</p> <p>Handles the \"playerDead\" command     It deletes the player game object and spawns an explosion animation</p>"},{"location":"Client/Core/#bullethitcmd","title":"bulletHitCMD","text":"<p>void bulletHitCMD(std::vector&lt;std::string&gt; args)</p> <p>Handles the \"bulletHit\" command     spawns an explosion at the impact</p>"},{"location":"Client/Core/#ennemydeadcmd","title":"ennemyDeadCMD","text":"<p>void ennemyDeadCMD(std::vector&lt;std::string&gt; args)</p> <p>Handles the \"start\" command     Spawns an explosion at the enemy's position</p>"},{"location":"ECS/","title":"ECS","text":"Component System"},{"location":"ECS/#types","title":"Types","text":"Name Description AScript Default abstract of IScript, only global functions are defined. ComponentManager Stores and Manages all of the components of all entities currently existing The template \"Component\" corresponds to all of the structs avaliable in Components.hpp EntityManager Responsible for creating, deleting and getting all entities IScript Interface for script classes Registry Mediator that wraps Component and Entity manager, this should be where you manipulate a world's content. SystemManager Responsible for running and adding systems that are active during the execution It also keeps track of the deltaTime between frames"},{"location":"ECS/AScript/","title":"AScript","text":"<p>class AScript : public ECS::IScript</p> <p>Default abstract of IScript, only global functions are defined.</p> <p>This script's methods will be called by the engine in specific moments, they cannot be called elsewhere</p> <p>Classes that inherit from this (the scripts you will create) can have their own private variables or component pointers (see example scripts in the ScriptSource folder for example)</p> <code>Game</code> Pointer to access the engine class's content <code>_selfID</code> ID of the script's entity"},{"location":"ECS/AScript/#functions","title":"Functions","text":"Name Description onStart Called on Entity's first frame of existence, usefull for getting all components once onUpdate Called every frame onCollision Called when an entity collides with another, they need a hitbox component to be activatable  <code>id</code> :    ID of the entity who collided the script's owner onClick Called when mouse clicks on the entity, they need to have an hitbox setEcsManager Called when Script is assigned to an entity so that they can manipulate the engine  <code>ecsManager</code> :    Pointer to ECSManager Class (the engine). setEntityID Defines the script's user ID  <code>id</code> :    Entity ID. spawnPrefabAt Automatically spawn a prefab at (x, y), useful for spawning decor or temporary animation elements !!! warning NOT RECOMMENDED, MODIFYING ENTITIES CREATED BY THIS METHOD MAY CAUSE CRASH  <code>prefabName</code> :    Prefab name.  <code>x</code> :    X position  <code>y</code> :    Y position"},{"location":"ECS/AScript/#function-details","title":"Function Details","text":""},{"location":"ECS/AScript/#onstart","title":"onStart","text":"<p>void onStart()</p> <p>Called on Entity's first frame of existence, usefull for getting all components once</p>"},{"location":"ECS/AScript/#onupdate","title":"onUpdate","text":"<p>void onUpdate()</p> <p>Called every frame</p>"},{"location":"ECS/AScript/#oncollision","title":"onCollision","text":"<p>void onCollision(ECS::entity_id id)</p> <p>Called when an entity collides with another, they need a hitbox component to be activatable</p> <code>id</code> ID of the entity who collided the script's owner"},{"location":"ECS/AScript/#onclick","title":"onClick","text":"<p>void onClick()</p> <p>Called when mouse clicks on the entity, they need to have an hitbox</p>"},{"location":"ECS/AScript/#setecsmanager","title":"setEcsManager","text":"<p>void setEcsManager(ECS::ECSManager* ecsManager)</p> <p>Called when Script is assigned to an entity so that they can manipulate the engine</p> <code>ecsManager</code> Pointer to ECSManager Class (the engine)."},{"location":"ECS/AScript/#setentityid","title":"setEntityID","text":"<p>void setEntityID(ECS::entity_id id)</p> <p>Defines the script's user ID</p> <code>id</code> Entity ID."},{"location":"ECS/AScript/#spawnprefabat","title":"spawnPrefabAt","text":"<p>ECS::entity_id spawnPrefabAt(std::string prefabName, int x, int y)</p> <p>Automatically spawn a prefab at (x, y), useful for spawning decor or temporary animation elements</p> <p>Warning</p> <p>NOT RECOMMENDED, MODIFYING ENTITIES CREATED BY THIS METHOD MAY CAUSE CRASH</p> <code>prefabName</code> Prefab name. <code>x</code> X position <code>y</code> Y position"},{"location":"ECS/ComponentManager/","title":"ComponentManager","text":"<p>class ComponentManager</p> <p>Stores and Manages all of the components of all entities currently existing The template \"Component\" corresponds to all of the structs avaliable in Components.hpp</p>"},{"location":"ECS/ComponentManager/#functions","title":"Functions","text":"Name Description addComponent Add a component to an entity in the current world  <code>id</code> :    Entity ID  <code>Component</code> :    Component's struct which's values are setup or not removeComponent Remove a component from an entity in the current world  <code>id</code> :    Entity ID  <code>Component</code> :    Component's struct !!! warning It should be called like this: removeComponent(id) removeAllComponents Remove all of the components from an entity  <code>id</code> :    Entity ID getComponent Get a component from an entity in the current world, you can then modify the shared_ptr component to directly modify it's information inside the entity, no need to re-add it  <code>id</code> :    Entity ID  <code>Component</code> :    Component's struct !!! warning It should be called like this: getComponent(id)  Return :    Entity's component wrapped in a shared_ptr getEntitiesWithComponent Returns a list of all the entities that have a component type, usefull when you create a System or want to know only certain entities to increase performance  <code>Component</code> :    Component's struct !!! warning It should be called like this: getEntitiesWithComponent() getComponentStorage Returns the component storage of a component type  <code>Component</code> :    Component's struct !!! warning It should be called like this: getComponentStorage(id)  Return :    Entity's component Storage"},{"location":"ECS/ComponentManager/#function-details","title":"Function Details","text":""},{"location":"ECS/ComponentManager/#addcomponent","title":"addComponent","text":"<p>template &lt;typename Component&gt; void addComponent(ECS::entity_id id, Component component)</p> <p>Add a component to an entity in the current world</p> <code>id</code> Entity ID <code>Component</code> Component's struct which's values are setup or not"},{"location":"ECS/ComponentManager/#removecomponent","title":"removeComponent","text":"<p>template &lt;typename Component&gt; void removeComponent(ECS::entity_id id)</p> <p>Remove a component from an entity in the current world</p> <code>id</code> Entity ID <code>Component</code> Component's struct <p>Warning</p> <p>It should be called like this: removeComponent(id)"},{"location":"ECS/ComponentManager/#removeallcomponents","title":"removeAllComponents","text":"<p>void removeAllComponents(ECS::entity_id id)</p> <p>Remove all of the components from an entity</p> <code>id</code> Entity ID"},{"location":"ECS/ComponentManager/#getcomponent","title":"getComponent","text":"<p>template &lt;typename Component&gt; std::optional&lt;std::shared_ptr&lt;Component&gt;&gt; getComponent(ECS::entity_id id)</p> <p>Get a component from an entity in the current world, you can then modify the shared_ptr component to directly modify it's information inside the entity, no need to re-add it</p> <code>id</code> Entity ID <code>Component</code> Component's struct <p>Warning</p> <p>It should be called like this: getComponent(id) Return Entity's component wrapped in a shared_ptr"},{"location":"ECS/ComponentManager/#getentitieswithcomponent","title":"getEntitiesWithComponent","text":"<p>template &lt;typename Component&gt; std::vector&lt;ECS::entity_id&gt; getEntitiesWithComponent()</p> <p>Returns a list of all the entities that have a component type, usefull when you create a System or want to know only certain entities to increase performance</p> <code>Component</code> Component's struct <p>Warning</p> <p>It should be called like this: getEntitiesWithComponent()"},{"location":"ECS/ComponentManager/#getcomponentstorage","title":"getComponentStorage","text":"<p>template &lt;typename Component&gt; ComponentStorage&lt;Component&gt;&amp; getComponentStorage()</p> <p>Returns the component storage of a component type</p> <code>Component</code> Component's struct <p>Warning</p> <p>It should be called like this: getComponentStorage(id) Return Entity's component Storage"},{"location":"ECS/EntityManager/","title":"EntityManager","text":"<p>class EntityManager</p> <p>Responsible for creating, deleting and getting all entities</p>"},{"location":"ECS/EntityManager/#functions","title":"Functions","text":"Name Description createEntity Create an empty entity in the current world  Return :    Created entity ID destroyEntity Destroy an entity in the current world  <code>id</code> :    ID of the entity to destroy getAllEntities Returns all of the entities in the registry  Return :    List of all entities"},{"location":"ECS/EntityManager/#function-details","title":"Function Details","text":""},{"location":"ECS/EntityManager/#createentity","title":"createEntity","text":"<p>const entity_id &amp;createEntity()</p> <p>Create an empty entity in the current world</p> Return Created entity ID"},{"location":"ECS/EntityManager/#destroyentity","title":"destroyEntity","text":"<p>void destroyEntity(const entity_id &amp;id)</p> <p>Destroy an entity in the current world</p> <code>id</code> ID of the entity to destroy"},{"location":"ECS/EntityManager/#getallentities","title":"getAllEntities","text":"<p>std::vector&lt;ECS::entity_id&gt; getAllEntities()</p> <p>Returns all of the entities in the registry</p> Return List of all entities"},{"location":"ECS/IScript/","title":"IScript","text":"<p>class IScript</p> <p>Interface for script classes</p>"},{"location":"ECS/Registry/","title":"Registry","text":"<p>class Registry</p> <p>Mediator that wraps Component and Entity manager, this should be where you manipulate a world's content. It also contains all the entities of the world.</p>"},{"location":"ECS/SystemManager/","title":"SystemManager","text":"<p>class SystemManager</p> <p>Responsible for running and adding systems that are active during the execution It also keeps track of the deltaTime between frames</p>"},{"location":"ECS/Component/","title":"Component","text":""},{"location":"ECS/Component/#types","title":"Types","text":"Name Description Acceleration Acceleration of entity  <code>x</code> :    X acceleration.  <code>y</code> :    Y acceleration. !!! warning THIS COMPONENT IS NOT IMPLEMENTED Animation Animation rect of entity  <code>rect</code> :    Frame for sprite.  <code>fps</code> :    Frame per second.  <code>destroyAtEnt</code> :    If true, the entity will automatically be destroyed at the end of the animation, perfect for particles Drawable Visual for entity  <code>sprite</code> :    Sprite.  <code>center</code> :    If true, the sprite will be centered based on it's position Health Health information for component  <code>health</code> :    Health value Hitbox Rectangle box for collisions/zone/etc...  <code>x</code> :    X outset.  <code>y</code> :    Y outset.  <code>w</code> :    width.  <code>h</code> :    height. Parallax Parallax movement for entity  <code>speed</code> :    Speed of parallax, goes backwards if negative value. !!! warning Float values can sometimes not work, for onsistency, only use int values PlayerInput Used for debugging local inputs  <code>up,</code> :    down, left, right, action Action value. Position Position inside world space  <code>x</code> :    X position.  <code>y</code> :    Y position. Script Scripting on entity  <code>name</code> :    Script name. SpriteSheet Spritesheet info for selecting Sprite part on One line  <code>nbrOfState</code> :    nbr of different states avaliable.  <code>state</code> :    state selected. !!! warning THIS COMPONENT IS NOT IMPLEMENTED OR FUNCTIONAL State State value usable for StateMachine or simply indicating a state  <code>name</code> :    State name. Tag Tag value usable for entity labeling/categorisation Usefull for entity differentiation when colliding for example  <code>name</code> :    State name. Velocity Velocity of entity  <code>x</code> :    X speed.  <code>y</code> :    Y speed."},{"location":"ECS/Component/Acceleration/","title":"Acceleration","text":"<p>struct Acceleration</p> <p>Acceleration of entity</p> <code>x</code> X acceleration. <code>y</code> Y acceleration. <p>Warning</p> <p>THIS COMPONENT IS NOT IMPLEMENTED</p>"},{"location":"ECS/Component/Animation/","title":"Animation","text":"<p>struct Animation</p> <p>Animation rect of entity</p> <code>rect</code> Frame for sprite. <code>fps</code> Frame per second. <code>destroyAtEnt</code> If true, the entity will automatically be destroyed at the end of the animation, perfect for particles"},{"location":"ECS/Component/Drawable/","title":"Drawable","text":"<p>struct Drawable</p> <p>Visual for entity</p> <code>sprite</code> Sprite. <code>center</code> If true, the sprite will be centered based on it's position"},{"location":"ECS/Component/Health/","title":"Health","text":"<p>struct Health</p> <p>Health information for component</p> <code>health</code> Health value"},{"location":"ECS/Component/Hitbox/","title":"Hitbox","text":"<p>struct Hitbox</p> <p>Rectangle box for collisions/zone/etc...</p> <code>x</code> X outset. <code>y</code> Y outset. <code>w</code> width. <code>h</code> height."},{"location":"ECS/Component/Parallax/","title":"Parallax","text":"<p>struct Parallax</p> <p>Parallax movement for entity</p> <code>speed</code> Speed of parallax, goes backwards if negative value. <p>Warning</p> <p>Float values can sometimes not work, for onsistency, only use int values</p>"},{"location":"ECS/Component/PlayerInput/","title":"PlayerInput","text":"<p>struct PlayerInput</p> <p>Used for debugging local inputs</p> <code>up,</code> down, left, right, action Action value."},{"location":"ECS/Component/Position/","title":"Position","text":"<p>struct Position</p> <p>Position inside world space</p> <code>x</code> X position. <code>y</code> Y position."},{"location":"ECS/Component/Script/","title":"Script","text":"<p>struct Script</p> <p>Scripting on entity</p> <code>name</code> Script name."},{"location":"ECS/Component/SpriteSheet/","title":"SpriteSheet","text":"<p>struct SpriteSheet</p> <p>Spritesheet info for selecting Sprite part on One line</p> <code>nbrOfState</code> nbr of different states avaliable. <code>state</code> state selected. <p>Warning</p> <p>THIS COMPONENT IS NOT IMPLEMENTED OR FUNCTIONAL</p>"},{"location":"ECS/Component/State/","title":"State","text":"<p>struct State</p> <p>State value usable for StateMachine or simply indicating a state</p> <code>name</code> State name."},{"location":"ECS/Component/Tag/","title":"Tag","text":"<p>struct Tag</p> <p>Tag value usable for entity labeling/categorisation     Usefull for entity differentiation when colliding for example</p> <code>name</code> State name."},{"location":"ECS/Component/Velocity/","title":"Velocity","text":"<p>struct Velocity</p> <p>Velocity of entity</p> <code>x</code> X speed. <code>y</code> Y speed."},{"location":"ECS/System/","title":"System","text":""},{"location":"ECS/System/#types","title":"Types","text":"Name Description Animate Manages the entities's animation component and apply it to their drawable Collision Manages the collisions between entities and execute their's scripts \"onCollision()\" method if they do Draw Render's all active Drawable components on the window  <code>_win</code> :    the engine's window. Movement Manages all the entities movement by adding their velocity to their position. ParallaxSystem Manages the entities's parallax component and apply it to their drawable This cannot be used with an animation component. PlayerControl Debug Tool to manage local control for entities PlayerMovement Debug Tool to manage local movement for entities based on Debug Movement ScriptOnClick Executes the entity's \"onClick()\" method when the mouse clicks on it. ScriptUpdate Executes all active script's \"onUpdate()\" and \"onStart()\" methods."},{"location":"ECS/System/Animate/","title":"Animate","text":"<p>struct Animate</p> <p>Manages the entities's animation component and apply it to their drawable</p>"},{"location":"ECS/System/Collision/","title":"Collision","text":"<p>struct Collision</p> <p>Manages the collisions between entities and execute their's scripts \"onCollision()\" method if they do</p>"},{"location":"ECS/System/Draw/","title":"Draw","text":"<p>struct Draw</p> <p>Render's all active Drawable components on the window</p> <code>_win</code> the engine's window."},{"location":"ECS/System/Movement/","title":"Movement","text":"<p>struct Movement</p> <p>Manages all the entities movement by adding their velocity to their position.</p>"},{"location":"ECS/System/ParallaxSystem/","title":"ParallaxSystem","text":"<p>struct ParallaxSystem</p> <p>Manages the entities's parallax component and apply it to their drawable</p> <p>This cannot be used with an animation component.</p>"},{"location":"ECS/System/PlayerControl/","title":"PlayerControl","text":"<p>struct PlayerControl</p> <p>Debug Tool to manage local control for entities</p>"},{"location":"ECS/System/PlayerMovement/","title":"PlayerMovement","text":"<p>struct PlayerMovement</p> <p>Debug Tool to manage local movement for entities based on Debug Movement</p>"},{"location":"ECS/System/ScriptOnClick/","title":"ScriptOnClick","text":"<p>struct ScriptOnClick</p> <p>Executes the entity's \"onClick()\" method when the mouse clicks on it.</p> <code>_win</code> the engine's window. <code>mousePos</code> Mouse position value, it is modified each frame."},{"location":"ECS/System/ScriptUpdate/","title":"ScriptUpdate","text":"<p>struct ScriptUpdate</p> <p>Executes all active script's \"onUpdate()\" and \"onStart()\" methods.</p>"},{"location":"Network/","title":"Network","text":"Serialized"},{"location":"Network/Serialized/","title":"Serialized","text":""},{"location":"Network/Serialized/#types","title":"Types","text":"Name Description PlayerPosition"},{"location":"Network/Serialized/PlayerPosition/","title":"PlayerPosition","text":"<p>class PlayerPosition: public Flint::Inspection&lt;PlayerPosition&gt;</p>"},{"location":"Network/Serialized/PlayerPosition/#functions","title":"Functions","text":"Name Description str This class being a child of Flint::Inspection, overriding the str function also override the operator&lt;&lt;. This is done for debugging purposes."},{"location":"Network/Serialized/PlayerPosition/#function-details","title":"Function Details","text":""},{"location":"Network/Serialized/PlayerPosition/#str","title":"str","text":"<p>std::string str() const override</p> <p>This class being a child of Flint::Inspection, overriding the str function also override the operator&lt;&lt;. This is done for debugging purposes.</p>"},{"location":"Server/","title":"Server","text":""},{"location":"Server/#types","title":"Types","text":"Name Description Client Threaded class that handles communication between the server and the client. Core PlayerInfo Contains all gameplay information of the player in game"},{"location":"Server/Client/","title":"Client","text":"<p>class Client</p> <p>Threaded class that handles communication between the server and the client. It uses the encapsulated socket.</p>"},{"location":"Server/Client/#functions","title":"Functions","text":"Name Description start Starts the client thread and socket stop Starts the client thread sendMessage Send message to the client  <code>message</code> :    Message to send receiveMessage Check if the client sent data to the server and stores them in the queue, closes the thread if there is no message or is disconnected getMessageQueue Returns the message queue that contains the messages sent by the client"},{"location":"Server/Client/#function-details","title":"Function Details","text":""},{"location":"Server/Client/#start","title":"start","text":"<p>void start()</p> <p>Starts the client thread and socket</p>"},{"location":"Server/Client/#stop","title":"stop","text":"<p>void stop()</p> <p>Starts the client thread</p>"},{"location":"Server/Client/#sendmessage","title":"sendMessage","text":"<p>void sendMessage(const std::string&amp; message)</p> <p>Send message to the client</p> <code>message</code> Message to send"},{"location":"Server/Client/#receivemessage","title":"receiveMessage","text":"<p>void receiveMessage()</p> <p>Check if the client sent data to the server and stores them in the queue, closes the thread if there is no message or is disconnected</p>"},{"location":"Server/Client/#getmessagequeue","title":"getMessageQueue","text":"<p>ThreadSafeQueue&lt;std::string&gt;&amp; getMessageQueue()</p> <p>Returns the message queue that contains the messages sent by the client</p>"},{"location":"Server/Core/","title":"Core","text":"<p>class Core</p>"},{"location":"Server/Core/#functions","title":"Functions","text":"Name Description run Run the server's loop and threads processClientMessages Checks if any client sent a message to process with the handleCommand() method handleCommand Handles the client's command  <code>message</code> :    Client message containing the command  <code>clientNbr</code> :    Number of the client sendToAll Sends a message to all the clients at once  <code>message</code> :    Message to send checkPlayersCapabilities Checks player positiona and cooldown to prevent cheating or out of bounds sendGameUpdate Sends the player and all element positions. checkEvent Check if the ECSManager has any events this frame and sends them to clients."},{"location":"Server/Core/#function-details","title":"Function Details","text":""},{"location":"Server/Core/#run","title":"run","text":"<p>void run()</p> <p>Run the server's loop and threads</p>"},{"location":"Server/Core/#processclientmessages","title":"processClientMessages","text":"<p>void processClientMessages()</p> <p>Checks if any client sent a message to process with the handleCommand() method</p>"},{"location":"Server/Core/#handlecommand","title":"handleCommand","text":"<p>void handleCommand(std::string message, int clientNbr)</p> <p>Handles the client's command</p> <code>message</code> Client message containing the command <code>clientNbr</code> Number of the client"},{"location":"Server/Core/#sendtoall","title":"sendToAll","text":"<p>void sendToAll(std::string message)</p> <p>Sends a message to all the clients at once</p> <code>message</code> Message to send"},{"location":"Server/Core/#checkplayerscapabilities","title":"checkPlayersCapabilities","text":"<p>void checkPlayersCapabilities()</p> <p>Checks player positiona and cooldown to prevent cheating or out of bounds</p>"},{"location":"Server/Core/#sendgameupdate","title":"sendGameUpdate","text":"<p>void sendGameUpdate()</p> <p>Sends the player and all element positions.</p>"},{"location":"Server/Core/#checkevent","title":"checkEvent","text":"<p>void checkEvent()</p> <p>Check if the ECSManager has any events this frame and sends them to clients. The events are defined in the .so scripts</p>"},{"location":"Server/PlayerInfo/","title":"PlayerInfo","text":"<p>class PlayerInfo</p> <p>Contains all gameplay information of the player in game</p>"},{"location":"client/","title":"RType Client","text":"<p>Client side part of the RType project. Runs using SFML and connect to the server in order to play.</p>"},{"location":"coverage/","title":"Code Coverage","text":"Name Lines Covered Uncovered Coverage client 115 0 115 0.0% src 115 0 115 0.0% Client 89 0 89 0.0% Core.cpp 89 0 89 0.0% Core.hpp 0 0 0 100.0% PrefabList.hpp 0 0 0 100.0% Network 26 0 26 0.0% Socket.cpp 26 0 26 0.0% Socket.hpp 0 0 0 100.0% ecs 206 0 206 0.0% src 206 0 206 0.0% Component 33 0 33 0.0% ComponentStorage.hpp 9 0 9 0.0% Components.hpp 24 0 24 0.0% Managers 165 0 165 0.0% ComponentManager.cpp 0 0 0 100.0% ComponentManager.hpp 20 0 20 0.0% EntityManager.cpp 11 0 11 0.0% EntityManager.hpp 0 0 0 100.0% Registry.hpp 19 0 19 0.0% SystemManager.cpp 5 0 5 0.0% SystemManager.hpp 3 0 3 0.0% Systems.hpp 107 0 107 0.0% Script 8 0 8 0.0% AScript.hpp 8 0 8 0.0% IScript.hpp 0 0 0 100.0% flint 101 0 101 0.0% src 101 0 101 0.0% Colors 0 0 0 100.0% Colors.cpp 0 0 0 100.0% Colors.hpp 0 0 0 100.0% CxxABI 34 0 34 0.0% CxxABI.cpp 34 0 34 0.0% CxxABI.hpp 0 0 0 100.0% Exceptions 44 0 44 0.0% Exceptions.cpp 43 0 43 0.0% Exceptions.hpp 1 0 1 0.0% Init 6 0 6 0.0% Init.cpp 6 0 6 0.0% Init.hpp 0 0 0 100.0% Logging 9 0 9 0.0% Logging.cpp 8 0 8 0.0% Logging.hpp 1 0 1 0.0% hpp 8 0 8 0.0% Inspection.hpp 8 0 8 0.0% Preprocessor.hpp 0 0 0 100.0% network 101 0 101 0.0% src 101 0 101 0.0% Security 71 0 71 0.0% DecodeError.hpp 3 0 3 0.0% GaloisField.cpp 8 0 8 0.0% GaloisField.hpp 1 0 1 0.0% HammingCodes.cpp 55 0 55 0.0% HammingCodes.hpp 1 0 1 0.0% ReedSolomon.cpp 2 0 2 0.0% ReedSolomon.hpp 1 0 1 0.0% Serialized 3 0 3 0.0% PlayerPosition.cpp 3 0 3 0.0% PlayerPosition.hpp 0 0 0 100.0% Server 27 0 27 0.0% UDP 27 0 27 0.0% UDPServer.cpp 27 0 27 0.0% UDPServer.hpp 0 0 0 100.0% server 175 0 175 0.0% src 175 0 175 0.0% Network 32 0 32 0.0% Socket.cpp 32 0 32 0.0% Socket.hpp 0 0 0 100.0% Server 143 0 143 0.0% Client.cpp 28 0 28 0.0% Client.hpp 0 0 0 100.0% Core.cpp 98 0 98 0.0% Core.hpp 0 0 0 100.0% PlayerInfo.cpp 9 0 9 0.0% PlayerInfo.hpp 0 0 0 100.0% ThreadSafeQueue.hpp 8 0 8 0.0% Summary 89 0 89 0.0% Summary 26 0 26 0.0% Summary 115 0 115 0.0% Summary 115 0 115 0.0% Summary 33 0 33 0.0% Summary 165 0 165 0.0% Summary 8 0 8 0.0% Summary 206 0 206 0.0% Summary 206 0 206 0.0% Summary 0 0 0 100.0% Summary 34 0 34 0.0% Summary 44 0 44 0.0% Summary 6 0 6 0.0% Summary 9 0 9 0.0% Summary 8 0 8 0.0% Summary 101 0 101 0.0% Summary 101 0 101 0.0% Summary 71 0 71 0.0% Summary 3 0 3 0.0% Summary 27 0 27 0.0% Summary 27 0 27 0.0% Summary 101 0 101 0.0% Summary 101 0 101 0.0% Summary 32 0 32 0.0% Summary 143 0 143 0.0% Summary 175 0 175 0.0% Summary 175 0 175 0.0% Summary 698 0 698 0.0%"},{"location":"coverage/client/","title":"client","text":"Name Lines Covered Uncovered Coverage src 115 0 115 0.0% Client 89 0 89 0.0% Core.cpp 89 0 89 0.0% Core.hpp 0 0 0 100.0% PrefabList.hpp 0 0 0 100.0% Network 26 0 26 0.0% Socket.cpp 26 0 26 0.0% Socket.hpp 0 0 0 100.0% Summary 89 0 89 0.0% Summary 26 0 26 0.0% Summary 115 0 115 0.0% Summary 115 0 115 0.0%"},{"location":"coverage/client/src/","title":"src","text":"Name Lines Covered Uncovered Coverage Client 89 0 89 0.0% Core.cpp 89 0 89 0.0% Core.hpp 0 0 0 100.0% PrefabList.hpp 0 0 0 100.0% Network 26 0 26 0.0% Socket.cpp 26 0 26 0.0% Socket.hpp 0 0 0 100.0% Summary 89 0 89 0.0% Summary 26 0 26 0.0% Summary 115 0 115 0.0%"},{"location":"coverage/client/src/Client/","title":"Client","text":"Name Lines Covered Uncovered Coverage Core.cpp 89 0 89 0.0% Core.hpp 0 0 0 100.0% PrefabList.hpp 0 0 0 100.0% Summary 89 0 89 0.0%"},{"location":"coverage/client/src/Client/Core.cpp/","title":"Core.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** EpiGimp\n** File description:\n** main\n*/\n\n#include \"Core.hpp\"\n#include \"ErrorException.hpp\"\n#include &lt;iostream&gt;\n#include &lt;unistd.h&gt;\n\nClient::Core::Core(const std::string&amp; ip, int port)\n    : _ip(ip), _port(port), _clientSocket(-1)\n{\n    this-&gt;_ecsManager = std::make_shared&lt;ECS::ECSManager&gt;(\"RType\", true, true);\n    this-&gt;_win = this-&gt;_ecsManager-&gt;getWindow();\n    this-&gt;_ecsManager-&gt;loadWorld(\"assets/world/test.json\");\n    for (int i = 0; i &lt; 5; i++) {\n        this-&gt;_buttonsPressed.push_back(false);\n    }\n    this-&gt;_previousButtonsPressed = this-&gt;_buttonsPressed;\n\n    this-&gt;_commandControls[0] = \"up\";\n    this-&gt;_commandControls[1] = \"down\";\n    this-&gt;_commandControls[2] = \"left\";\n    this-&gt;_commandControls[3] = \"right\";\n    this-&gt;_commandControls[4] = \"action\";\n\n    this-&gt;_commands[\"start\"] = &amp;Client::Core::startCMD;\n    this-&gt;_commands[\"end\"] = &amp;Client::Core::endCMD;\n    this-&gt;_commands[\"place\"] = &amp;Client::Core::placeCMD;\n    this-&gt;_commands[\"player\"] = &amp;Client::Core::playerCMD;\n    this-&gt;_commands[\"playerDead\"] = &amp;Client::Core::playerDeadCMD;\n    this-&gt;_commands[\"bulletHit\"] = &amp;Client::Core::bulletHitCMD;\n    this-&gt;_commands[\"ennemyDead\"] = &amp;Client::Core::ennemyDeadCMD;\n}\n\nClient::Core::~Core()\n{\n    if (_clientSocket != -1) {\n        close(_clientSocket);\n    }\n}\n\nvoid Client::Core::run()\n{\n    if (!_socket.connectToServer(_ip, _port)) {\n        throw ErrorException(\"Error: Failed to connect to server!\");\n    }\n    _clientSocket = _socket.getSocket();\n    while (this-&gt;_win-&gt;isOpen()) {\n        this-&gt;_win-&gt;clear();\n        this-&gt;handleEvent();\n\n        std::string receivedMessage = _socket.receiveData(_clientSocket);\n        if (!receivedMessage.empty()) {\n            this-&gt;handleServerMessage(receivedMessage);\n        }\n        if (!this-&gt;_gameStarted &amp;&amp; this-&gt;_buttonsPressed[ACTION]) {\n            this-&gt;_socket.sendData(_clientSocket, \"start\");\n        }\n\n        for (int i = 0; i &lt; 5; i++) {\n            if (this-&gt;_buttonsPressed[i] != this-&gt;_previousButtonsPressed[i]) {\n                _socket.sendData(_clientSocket, this-&gt;_commandControls[i] + \" \" + std::to_string(this-&gt;_buttonsPressed[i]));\n            }\n        }\n\n        this-&gt;_ecsManager-&gt;loopServer();\n        this-&gt;_win-&gt;display();\n        this-&gt;hideNonUpdatedElements();\n        this-&gt;_previousButtonsPressed = this-&gt;_buttonsPressed;\n    }\n}\n\nvoid Client::Core::handleEvent()\n{\n    while (this-&gt;_win-&gt;pollEvent(this-&gt;_event))\n    {\n        if (_event.type == sf::Event::Closed) {\n            this-&gt;_win-&gt;close();\n        }\n    }\n    if (this-&gt;_win-&gt;hasFocus()) {\n        this-&gt;_buttonsPressed[UP] = sf::Keyboard::isKeyPressed(sf::Keyboard::Up);\n        this-&gt;_buttonsPressed[DOWN] = sf::Keyboard::isKeyPressed(sf::Keyboard::Down);\n        this-&gt;_buttonsPressed[LEFT] = sf::Keyboard::isKeyPressed(sf::Keyboard::Left);\n        this-&gt;_buttonsPressed[RIGHT] = sf::Keyboard::isKeyPressed(sf::Keyboard::Right);\n        this-&gt;_buttonsPressed[ACTION] = sf::Keyboard::isKeyPressed(sf::Keyboard::Space);\n    }\n}\n\nvoid Client::Core::handleServerMessage(std::string message)\n{\n    ECS::entity_id id;\n    std::regex reg2(\"\\n\");\n    auto begin = std::sregex_token_iterator(message.begin(), message.end(), reg2, -1);\n    auto end = std::sregex_token_iterator();\n    std::vector&lt;std::string&gt; commandList(begin, end);\n    for (auto &amp;currentCommand : commandList) {\n        std::regex reg(\"\\\\ \");\n        begin = std::sregex_token_iterator(currentCommand.begin(), currentCommand.end(), reg, -1);\n        end = std::sregex_token_iterator();\n        std::vector&lt;std::string&gt; command(begin, end);\n        if (this-&gt;_commands.count(command[0]) != 0) {\n            (this-&gt;*_commands[command[0]])(command);\n        }\n    }\n}\n\nvoid Client::Core::createPlayers(int nbrPlayers)\n{\n    int n = 1;\n    while (n &lt;= nbrPlayers) {\n        ECS::entity_id id = this-&gt;_ecsManager-&gt;createEntityFromPrefab(\"player\" + std::to_string(n));\n        this-&gt;_players[n] = id;\n        n++;\n    }\n}\n\nvoid Client::Core::hideNonUpdatedElements()\n{\n    for (auto &amp;e : this-&gt;_placedEntities) {\n        this-&gt;_ecsManager-&gt;destroyEntity(e);\n    }\n    this-&gt;_placedEntities.clear();\n}\n\nvoid Client::Core::startCMD(std::vector&lt;std::string&gt; args)\n{\n    this-&gt;_gameStarted = true;\n    this-&gt;_ecsManager-&gt;loadWorld(\"assets/world/game.json\");\n    this-&gt;createPlayers(std::stoi(args[1]));\n}\n\nvoid Client::Core::endCMD(std::vector&lt;std::string&gt; args)\n{\n    this-&gt;_ecsManager-&gt;loadWorld(\"assets/world/test.json\");\n    this-&gt;_players.clear();\n    this-&gt;_placedEntities.clear();\n    this-&gt;_gameStarted = false;\n}\n\nvoid Client::Core::placeCMD(std::vector&lt;std::string&gt; args)\n{\n    ECS::entity_id id = this-&gt;_ecsManager-&gt;createEntityFromPrefab(args[1]);\n    this-&gt;_ecsManager-&gt;getComponent&lt;ECS::Component::Position&gt;(id)-&gt;x = std::stoi(args[2]);\n    this-&gt;_ecsManager-&gt;getComponent&lt;ECS::Component::Position&gt;(id)-&gt;y = std::stoi(args[3]);\n    this-&gt;_placedEntities.push_back(id);\n}\n\nvoid Client::Core::playerCMD(std::vector&lt;std::string&gt; args)\n{\n    auto pos = this-&gt;_ecsManager-&gt;getComponent&lt;ECS::Component::Position&gt;(this-&gt;_players[std::stoi(args[1])]);\n    pos-&gt;x = std::stoi(args[2]);\n    pos-&gt;y = std::stoi(args[3]);\n}\n\nvoid Client::Core::playerDeadCMD(std::vector&lt;std::string&gt; args)\n{\n    auto pos = this-&gt;_ecsManager-&gt;getComponent&lt;ECS::Component::Position&gt;(this-&gt;_players[std::stoi(args[1])]);\n    ECS::entity_id id = this-&gt;_ecsManager-&gt;createEntityFromPrefab(\"explosion_tm\");\n    this-&gt;_ecsManager-&gt;getComponent&lt;ECS::Component::Position&gt;(id)-&gt;x = pos-&gt;x;\n    this-&gt;_ecsManager-&gt;getComponent&lt;ECS::Component::Position&gt;(id)-&gt;y = pos-&gt;y;\n    this-&gt;_ecsManager-&gt;destroyEntity(this-&gt;_players[std::stoi(args[1])]);\n    this-&gt;_players.erase(std::stoi(args[1]));\n    std::cout &lt;&lt; this-&gt;_players.size() &lt;&lt; std::endl;\n}\n\nvoid Client::Core::bulletHitCMD(std::vector&lt;std::string&gt; args)\n{\n    ECS::entity_id id = this-&gt;_ecsManager-&gt;createEntityFromPrefab(\"explosion\");\n    this-&gt;_ecsManager-&gt;getComponent&lt;ECS::Component::Position&gt;(id)-&gt;x = std::stoi(args[1]);\n    this-&gt;_ecsManager-&gt;getComponent&lt;ECS::Component::Position&gt;(id)-&gt;y = std::stoi(args[2]);\n}\n\nvoid Client::Core::ennemyDeadCMD(std::vector&lt;std::string&gt; args)\n{\n    ECS::entity_id id = this-&gt;_ecsManager-&gt;createEntityFromPrefab(\"explosion_tm\");\n    this-&gt;_ecsManager-&gt;getComponent&lt;ECS::Component::Position&gt;(id)-&gt;x = std::stoi(args[1]);\n    this-&gt;_ecsManager-&gt;getComponent&lt;ECS::Component::Position&gt;(id)-&gt;y = std::stoi(args[2]);\n}\n</code></pre>"},{"location":"coverage/client/src/Client/Core.hpp/","title":"Core.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Server\n** File description:\n** Core\n*/\n\n#ifndef CLIENT_CORE_HPP_\n#define CLIENT_CORE_HPP_\n\n#include \"Network/Socket.hpp\"\n#include \"ECSManager.hpp\"\n#include &lt;memory&gt;\n#include &lt;string&gt;\n\nnamespace Client\n{\n    enum Controls {\n        UP,\n        DOWN,\n        LEFT,\n        RIGHT,\n        ACTION\n    };\n\n    /**\n    * Handles the core loop of the client\n    * Handles the ECSManager and the connection to the server in one thread.\n    */\n    class Core\n    {\n        public:\n            typedef void(Client::Core::*FnPtr)(std::vector&lt;std::string&gt;);\n\n            Core(const std::string&amp; ip, int port);\n            ~Core();\n\n            /**\n            * Run the client's loop\n            */\n            void run();\n\n            /**\n            * Handles the window's event like button press.\n            */\n            void handleEvent();\n\n            /**\n            * Checks the message sent by the server and executes the correct CMD method\n            * @param message Message sent by the server\n            */\n            void handleServerMessage(std::string message);\n\n            /**\n            * Removes all ECS elements that were not updated by the server this frame\n            */\n            void hideNonUpdatedElements();\n\n            /**\n            * Creates X number of player entities in the ECS based on the server's \"start\" command\n            * @param nbrPlayers Number of players this game\n            */\n            void createPlayers(int nbrPlayers);\n\n            /**\n            * Handles the \"start\" command\n            * It switches to the game world in the ECSManager ad spawns the players\n            */\n            void startCMD(std::vector&lt;std::string&gt; args);\n\n            /**\n            * Handles the \"end\" command\n            * It switches back to the title screen and cleans all entities in the game world\n            */\n            void endCMD(std::vector&lt;std::string&gt; args);\n\n            /**\n            * Handles the \"place\" command\n            * Creates entity prefabs and places them in the correct position\n            */\n            void placeCMD(std::vector&lt;std::string&gt; args);\n\n            /**\n            * Handles the \"player\" command\n            * Places the correct player at the x and y positions provided by the server\n            */\n            void playerCMD(std::vector&lt;std::string&gt; args);\n\n            /**\n            * Handles the \"playerDead\" command\n            * It deletes the player game object and spawns an explosion animation\n            */\n            void playerDeadCMD(std::vector&lt;std::string&gt; args);\n\n            /**\n            * Handles the \"bulletHit\" command\n            * spawns an explosion at the impact\n            */\n            void bulletHitCMD(std::vector&lt;std::string&gt; args);\n\n            /**\n            * Handles the \"start\" command\n            * Spawns an explosion at the enemy's position\n            */\n            void ennemyDeadCMD(std::vector&lt;std::string&gt; args);\n\n        private:\n            std::string _ip;\n            int _port;\n            Socket _socket;\n            int _clientSocket;\n\n            std::shared_ptr&lt;ECS::ECSManager&gt; _ecsManager;\n            std::shared_ptr&lt;sf::RenderWindow&gt; _win;\n            sf::Event _event;\n\n            bool _gameStarted = false;\n\n            //checks if the control buttons are pressed (up, down, left, right, action)\n            std::vector&lt;bool&gt; _buttonsPressed;\n\n            //Check if the control buttons were pressed this frame (usefull for checking if buttons is pressed this frame)\n            std::vector&lt;bool&gt; _previousButtonsPressed;\n            std::unordered_map&lt;int, std::string&gt; _commandControls;\n            std::map&lt;std::string, FnPtr&gt; _commands;\n\n            //List of player entities\n            std::unordered_map&lt;int, ECS::entity_id&gt; _players;\n\n            //Contains all entities placed by the \"place\" command this frame.\n            std::vector&lt;ECS::entity_id&gt; _placedEntities;\n\n\n    };\n}\n\n#endif\n</code></pre>"},{"location":"coverage/client/src/Client/PrefabList.hpp/","title":"PrefabList.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Server\n** File description:\n** Core\n*/\n\n\n#ifndef PREFAB_LIST_HPP_\n#define PREFAB_LIST_HPP_\n\n#include &lt;string&gt;\n#include &lt;unistd.h&gt;\n#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n\n#include \"Entity.hpp\"\n\nnamespace Client\n{\n    class PrefabList\n    {\n    public:\n        PrefabList();\n        ~PrefabList();\n\n\n    private:\n        std::unordered_map&lt;int, ECS::entity_id&gt; _ids;\n    };\n}\n\n#endif // SOCKET_HPP_\n</code></pre>"},{"location":"coverage/client/src/Network/","title":"Network","text":"Name Lines Covered Uncovered Coverage Socket.cpp 26 0 26 0.0% Socket.hpp 0 0 0 100.0% Summary 26 0 26 0.0%"},{"location":"coverage/client/src/Network/Socket.cpp/","title":"Socket.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Server\n** File description:\n** Core\n*/\n\n#include \"Socket.hpp\"\n\nSocket::Socket()\n    : _socket(-1)\n{\n}\n\nSocket::~Socket()\n{\n    if (_socket != -1) {\n        close(_socket);\n    }\n}\n\nbool Socket::connectToServer(const std::string&amp; ip, int port)\n{\n    _socket = socket(AF_INET, SOCK_STREAM, 0);\n    if (_socket == -1) {\n        std::cerr &lt;&lt; \"Failed to create socket!\" &lt;&lt; std::endl;\n        return false;\n    }\n    struct sockaddr_in serverAddr;\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_port = htons(port);\n    if (inet_pton(AF_INET, ip.c_str(), &amp;serverAddr.sin_addr) &lt;= 0) {\n        std::cerr &lt;&lt; \"Invalid address!\" &lt;&lt; std::endl;\n        return false;\n    }\n\n    if (connect(_socket, (struct sockaddr*)&amp;serverAddr, sizeof(serverAddr)) &lt; 0) {\n        std::cerr &lt;&lt; \"Connection failed!\" &lt;&lt; std::endl;\n        return false;\n    }\n    int flags = fcntl(_socket, F_GETFL, 0);  // Get current socket flags\n    fcntl(_socket, F_SETFL, flags | O_NONBLOCK);\n\n    return true;\n}\n\nbool Socket::sendData(int socket, const std::string&amp; data)\n{\n    std::string dataSent = data + \"\\n\";\n    int bytesSent = send(socket, dataSent.c_str(), dataSent.length(), 0);\n    return (bytesSent == static_cast&lt;int&gt;(data.length()));\n}\n\nstd::string Socket::receiveData(int socket)\n{\n    char buffer[1024];  // Buffer to store received data\n    int bytesReceived = recv(socket, buffer, sizeof(buffer), 0);  // Receive data\n\n    // If data is received, convert it to a string and return\n    if (bytesReceived &gt; 0) {\n        return std::string(buffer, bytesReceived);  // Return message as a string\n    }\n\n    // If no data received or socket is closed, return an empty string\n    return \"\";\n}\n\nint Socket::getSocket() const\n{\n    return _socket;\n}\n</code></pre>"},{"location":"coverage/client/src/Network/Socket.hpp/","title":"Socket.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Server\n** File description:\n** Core\n*/\n\n\n#ifndef SOCKET_HPP_\n#define SOCKET_HPP_\n\n#include &lt;string&gt;\n#include &lt;sys/socket.h&gt;\n#include &lt;arpa/inet.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;iostream&gt;\n#include &lt;fcntl.h&gt;\n\n/**\n* Simple encapsulation of unistd socket\n* It assures proper connection to the client and handles the data exchange.\n*/\nclass Socket\n{\npublic:\n    Socket();\n    ~Socket();\n\n    bool connectToServer(const std::string&amp; ip, int port);\n    bool sendData(int socket, const std::string&amp; data);\n    std::string receiveData(int socket);\n    int getSocket() const;\n\nprivate:\n    int _socket;\n};\n\n#endif // SOCKET_HPP_\n</code></pre>"},{"location":"coverage/ecs/","title":"ecs","text":"Name Lines Covered Uncovered Coverage src 206 0 206 0.0% Component 33 0 33 0.0% ComponentStorage.hpp 9 0 9 0.0% Components.hpp 24 0 24 0.0% Managers 165 0 165 0.0% ComponentManager.cpp 0 0 0 100.0% ComponentManager.hpp 20 0 20 0.0% EntityManager.cpp 11 0 11 0.0% EntityManager.hpp 0 0 0 100.0% Registry.hpp 19 0 19 0.0% SystemManager.cpp 5 0 5 0.0% SystemManager.hpp 3 0 3 0.0% Systems.hpp 107 0 107 0.0% Script 8 0 8 0.0% AScript.hpp 8 0 8 0.0% IScript.hpp 0 0 0 100.0% Summary 33 0 33 0.0% Summary 165 0 165 0.0% Summary 8 0 8 0.0% Summary 206 0 206 0.0% Summary 206 0 206 0.0%"},{"location":"coverage/ecs/src/","title":"src","text":"Name Lines Covered Uncovered Coverage Component 33 0 33 0.0% ComponentStorage.hpp 9 0 9 0.0% Components.hpp 24 0 24 0.0% Managers 165 0 165 0.0% ComponentManager.cpp 0 0 0 100.0% ComponentManager.hpp 20 0 20 0.0% EntityManager.cpp 11 0 11 0.0% EntityManager.hpp 0 0 0 100.0% Registry.hpp 19 0 19 0.0% SystemManager.cpp 5 0 5 0.0% SystemManager.hpp 3 0 3 0.0% Systems.hpp 107 0 107 0.0% Script 8 0 8 0.0% AScript.hpp 8 0 8 0.0% IScript.hpp 0 0 0 100.0% Summary 33 0 33 0.0% Summary 165 0 165 0.0% Summary 8 0 8 0.0% Summary 206 0 206 0.0%"},{"location":"coverage/ecs/src/Component/","title":"Component","text":"Name Lines Covered Uncovered Coverage ComponentStorage.hpp 9 0 9 0.0% Components.hpp 24 0 24 0.0% Summary 33 0 33 0.0%"},{"location":"coverage/ecs/src/Component/ComponentStorage.hpp/","title":"ComponentStorage.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** RType\n** File description:\n** EntityManager Class\n*/\n\n#ifndef COMPONENTSTORAGE_HPP_\n    #define COMPONENTSTORAGE_HPP_\n\n    #include \"../Entity.hpp\"\n\n    /**\n    * ComponentStorage Interface\n    *\n    */\n    class ComponentStorageBase {\n        public:\n            virtual ~ComponentStorageBase() = default;\n            virtual void remove(ECS::entity_id id) = 0;\n        };\n\n    /**\n    * Stores all of the components of a same type wrapped in a std::shared_ptr\n    *\n    * @tparam Component Struct of the component.\n    */\n    template &lt;typename Component&gt;\n    class ComponentStorage : public ComponentStorageBase {\n    public:\n        std::vector&lt;std::shared_ptr&lt;Component&gt;&gt; storage;\n\n        void resize(size_t entity_count) {\n            if (entity_count &gt;= storage.size()) {\n                storage.resize(entity_count + 1);\n            }\n        }\n\n        /**\n        * Get component wrapped in a std::optional\n        *\n        * @param id Entity ID.\n        */\n        std::optional&lt;std::shared_ptr&lt;Component&gt;&gt; get(ECS::entity_id id) {\n            if (id &gt;= storage.size()) {\n                return std::nullopt;\n            }\n            return storage[id];\n        }\n\n        /**\n        * Add a component for an entity\n        *\n        * @param id Entity ID.\n        */\n        void add(ECS::entity_id id, std::shared_ptr&lt;Component&gt; component) {\n            resize(id);\n            storage[id] = std::move(component);\n        }\n\n        /**\n        * Remove component from an entity\n        *\n        * @param id Entity ID.\n        */\n        void remove(ECS::entity_id id) {\n            if (id &lt; storage.size()) {\n                storage[id] = nullptr;\n            }\n        }\n    };\n\n#endif\n</code></pre>"},{"location":"coverage/ecs/src/Component/Components.hpp/","title":"Components.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** RType\n** File description:\n** ECS Components\n*/\n\n#ifndef COMPONENTS_HPP_\n    #define COMPONENTS_HPP_\n\n    #include &lt;iostream&gt;\n\n    #include \"../GUI_SFML_Graphics.hpp\"\n    #include \"../Script/IScript.hpp\"\n\n    namespace ECS::Component\n    {\n        /**\n        * Position inside world space\n        *\n        * @param x X position.\n        * @param y Y position.\n        */\n        struct Position {\n            float x, y = 0;\n\n            bool operator==(const Position &amp;other) const\n            {\n                return x == other.x &amp;&amp; y == other.y;\n            }\n\n            friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Position&amp; p) {\n                os &lt;&lt; \"Position(x: \" &lt;&lt; p.x &lt;&lt; \", y: \" &lt;&lt; p.y &lt;&lt; \")\";\n                return os;\n            }\n        };\n\n        /**\n        * Velocity of entity\n        *\n        * @param x X speed.\n        * @param y Y speed.\n        */\n        struct Velocity {\n            int x, y = 0;\n\n            bool operator==(const Position &amp;other) const\n            {\n                return x == other.x &amp;&amp; y == other.y;\n            }\n\n            friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Velocity&amp; p) {\n                os &lt;&lt; \"Velocity(x: \" &lt;&lt; p.x &lt;&lt; \", y: \" &lt;&lt; p.y &lt;&lt; \")\";\n                return os;\n            }\n        };\n\n        /**\n        * Acceleration of entity\n        *\n        * @param x X acceleration.\n        * @param y Y acceleration.\n        * \n        * @warning THIS COMPONENT IS NOT IMPLEMENTED\n        */\n        struct Acceleration {\n            float x, y = 0;\n\n            bool operator==(const Acceleration &amp;other) const\n            {\n                return x == other.x &amp;&amp; y == other.y;\n            }\n        };\n\n        /**\n        * Rectangle box for collisions/zone/etc...\n        *\n        * @param x X outset.\n        * @param y Y outset.\n        * @param w width.\n        * @param h height.\n        */\n        struct Hitbox {\n            float x, y, w, h = 0;\n\n            friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Hitbox&amp; p) {\n                os &lt;&lt; \"Hitbox(x: \" &lt;&lt; p.x &lt;&lt; \", y: \" &lt;&lt; p.y &lt;&lt; \", w: \" &lt;&lt; p.w &lt;&lt; \", h: \" &lt;&lt; p.h &lt;&lt; \")\";\n                return os;\n            }\n        };\n\n        /**\n        * State value usable for StateMachine or simply indicating a state\n        *\n        * @param name State name.\n        */\n        struct State {\n            std::string value = \"\";\n\n            friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const State&amp; p) {\n                os &lt;&lt; \"State(\" &lt;&lt; p.value &lt;&lt; \")\";\n                return os;\n            }\n\n        };\n\n        /**\n        * Tag value usable for entity labeling/categorisation\n        * Usefull for entity differentiation when colliding for example\n        *\n        * @param name State name.\n        */\n        struct Tag {\n            std::string value = \"\";\n\n            friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Tag&amp; p) {\n                os &lt;&lt; \"State(\" &lt;&lt; p.value &lt;&lt; \")\";\n                return os;\n            }\n\n        };\n\n        /**\n        * Scripting on entity\n        *\n        * @param name Script name.\n        */\n        struct Script {\n            std::shared_ptr&lt;ECS::IScript&gt; content = nullptr;\n            bool hasStarted = false;\n\n            // Script( std::unique_ptr&lt;ECS::IScript&gt; c){\n            //     content = std::move(c);\n            // }\n\n            friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Script&amp; p) {\n                os &lt;&lt; \"Script()\";\n                return os;\n            }\n        };\n\n        /**\n        * Visual for entity\n        *\n        * @param sprite Sprite.\n        * @param center If true, the sprite will be centered based on it's position\n        */\n        struct Drawable {\n            sf::Sprite sprite;\n            bool center = false;\n\n            friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Drawable&amp; p) {\n                os &lt;&lt; \"Sprite()\";\n                return os;\n            }\n        };\n\n\n        /**\n        * Animation rect of entity\n        *\n        * @param rect Frame for sprite.\n        * @param fps Frame per second.\n        * @param destroyAtEnt If true, the entity will automatically be destroyed at the end of the animation, perfect for particles\n        */\n        struct Animation {\n            sf::IntRect rect;\n            int fps;\n            int currentFps = 0;\n            bool animating = false;\n            bool destroyAtEnd = false;\n\n            friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Animation&amp; p) {\n                os &lt;&lt; \"Animation()\";\n                return os;\n            }\n        };\n\n        /**\n        * Spritesheet info for selecting Sprite part on One line\n        *\n        * @param nbrOfState nbr of different states avaliable.\n        * @param state state selected.\n        * \n        * @warning THIS COMPONENT IS NOT IMPLEMENTED OR FUNCTIONAL\n        */\n        struct SpriteSheet {\n            int nbrOfState;\n            int state;\n\n            friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const SpriteSheet&amp; p) {\n                os &lt;&lt; \"SpriteSheet()\";\n                return os;\n            }\n        };\n\n\n        /**\n        * Parallax movement for entity\n        *\n        * @param speed Speed of parallax, goes backwards if negative value.\n        *\n        * @warning Float values can sometimes not work, for onsistency, only use int values\n        */\n        struct Parallax {\n            float speed = 0.5f;\n\n            bool operator==(const Parallax&amp; other) const {\n                return speed == other.speed;\n            }\n\n            friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Parallax&amp; p) {\n                os &lt;&lt; \"Parallax(speed: \" &lt;&lt; p.speed &lt;&lt; \")\";\n                return os;\n            }\n        };\n\n        /**\n        * Used for debugging local inputs\n        *\n        * @param up, down, left, right, action Action value.\n        *\n        */\n        struct PlayerInput {\n            bool up, down, left, right, action = false;\n        };\n\n        /**\n        * Health information for component\n        *\n        * @param health Health value\n        *\n        */\n        struct Health {\n            int health = 1;\n        };\n\n    }\n\n#endif\n</code></pre>"},{"location":"coverage/ecs/src/Managers/","title":"Managers","text":"Name Lines Covered Uncovered Coverage ComponentManager.cpp 0 0 0 100.0% ComponentManager.hpp 20 0 20 0.0% EntityManager.cpp 11 0 11 0.0% EntityManager.hpp 0 0 0 100.0% Registry.hpp 19 0 19 0.0% SystemManager.cpp 5 0 5 0.0% SystemManager.hpp 3 0 3 0.0% Systems.hpp 107 0 107 0.0% Summary 165 0 165 0.0%"},{"location":"coverage/ecs/src/Managers/ComponentManager.cpp/","title":"ComponentManager.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** ComponentManager\n** File description:\n** Component Manager\n*/\n\n#include \"ComponentManager.hpp\"\n\nECS::ComponentManager::ComponentManager()\n{\n\n}\n</code></pre>"},{"location":"coverage/ecs/src/Managers/ComponentManager.hpp/","title":"ComponentManager.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** RType\n** File description:\n** EntityManager Class\n*/\n\n#ifndef COMPONENT_MANAGER_HPP_\n    #define COMPONENT_MANAGER_HPP_\n\n    #include &lt;typeindex&gt;\n    #include &lt;any&gt;\n    #include &lt;iostream&gt;\n    #include &lt;optional&gt;\n    #include &lt;memory&gt;\n    #include &lt;queue&gt;\n    #include &lt;map&gt;\n    #include &lt;unordered_map&gt;\n\n    #include \"Entity.hpp\"\n    #include \"Component/Components.hpp\"\n    #include \"Component/ComponentStorage.hpp\"\n\n    namespace ECS\n    {\n        /**\n        * Stores and Manages all of the components of all entities currently existing\n        * The template \"Component\" corresponds to all of the structs avaliable in Components.hpp\n        *\n        */\n        class ComponentManager {\n\n            public:\n                ComponentManager();\n\n                /**\n                * Add a component to an entity in the current world\n                * @param id Entity ID\n                * @tparam Component Component's struct which's values are setup or not\n                *\n                */\n                template &lt;typename Component&gt;\n                void addComponent(ECS::entity_id id, Component component) {\n                    std::type_index index = typeid(Component);\n                    if (this-&gt;_components.find(index) == this-&gt;_components.end()) {\n                        this-&gt;registerComponentStorage&lt;Component&gt;();\n                    }\n                    auto&amp; storage = getComponentStorage&lt;Component&gt;();\n                    storage.add(id, std::move(std::make_shared&lt;Component&gt;(component)));\n                    this-&gt;_entityWithComponent[index].push_back(id);\n                }\n\n                /**\n                * Remove a component from an entity in the current world\n                * @param id Entity ID\n                * @tparam Component Component's struct\n                *\n                * @warning It should be called like this: removeComponent&lt;ComponentStructType&gt;(id)\n                *\n                */\n                template &lt;typename Component&gt;\n                void removeComponent(ECS::entity_id id) {\n                    std::type_index index = typeid(Component);\n                    auto&amp; storage = getComponentStorage&lt;Component&gt;();\n                    storage.remove(id);\n                    this-&gt;_entityWithComponent[index].erase(std::remove(this-&gt;_entityWithComponent[index].begin(), this-&gt;_entityWithComponent[index].end(), id), this-&gt;_entityWithComponent[index].end());\n                }\n\n                /**\n                * Remove all of the components from an entity\n                * @param id Entity ID\n                *\n                */\n                void removeAllComponents(ECS::entity_id id)\n                {\n                    for (auto &amp;e : this-&gt;_components) {\n                        this-&gt;_components[e.first]-&gt;remove(id);\n                        this-&gt;_entityWithComponent[e.first].erase(std::remove(this-&gt;_entityWithComponent[e.first].begin(), this-&gt;_entityWithComponent[e.first].end(), id), this-&gt;_entityWithComponent[e.first].end());\n                    }\n                }\n\n                /**\n                * Get a component from an entity in the current world, you can then modify the shared_ptr component\n                * to directly modify it's information inside the entity, no need to re-add it\n                * @param id Entity ID\n                * @tparam Component Component's struct\n                * \n                * @warning It should be called like this: getComponent&lt;ComponentStructType&gt;(id)\n                * \n                * @return Entity's component wrapped in a shared_ptr\n                *\n                */\n                template &lt;typename Component&gt;\n                std::optional&lt;std::shared_ptr&lt;Component&gt;&gt; getComponent(ECS::entity_id id) {\n                    return getComponentStorage&lt;Component&gt;().get(id);\n                }\n\n                template &lt;typename Component&gt;\n                std::shared_ptr&lt;ComponentStorage&lt;Component&gt;&gt; getComponents() {\n                    return getComponentStorage&lt;Component&gt;();\n                }\n\n                /**\n                * Returns a list of all the entities that have a component type, usefull when you create a System\n                * or want to know only certain entities to increase performance\n                * @tparam Component Component's struct\n                * \n                * @warning It should be called like this: getEntitiesWithComponent&lt;ComponentStructType&gt;()\n                *\n                */\n                template &lt;typename Component&gt;\n                std::vector&lt;ECS::entity_id&gt; getEntitiesWithComponent()\n                {\n                    return _entityWithComponent[typeid(Component)];\n                }\n\n                /**\n                * Returns the component storage of a component type\n                * @tparam Component Component's struct\n                * \n                * @warning It should be called like this: getComponentStorage&lt;ComponentStructType&gt;(id)\n                * \n                * @return Entity's component Storage\n                *\n                */\n                template &lt;typename Component&gt;\n                ComponentStorage&lt;Component&gt;&amp; getComponentStorage() {\n                    if (_components.count(typeid(Component)) == 0) {\n                        this-&gt;registerComponentStorage&lt;Component&gt;();\n                    }\n                    return *static_cast&lt;ComponentStorage&lt;Component&gt;*&gt;(_components[typeid(Component)].get());\n                }\n\n                template &lt;typename Component&gt;\n                void registerComponentStorage() {\n                    _components[typeid(Component)] = std::make_shared&lt;ComponentStorage&lt;Component&gt;&gt;();\n                }\n\n            private:\n                std::unordered_map&lt;std::type_index, std::vector&lt;ECS::entity_id&gt;&gt; _entityWithComponent;\n                std::unordered_map&lt;std::type_index, std::shared_ptr&lt;ComponentStorageBase&gt;&gt; _components;\n        };\n    }\n\n#endif\n</code></pre>"},{"location":"coverage/ecs/src/Managers/EntityManager.cpp/","title":"EntityManager.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** EpiGimp\n** File description:\n** main\n*/\n\n#include &lt;iostream&gt;\n#include \"EntityManager.hpp\"\n\nECS::EntityManager::EntityManager()\n{\n    for (ECS::entity_id id = 0; id &lt; ECS_MAX_ENTITY; id++) {\n        this-&gt;_emptyIDs.push(id);\n    }\n}\n\nconst ECS::entity_id &amp;ECS::EntityManager::createEntity()\n{\n    const ECS::entity_id &amp;newID = this-&gt;_emptyIDs.front();\n    this-&gt;_emptyIDs.pop();\n\n    ECS::Entity newEntity(newID);\n    this-&gt;_entities[newID] = newEntity;\n    return newID;\n}\n\nvoid ECS::EntityManager::destroyEntity(const ECS::entity_id &amp;id)\n{\n    this-&gt;_emptyIDs.push(id);\n    this-&gt;_entities[id].reset();\n\n}\n\nstd::vector&lt;ECS::entity_id&gt; ECS::EntityManager::getAllEntities()\n{\n    std::vector&lt;ECS::entity_id&gt; list;\n    for (auto &amp;e : this-&gt;_entities) {\n        list.push_back(e.first);\n    }\n\n    return list;\n}\n</code></pre>"},{"location":"coverage/ecs/src/Managers/EntityManager.hpp/","title":"EntityManager.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** RType\n** File description:\n** EntityManager Class\n*/\n\n#ifndef ENTITY_MANAGER_HPP_\n    #define ENTITY_MANAGER_HPP_\n\n    #include &lt;memory&gt;\n    #include &lt;queue&gt;\n    #include &lt;map&gt;\n    #include &lt;unordered_map&gt;\n\n    #include \"Entity.hpp\"\n\n    namespace ECS\n    {\n        /**\n        * Responsible for creating, deleting and getting all entities\n        *\n        */\n        class EntityManager {\n\n            public:\n                EntityManager();\n\n                /**\n                * Create an empty entity in the current world\n                *\n                * @return Created entity ID\n                */\n                const entity_id &amp;createEntity();\n\n                /**\n                * Destroy an entity in the current world\n                * @param id ID of the entity to destroy\n                *\n                */\n                void destroyEntity(const entity_id &amp;id);\n\n                /**\n                * Returns all of the entities in the registry\n                *\n                * @return List of all entities\n                */\n                std::vector&lt;ECS::entity_id&gt; getAllEntities();\n\n            private:\n                std::queue&lt;ECS::entity_id&gt; _emptyIDs;\n                std::unordered_map&lt;ECS::entity_id, std::optional&lt;ECS::Entity&gt;&gt; _entities;\n                std::vector&lt;ECS::entity_id&gt; _usedIDs;\n\n        };\n\n    }\n\n#endif\n\n#define ECS_MAX_ENTITY 32000\n</code></pre>"},{"location":"coverage/ecs/src/Managers/Registry.hpp/","title":"Registry.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** RType\n** File description:\n** EntityManager Class\n*/\n\n#ifndef REGISTRY_HPP_\n    #define REGISTRY_HPP_\n\n    #include &lt;memory&gt;\n\n    #include \"EntityManager.hpp\"\n    #include \"ComponentManager.hpp\"\n\n    namespace ECS\n    {\n        /**\n        * Mediator that wraps Component and Entity manager, this should be where you\n        * manipulate a world's content. It also contains all the entities of the world.\n        *\n        */\n        class Registry {\n\n            public:\n                Registry()\n                {\n                    this-&gt;_entityManager = std::make_unique&lt;ECS::EntityManager&gt;();\n                    this-&gt;_componentManager = std::make_unique&lt;ECS::ComponentManager&gt;();\n                }\n\n                ~Registry()\n                {\n                    std::vector&lt;ECS::entity_id&gt; allEntities = this-&gt;_entityManager-&gt;getAllEntities();\n                    for (auto &amp;e : allEntities) {\n                        this-&gt;removeAllComponents(e);\n                        this-&gt;destroyEntity(e);\n                    }\n                }\n\n                const ECS::entity_id &amp;createEntity()\n                {\n                    return this-&gt;_entityManager-&gt;createEntity();\n                }\n\n                void destroyEntity(const entity_id &amp;id)\n                {\n                    this-&gt;_entityManager-&gt;destroyEntity(id);\n                    this-&gt;removeAllComponents(id);\n                }\n\n                std::vector&lt;ECS::entity_id&gt; getAllEntities()\n                {\n                    return this-&gt;_entityManager-&gt;getAllEntities();\n                }\n\n                template &lt;typename Component&gt;\n                void addComponent(ECS::entity_id id, Component comp)\n                {\n                    this-&gt;_componentManager-&gt;addComponent(id, comp);\n                }\n\n                template &lt;typename Component&gt;\n                void removeComponent(ECS::entity_id id)\n                {\n                    this-&gt;_componentManager-&gt;removeComponent&lt;Component&gt;(id);\n                }\n\n                void removeAllComponents(ECS::entity_id id)\n                {\n                    this-&gt;_componentManager-&gt;removeAllComponents(id);\n                }\n\n                template &lt;typename Component&gt;\n                std::shared_ptr&lt;Component&gt; getComponent(ECS::entity_id id)\n                {\n                    std::optional&lt;std::shared_ptr&lt;Component&gt;&gt; comp = this-&gt;_componentManager-&gt;getComponent&lt;Component&gt;(id);\n                    if (comp == std::nullopt) {\n                        return nullptr;\n                    }\n                    return comp.value();\n                }\n\n                template &lt;typename Component&gt;\n                std::vector&lt;ECS::entity_id&gt; getEntitiesWithComponent()\n                {\n                    return this-&gt;_componentManager-&gt;getEntitiesWithComponent&lt;Component&gt;();\n                }\n\n                template &lt;typename Component&gt;\n                ComponentStorage&lt;Component&gt; getComponents() {\n                    // auto&amp; storage = getComponentStorage&lt;Component&gt;();\n                    return this-&gt;_componentManager-&gt;getComponentStorage&lt;Component&gt;();\n                }\n\n\n            private:\n                std::unique_ptr&lt;ECS::ComponentManager&gt; _componentManager;\n                std::unique_ptr&lt;ECS::EntityManager&gt; _entityManager;\n\n        };\n    }\n\n#endif\n</code></pre>"},{"location":"coverage/ecs/src/Managers/SystemManager.cpp/","title":"SystemManager.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** SystemManager\n** File description:\n** System Manager\n*/\n\n#include \"SystemManager.hpp\"\n\nECS::SystemManager::SystemManager()\n{\n\n}\n\nECS::SystemManager::~SystemManager()\n{\n\n}\n\nvoid ECS::SystemManager::runAllSystems(ECS::Registry &amp;R)\n{\n    this-&gt;_dt = this-&gt;_clock.getElapsedTime().asSeconds();\n\n    for (auto &amp;system : this-&gt;_systems) {\n        system(R, _dt);\n    }\n    this-&gt;_clock.restart();\n}\n\ndouble ECS::SystemManager::getDeltaTime()\n{\n    return this-&gt;_dt;\n}\n</code></pre>"},{"location":"coverage/ecs/src/Managers/SystemManager.hpp/","title":"SystemManager.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** RType\n** File description:\n** SystemManager Class\n*/\n\n#ifndef SYSTEM_MANAGER_HPP_\n    #define SYSTEM_MANAGER_HPP_\n\n    #include &lt;memory&gt;\n    #include &lt;functional&gt;\n    #include &lt;chrono&gt;\n    #include &lt;cmath&gt;\n\n    #include \"Systems.hpp\"\n    #include \"Registry.hpp\"\n\n    namespace ECS\n    {\n        /**\n        * Responsible for running and adding systems that are active during the execution\n        * It also keeps track of the deltaTime between frames\n        *\n        */\n        class SystemManager {\n\n            public:\n                SystemManager();\n                ~SystemManager();\n\n                template &lt;typename System, typename... Args&gt;\n                void addSystem(Args&amp;&amp;... args)\n                {\n                    // Capture the arguments by reference to respect const correctness\n                    this-&gt;_systems.push_back([&amp;args...](ECS::Registry&amp; R, double dt) {\n                        // Forward the arguments to the system constructor\n                        System system(std::forward&lt;Args&gt;(args)...);\n                        system(R, dt);  // Call operator() on the system\n                    });\n                }\n\n                void runAllSystems(ECS::Registry &amp;R);\n                double getDeltaTime();\n\n\n            private:\n                std::vector&lt;std::function&lt;void(ECS::Registry&amp;, double dt)&gt;&gt; _systems;\n                // std::chrono::steady_clock::time_point _lastTime;\n                sf::Clock _clock;\n                double _dt = 0;\n\n        };\n    }\n\n#endif\n</code></pre>"},{"location":"coverage/ecs/src/Managers/Systems.hpp/","title":"Systems.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** RType\n** File description:\n** ECS Components\n*/\n\n#ifndef SYSTEMS_HPP_\n    #define SYSTEMS_HPP_\n\n    #include &lt;iostream&gt;\n    #include \"GUI_SFML_Graphics.hpp\"\n\n    #include \"Registry.hpp\"\n\n    namespace ECS::System\n    {\n\n        /**\n        * Manages all the entities movement by adding their velocity to their position.\n        *\n        */\n        struct Movement {\n\n            void operator()(ECS::Registry &amp;R, double dt)\n            {\n                std::vector&lt;ECS::entity_id&gt; allEntities = R.getEntitiesWithComponent&lt;ECS::Component::Velocity&gt;();\n                for (auto &amp;entity : allEntities) {\n                    auto pos = R.getComponent&lt;ECS::Component::Position&gt;(entity);\n                    auto vel = R.getComponent&lt;ECS::Component::Velocity&gt;(entity);\n                    if (vel != nullptr) {\n                        pos-&gt;x += (vel-&gt;x * dt);\n                        pos-&gt;y += (vel-&gt;y * dt);\n                    }\n                }\n            }\n        };\n\n        /**\n        * Manages the collisions between entities and execute their's scripts \"onCollision()\" method if they do\n        *\n        */\n        struct Collision {\n\n            bool checkCollision(const ECS::Component::Hitbox &amp;a, const ECS::Component::Hitbox &amp;b) {\n                return !(a.x + a.w &lt; b.x || a.x &gt; b.x + b.w || a.y + a.h &lt; b.y || a.y &gt; b.y + b.h);\n            }\n\n            void operator()(ECS::Registry &amp;R, double dt)\n            {\n                std::vector&lt;ECS::entity_id&gt; allEntities = R.getEntitiesWithComponent&lt;ECS::Component::Hitbox&gt;();\n                ECS::Component::Hitbox a;\n                ECS::Component::Hitbox b;\n\n                for (size_t i = 0; i &lt; allEntities.size(); ++i) {\n                    auto &amp;entity = allEntities[i];\n                    auto aHitbox = R.getComponent&lt;ECS::Component::Hitbox&gt;(entity);\n                    auto aPos = R.getComponent&lt;ECS::Component::Position&gt;(entity);\n\n                    if (aPos == nullptr) {\n                        continue;\n                    }\n\n                    a = *aHitbox;\n                    a.x += aPos-&gt;x;\n                    a.y += aPos-&gt;y;\n\n                    // Only check entities that come after the current one to avoid double-checking pairs\n                    for (size_t j = i + 1; j &lt; allEntities.size(); ++j) {\n                        auto &amp;otherEntity = allEntities[j];\n                        auto bHitbox = R.getComponent&lt;ECS::Component::Hitbox&gt;(otherEntity);\n                        auto bPos = R.getComponent&lt;ECS::Component::Position&gt;(otherEntity);\n\n                        if (bPos == nullptr) {\n                            continue;\n                        }\n\n                        b = *bHitbox;\n                        b.x += bPos-&gt;x;\n                        b.y += bPos-&gt;y;\n\n                        if (checkCollision(a, b)) {\n                            auto script_one = R.getComponent&lt;ECS::Component::Script&gt;(entity);\n                            auto script_two = R.getComponent&lt;ECS::Component::Script&gt;(otherEntity);\n                            if (script_one != nullptr) {\n                                script_one-&gt;content-&gt;onCollision(otherEntity);\n                            }\n                            if (script_two != nullptr) {\n                                script_two-&gt;content-&gt;onCollision(entity);\n                            }\n                        }\n                    }\n                }\n            }\n        };\n\n        /**\n        * Executes all active script's \"onUpdate()\" and \"onStart()\" methods.\n        *\n        */\n        struct ScriptUpdate {\n\n            void operator()(ECS::Registry &amp;R, double dt) {\n                std::vector&lt;ECS::entity_id&gt; allEntities = R.getEntitiesWithComponent&lt;ECS::Component::Script&gt;();\n\n                for (auto &amp;entity : allEntities) {\n                    auto s = R.getComponent&lt;ECS::Component::Script&gt;(entity);\n\n                    if (s != nullptr) {\n                        if (!s-&gt;hasStarted) {\n                            s-&gt;content-&gt;onStart();\n                            s-&gt;hasStarted = true;\n                        }\n                        s-&gt;content-&gt;onUpdate();\n                    }\n                }\n            }\n        };\n\n        /**\n        * Executes the entity's \"onClick()\" method when the mouse clicks on it.\n        *\n        * @param _win the engine's window.\n        * @param mousePos Mouse position value, it is modified each frame.\n        */\n        struct ScriptOnClick {\n\n            std::shared_ptr&lt;sf::RenderWindow&gt; _win;\n            sf::Vector2i mousePos;\n\n            bool checkCollision(std::shared_ptr&lt;ECS::Component::Hitbox&gt; rect, float pointX, float pointY) {\n                return !(pointX &lt; rect-&gt;x || pointX &gt; rect-&gt;x + rect-&gt;w || pointY &lt; rect-&gt;y || pointY &gt; rect-&gt;y + rect-&gt;h);\n            }\n\n            ScriptOnClick( std::shared_ptr&lt;sf::RenderWindow&gt;&amp; winPtr) : _win(winPtr) {}\n\n            void operator()(ECS::Registry &amp;R, double dt) {\n                std::vector&lt;ECS::entity_id&gt; allEntities = R.getEntitiesWithComponent&lt;ECS::Component::Script&gt;();\n\n                mousePos = sf::Mouse::getPosition(*_win);\n\n                for (auto &amp;entity : allEntities) {\n                    auto s = R.getComponent&lt;ECS::Component::Script&gt;(entity);\n                    auto h = R.getComponent&lt;ECS::Component::Hitbox&gt;(entity);\n\n                    if (s != nullptr &amp;&amp; h != nullptr) {\n                        if (checkCollision(h, sf::Mouse::getPosition().x, sf::Mouse::getPosition().y)\n                            &amp;&amp; sf::Mouse::isButtonPressed(sf::Mouse::Left)) {\n                            s-&gt;content-&gt;onClick();\n                        }\n                    }\n                }\n            }\n        };\n\n        /**\n        * Render's all active Drawable components on the window\n        *\n        * @param _win the engine's window.\n        */\n        struct Draw {\n\n            std::shared_ptr&lt;sf::RenderWindow&gt; _win;\n\n            Draw( std::shared_ptr&lt;sf::RenderWindow&gt;&amp; winPtr) : _win(winPtr) {}\n\n            void operator()(ECS::Registry &amp;R, double dt)\n            {\n                std::vector&lt;ECS::entity_id&gt; allEntities = R.getEntitiesWithComponent&lt;ECS::Component::Drawable&gt;();\n                for (auto &amp;entity : allEntities) {\n                    auto pos = R.getComponent&lt;ECS::Component::Position&gt;(entity);\n                    auto drawable = R.getComponent&lt;ECS::Component::Drawable&gt;(entity);\n                    if (pos != nullptr) {\n                        if (drawable-&gt;center) {\n                            sf::Vector2f origin((float)drawable-&gt;sprite.getTextureRect().width / 2, (float)drawable-&gt;sprite.getTextureRect().height / 2);\n                            drawable-&gt;sprite.setOrigin(origin);\n                        }\n                        drawable-&gt;sprite.setPosition(pos-&gt;x, pos-&gt;y);\n                        _win-&gt;draw(drawable-&gt;sprite);\n                    }\n                }\n            }\n        };\n\n\n        /**\n        * Manages the entities's animation component and apply it to their drawable\n        *\n        */\n        struct Animate {\n\n            void operator()(ECS::Registry &amp;R, double dt)\n            {\n                std::vector&lt;ECS::entity_id&gt; allEntities = R.getEntitiesWithComponent&lt;ECS::Component::Animation&gt;();\n                sf::Vector2u size;\n                for (auto &amp;entity : allEntities) {\n                    auto anim = R.getComponent&lt;ECS::Component::Animation&gt;(entity);\n                    auto drawable = R.getComponent&lt;ECS::Component::Drawable&gt;(entity);\n                    if (drawable != nullptr) {\n                        anim-&gt;currentFps++;\n                        if (!anim-&gt;animating) {\n                            anim-&gt;animating = true;\n                            drawable-&gt;sprite.setTextureRect(anim-&gt;rect);\n                            sf::Vector2f origin((float)anim-&gt;rect.width / 2, (float)anim-&gt;rect.height / 2);\n                            drawable-&gt;sprite.setOrigin(origin);\n                            continue;\n                        }\n                        if (anim-&gt;currentFps &lt; anim-&gt;fps) {\n                            continue;\n                        }\n                        anim-&gt;currentFps = 0;\n                        size = drawable-&gt;sprite.getTexture()-&gt;getSize();\n                        anim-&gt;rect.left += anim-&gt;rect.width;\n                        if (anim-&gt;rect.left &gt;= size.x) {\n                            if (anim-&gt;destroyAtEnd) {\n                                R.destroyEntity(entity);\n                                continue;\n                            }\n                            anim-&gt;rect.left = 0;\n                        }\n                        drawable-&gt;sprite.setTextureRect(anim-&gt;rect);\n                    }\n                }\n            }\n        };\n\n\n        /**\n        * Manages the entities's parallax component and apply it to their drawable\n        *\n        * This cannot be used with an animation component.\n        *\n        */\n        struct ParallaxSystem {\n\n            void operator()(ECS::Registry &amp;R, double dt)\n            {\n                // Get all entities with a Parallax component\n                std::vector&lt;ECS::entity_id&gt; allEntities = R.getEntitiesWithComponent&lt;ECS::Component::Parallax&gt;();\n                sf::IntRect newRect;\n\n                // Iterate over all entities with a Parallax component\n                for (auto &amp;entity : allEntities) {\n                    auto parallax = R.getComponent&lt;ECS::Component::Parallax&gt;(entity);\n                    auto drawable = R.getComponent&lt;ECS::Component::Drawable&gt;(entity);\n\n                    if (drawable != nullptr &amp;&amp; parallax != nullptr) {\n                        newRect = drawable-&gt;sprite.getTextureRect();\n                        newRect.left += parallax-&gt;speed;\n                        if (newRect.left &gt; newRect.width) {\n                            newRect.left = 0;\n                        }\n                        drawable-&gt;sprite.setTextureRect(newRect);\n                    }\n                }\n            }\n        };\n\n        /**\n        * Debug Tool to manage local control for entities\n        *\n        */\n        struct PlayerControl {\n\n            std::shared_ptr&lt;sf::RenderWindow&gt; _win;\n            sf::Event event;\n\n            PlayerControl( std::shared_ptr&lt;sf::RenderWindow&gt;&amp; winPtr) : _win(winPtr) {}\n\n            void operator()(ECS::Registry &amp;R, double dt)\n            {\n                std::vector&lt;ECS::entity_id&gt; allEntities = R.getEntitiesWithComponent&lt;ECS::Component::PlayerInput&gt;();\n                for (auto &amp;entity : allEntities) {\n                    auto inputs = R.getComponent&lt;ECS::Component::PlayerInput&gt;(entity);\n                    inputs-&gt;action = sf::Keyboard::isKeyPressed(sf::Keyboard::Space);\n                    inputs-&gt;left = sf::Keyboard::isKeyPressed(sf::Keyboard::Left);\n                    inputs-&gt;up = sf::Keyboard::isKeyPressed(sf::Keyboard::Up);\n                    inputs-&gt;down = sf::Keyboard::isKeyPressed(sf::Keyboard::Down);\n                    inputs-&gt;right = sf::Keyboard::isKeyPressed(sf::Keyboard::Right);\n                }\n            }\n        };\n\n        /**\n        * Debug Tool to manage local movement for entities based on Debug Movement\n        *\n        */\n        struct PlayerMovement {\n\n            void operator()(ECS::Registry &amp;R, double dt)\n            {\n                std::vector&lt;ECS::entity_id&gt; allEntities = R.getEntitiesWithComponent&lt;ECS::Component::PlayerInput&gt;();\n                for (auto &amp;entity : allEntities) {\n                    auto inputs = R.getComponent&lt;ECS::Component::PlayerInput&gt;(entity);\n                    auto vel = R.getComponent&lt;ECS::Component::Velocity&gt;(entity);\n                    if (vel) {\n                        vel-&gt;x = (inputs-&gt;left * -300) + (inputs-&gt;right * 300);\n                        vel-&gt;y = (inputs-&gt;up * -300) + (inputs-&gt;down * 300);\n                    }\n                }\n            }\n        };\n\n    }\n\n#endif\n</code></pre>"},{"location":"coverage/ecs/src/Script/","title":"Script","text":"Name Lines Covered Uncovered Coverage AScript.hpp 8 0 8 0.0% IScript.hpp 0 0 0 100.0% Summary 8 0 8 0.0%"},{"location":"coverage/ecs/src/Script/AScript.hpp/","title":"AScript.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** EpiGimp\n** File description:\n** ErrorException\n*/\n\n#ifndef A_SCRIPT_H_\n    #define A_SCRIPT_H_\n\n    #include \"IScript.hpp\"\n    #include \"../ECSManager.hpp\"\n\n    namespace ECS\n    {\n        /**\n        * Default abstract of IScript, only global functions are defined.\n        *\n        * This script's methods will be called by the engine in specific moments, they cannot be called\n        * elsewhere\n        *\n        * Classes that inherit from this (the scripts you will create) can have their own private variables\n        * or component pointers (see example scripts in the ScriptSource folder for example)\n        *\n        * @param Game Pointer to access the engine class's content\n        * @param _selfID ID of the script's entity\n        *\n        */\n        class AScript : public ECS::IScript\n        {\n            public:\n                ~AScript() = default;\n\n                /**\n                * Called on Entity's first frame of existence, usefull for getting all components once\n                *\n                */\n                void onStart() {}\n\n                /**\n                * Called every frame\n                *\n                */\n                void onUpdate() {}\n\n                /**\n                * Called when an entity collides with another, they need a hitbox component to be activatable\n                * \n                * @param id ID of the entity who collided the script's owner\n                *\n                */\n                void onCollision(ECS::entity_id id) {}\n\n                /**\n                * Called when mouse clicks on the entity, they need to have an hitbox\n                *\n                */\n                void onClick() {}\n                void onEnterCamera() {} //NOT SUPPORTED\n                void onExitCamera() {} //NOT SUPPORTED\n\n                /**\n                * Called when Script is assigned to an entity so that they can manipulate the engine\n                *\n                * @param ecsManager Pointer to ECSManager Class (the engine).\n                */\n                void setEcsManager(ECS::ECSManager* ecsManager) {\n                    Game = ecsManager;\n                }\n\n                /**\n                * Defines the script's user ID\n                *\n                * @param id Entity ID.\n                */\n                void setEntityID(ECS::entity_id id) {\n                    _selfID = id;\n                }\n\n                /**\n                * Automatically spawn a prefab at (x, y), useful for spawning decor or temporary animation elements\n                *\n                * @warning NOT RECOMMENDED, MODIFYING ENTITIES CREATED BY THIS METHOD MAY CAUSE CRASH\n                * @param prefabName Prefab name.\n                * @param x X position\n                * @param y Y position\n                */\n                ECS::entity_id spawnPrefabAt(std::string prefabName, int x, int y) {\n                    ECS::entity_id id = Game-&gt;createEntityFromPrefab(prefabName);\n                    auto e = Game-&gt;getComponent&lt;ECS::Component::Position&gt;(id);\n                    if (e != nullptr) {\n                        e-&gt;x = x;\n                        e-&gt;y = y;\n                    }\n                    return id;\n                }\n\n            protected:\n                ECS::ECSManager *Game;\n                ECS::entity_id _selfID;\n\n        };\n    }\n\n#endif\n</code></pre>"},{"location":"coverage/ecs/src/Script/IScript.hpp/","title":"IScript.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** EpiGimp\n** File description:\n** ErrorException\n*/\n\n#ifndef I_SCRIPT_H_\n    #define I_SCRIPT_H_\n\n    #include \"../Entity.hpp\"\n\n    namespace ECS\n    {\n        class ECSManager;\n\n        /**\n        * Interface for script classes\n        *\n        */\n        class IScript\n        {\n            public:\n                virtual ~IScript() = default;\n                virtual void onStart() = 0;\n                virtual void onUpdate() = 0;\n                virtual void onCollision(ECS::entity_id id) = 0;\n                virtual void onClick() = 0;\n                virtual void onEnterCamera() = 0;\n                virtual void onExitCamera() = 0;\n                virtual void setEcsManager(ECS::ECSManager* ecsManager) = 0;\n                virtual void setEntityID(ECS::entity_id id) = 0;\n        };\n    }\n\n#endif\n</code></pre>"},{"location":"coverage/flint/","title":"flint","text":"Name Lines Covered Uncovered Coverage src 101 0 101 0.0% Colors 0 0 0 100.0% Colors.cpp 0 0 0 100.0% Colors.hpp 0 0 0 100.0% CxxABI 34 0 34 0.0% CxxABI.cpp 34 0 34 0.0% CxxABI.hpp 0 0 0 100.0% Exceptions 44 0 44 0.0% Exceptions.cpp 43 0 43 0.0% Exceptions.hpp 1 0 1 0.0% Init 6 0 6 0.0% Init.cpp 6 0 6 0.0% Init.hpp 0 0 0 100.0% Logging 9 0 9 0.0% Logging.cpp 8 0 8 0.0% Logging.hpp 1 0 1 0.0% hpp 8 0 8 0.0% Inspection.hpp 8 0 8 0.0% Preprocessor.hpp 0 0 0 100.0% Summary 0 0 0 100.0% Summary 34 0 34 0.0% Summary 44 0 44 0.0% Summary 6 0 6 0.0% Summary 9 0 9 0.0% Summary 8 0 8 0.0% Summary 101 0 101 0.0% Summary 101 0 101 0.0%"},{"location":"coverage/flint/src/","title":"src","text":"Name Lines Covered Uncovered Coverage Colors 0 0 0 100.0% Colors.cpp 0 0 0 100.0% Colors.hpp 0 0 0 100.0% CxxABI 34 0 34 0.0% CxxABI.cpp 34 0 34 0.0% CxxABI.hpp 0 0 0 100.0% Exceptions 44 0 44 0.0% Exceptions.cpp 43 0 43 0.0% Exceptions.hpp 1 0 1 0.0% Init 6 0 6 0.0% Init.cpp 6 0 6 0.0% Init.hpp 0 0 0 100.0% Logging 9 0 9 0.0% Logging.cpp 8 0 8 0.0% Logging.hpp 1 0 1 0.0% hpp 8 0 8 0.0% Inspection.hpp 8 0 8 0.0% Preprocessor.hpp 0 0 0 100.0% Summary 0 0 0 100.0% Summary 34 0 34 0.0% Summary 44 0 44 0.0% Summary 6 0 6 0.0% Summary 9 0 9 0.0% Summary 8 0 8 0.0% Summary 101 0 101 0.0%"},{"location":"coverage/flint/src/Colors/","title":"Colors","text":"Name Lines Covered Uncovered Coverage Colors.cpp 0 0 0 100.0% Colors.hpp 0 0 0 100.0% Summary 0 0 0 100.0%"},{"location":"coverage/flint/src/Colors/Colors.cpp/","title":"Colors.cpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Thu, May, 2024                                                     *\n * Title           - CppLib                                                             *\n * Description     -                                                                    *\n *     Colors                                                                           *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *         \u2591        \u2591       \u2591\u2591        \u2591        \u2591        \u2591\u2591      \u2591\u2591  \u2591\u2591\u2591\u2591  \u2591             *\n *         \u2592  \u2592\u2592\u2592\u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592  \u2592  \u2592\u2592\u2592\u2592  \u2592             *\n *         \u2593      \u2593\u2593\u2593       \u2593\u2593\u2593\u2593\u2593  \u2593\u2593\u2593\u2593\u2593\u2593\u2593  \u2593\u2593\u2593\u2593      \u2593\u2593\u2593  \u2593\u2593\u2593\u2593\u2593\u2593\u2593        \u2593             *\n *         \u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588  \u2588  \u2588\u2588\u2588\u2588  \u2588             *\n *         \u2588        \u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588        \u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588        \u2588\u2588      \u2588\u2588  \u2588\u2588\u2588\u2588  \u2588             *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#include \"Colors.hpp\"\n\nnamespace Flint\n{\n    const std::string Colors::RESET          = \"\\033[0m\";\n    const std::string Colors::BOLD           = \"\\033[1m\";\n    const std::string Colors::DISABLED       = \"\\033[2m\";\n    const std::string Colors::ITALIC         = \"\\033[3m\";\n    const std::string Colors::UNDERLINE      = \"\\033[4m\";\n    const std::string Colors::BLINK          = \"\\033[5m\";\n    const std::string Colors::HIGHLIGHTED    = \"\\033[7m\";\n    const std::string Colors::STRIPED        = \"\\033[9m\";\n    const std::string Colors::BLACK          = \"\\033[30m\";\n    const std::string Colors::RED            = \"\\033[31m\";\n    const std::string Colors::GREEN          = \"\\033[32m\";\n    const std::string Colors::YELLOW         = \"\\033[33m\";\n    const std::string Colors::BLUE           = \"\\033[34m\";\n    const std::string Colors::PURPLE         = \"\\033[35m\";\n    const std::string Colors::CYAN           = \"\\033[36m\";\n    const std::string Colors::GREY           = \"\\033[37m\";\n    const std::string Colors::F_BLACK        = \"\\033[90m\";\n    const std::string Colors::F_RED          = \"\\033[91m\";\n    const std::string Colors::F_GREEN        = \"\\033[92m\";\n    const std::string Colors::F_YELLOW       = \"\\033[93m\";\n    const std::string Colors::F_BLUE         = \"\\033[94m\";\n    const std::string Colors::F_PURPLE       = \"\\033[95m\";\n    const std::string Colors::F_CYAN         = \"\\033[96m\";\n    const std::string Colors::F_GREY         = \"\\033[97m\";\n}\n</code></pre>"},{"location":"coverage/flint/src/Colors/Colors.hpp/","title":"Colors.hpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Thu, May, 2024                                                     *\n * Title           - CppLib                                                             *\n * Description     -                                                                    *\n *     Colors                                                                           *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *       \u2584\u2580\u2580\u2588\u2584\u2584\u2584\u2584  \u2584\u2580\u2580\u2584\u2580\u2580\u2580\u2584  \u2584\u2580\u2580\u2588\u2580\u2584    \u2584\u2580\u2580\u2580\u2588\u2580\u2580\u2584  \u2584\u2580\u2580\u2588\u2584\u2584\u2584\u2584  \u2584\u2580\u2584\u2584\u2584\u2584   \u2584\u2580\u2580\u2584 \u2584\u2584             *\n *      \u2590  \u2584\u2580   \u2590 \u2588   \u2588   \u2588 \u2588   \u2588  \u2588  \u2588    \u2588  \u2590 \u2590  \u2584\u2580   \u2590 \u2588 \u2588    \u258c \u2588  \u2588   \u2584\u2580            *\n *        \u2588\u2584\u2584\u2584\u2584\u2584  \u2590  \u2588\u2580\u2580\u2580\u2580  \u2590   \u2588  \u2590  \u2590   \u2588       \u2588\u2584\u2584\u2584\u2584\u2584  \u2590 \u2588      \u2590  \u2588\u2584\u2584\u2584\u2588             *\n *        \u2588    \u258c     \u2588          \u2588        \u2588        \u2588    \u258c    \u2588         \u2588   \u2588             *\n *       \u2584\u2580\u2584\u2584\u2584\u2584    \u2584\u2580        \u2584\u2580\u2580\u2580\u2580\u2580\u2584   \u2584\u2580        \u2584\u2580\u2584\u2584\u2584\u2584    \u2584\u2580\u2584\u2584\u2584\u2584\u2580   \u2584\u2580  \u2584\u2580             *\n *       \u2588    \u2590   \u2588         \u2588       \u2588 \u2588          \u2588    \u2590   \u2588     \u2590   \u2588   \u2588               *\n *       \u2590        \u2590         \u2590       \u2590 \u2590          \u2590        \u2590         \u2590   \u2590               *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#ifndef INCLUDED_COLORS_HPP\n    #define INCLUDED_COLORS_HPP\n\n    #include \"../Headers.hpp\"\n\nnamespace Flint\n{\n    /**\n      * This class defined a good set of ANSI colors.\n      *\n      * @ingroup flint\n      *\n      * @tip\n      * It is recomended to use those through streams :\n      * std::cout &lt;&lt; Flint::Colors::GREEN &lt;&lt; \"Hacker time\" &lt;&lt; Flint::Colors::RESET &lt;&lt; std::endl;\n      *\n      * @info\n      * Please ALWAYS remember to close your colors with Flint::Colors::RESET.\n      * Failure to do si might result in broken displays, with weird colors everywhere\n    */\n    class Colors\n    {\n        public:\n            static const std::string RESET;\n            static const std::string BOLD;\n            static const std::string DISABLED;\n            static const std::string ITALIC;\n            static const std::string UNDERLINE;\n            static const std::string BLINK;\n            static const std::string HIGHLIGHTED;\n            static const std::string STRIPED;\n            static const std::string BLACK;\n            static const std::string RED;\n            static const std::string GREEN;\n            static const std::string YELLOW;\n            static const std::string BLUE;\n            static const std::string PURPLE;\n            static const std::string CYAN;\n            static const std::string GREY;\n            static const std::string F_BLACK;\n            static const std::string F_RED;\n            static const std::string F_GREEN;\n            static const std::string F_YELLOW;\n            static const std::string F_BLUE;\n            static const std::string F_PURPLE;\n            static const std::string F_CYAN;\n            static const std::string F_GREY;\n    };\n}\n\n#endif\n</code></pre>"},{"location":"coverage/flint/src/CxxABI/","title":"CxxABI","text":"Name Lines Covered Uncovered Coverage CxxABI.cpp 34 0 34 0.0% CxxABI.hpp 0 0 0 100.0% Summary 34 0 34 0.0%"},{"location":"coverage/flint/src/CxxABI/CxxABI.cpp/","title":"CxxABI.cpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Thu, May, 2024                                                     *\n * Title           - CppLib                                                             *\n * Description     -                                                                    *\n *     CxxABI                                                                           *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *       _|_|_|_|  _|_|_|    _|_|_|  _|_|_|_|_|  _|_|_|_|    _|_|_|  _|    _|           *\n *       _|        _|    _|    _|        _|      _|        _|        _|    _|           *\n *       _|_|_|    _|_|_|      _|        _|      _|_|_|    _|        _|_|_|_|           *\n *       _|        _|          _|        _|      _|        _|        _|    _|           *\n *       _|_|_|_|  _|        _|_|_|      _|      _|_|_|_|    _|_|_|  _|    _|           *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#include \"CxxABI.hpp\"\n\nnamespace Flint\n{\n    std::string CxxABI::demangle(const char* name)\n    {\n        int status = -4;\n        char* _out = abi::__cxa_demangle(name, nullptr, nullptr, &amp;status);\n        if (status != 0 &amp;&amp; _out)\n            free(_out);\n        if (status != 0)\n            return std::string(name);\n        std::string result(_out);\n        free(_out);\n        return result;\n    }\n\n    std::pair&lt;std::string, std::size_t&gt; CxxABI::getFuncInfos(const char* symbolInfos)\n    {\n        std::pair&lt;std::string, std::size_t&gt; output;\n        std::string entry(symbolInfos);\n\n        std::size_t openP  = entry.find('(');\n        std::size_t closeP = entry.find(')');\n\n        if (openP == std::string::npos ||\n            closeP == std::string::npos)\n            return output;\n\n        std::string functionAndOffset = entry.substr(openP + 1, closeP);\n        std::size_t plusP  = functionAndOffset.find('+');\n\n        if (functionAndOffset.empty() ||\n            plusP == std::string::npos)\n            return output;\n\n        output.first  = CxxABI::demangle(functionAndOffset.substr(0, plusP).c_str());\n        std::stringstream ss;\n        ss &lt;&lt; std::hex &lt;&lt; functionAndOffset.substr(plusP + 1);\n        ss &gt;&gt; output.second;\n\n        return output;\n    }\n\n    // std::vector&lt;std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt;&gt; CxxABI::getBacktrace()\n    std::vector&lt;std::pair&lt;std::string, std::size_t&gt;&gt; CxxABI::getBacktrace()\n    {\n        std::vector&lt;std::pair&lt;std::string, std::size_t&gt;&gt; out;\n        int TRACE_CHUNCK = 128;\n\n        int size = 0, out_size = 0;\n        do {\n            size += TRACE_CHUNCK;\n            void* trace[size + 1];\n            out_size = (int)backtrace(trace, size);\n        } while (out_size == size);\n        void* trace[out_size + 1];\n\n        backtrace(trace, out_size);\n        char** symbols = backtrace_symbols(trace, out_size);\n        if (symbols) {\n            for (int i = 0; i &lt; out_size; ++i) {\n                std::pair&lt;std::string, std::size_t&gt; symbol = CxxABI::getFuncInfos(symbols[i]);\n                if (symbol.first.empty())\n                    break;\n                out.push_back(symbol);\n            }\n            free(symbols);\n        }\n\n        return out;\n    }\n}\n</code></pre>"},{"location":"coverage/flint/src/CxxABI/CxxABI.hpp/","title":"CxxABI.hpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Thu, May, 2024                                                     *\n * Title           - CppLib                                                             *\n * Description     -                                                                    *\n *     CxxABI                                                                           *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *       \u2584\u2580\u2580\u2588\u2584\u2584\u2584\u2584  \u2584\u2580\u2580\u2584\u2580\u2580\u2580\u2584  \u2584\u2580\u2580\u2588\u2580\u2584    \u2584\u2580\u2580\u2580\u2588\u2580\u2580\u2584  \u2584\u2580\u2580\u2588\u2584\u2584\u2584\u2584  \u2584\u2580\u2584\u2584\u2584\u2584   \u2584\u2580\u2580\u2584 \u2584\u2584             *\n *      \u2590  \u2584\u2580   \u2590 \u2588   \u2588   \u2588 \u2588   \u2588  \u2588  \u2588    \u2588  \u2590 \u2590  \u2584\u2580   \u2590 \u2588 \u2588    \u258c \u2588  \u2588   \u2584\u2580            *\n *        \u2588\u2584\u2584\u2584\u2584\u2584  \u2590  \u2588\u2580\u2580\u2580\u2580  \u2590   \u2588  \u2590  \u2590   \u2588       \u2588\u2584\u2584\u2584\u2584\u2584  \u2590 \u2588      \u2590  \u2588\u2584\u2584\u2584\u2588             *\n *        \u2588    \u258c     \u2588          \u2588        \u2588        \u2588    \u258c    \u2588         \u2588   \u2588             *\n *       \u2584\u2580\u2584\u2584\u2584\u2584    \u2584\u2580        \u2584\u2580\u2580\u2580\u2580\u2580\u2584   \u2584\u2580        \u2584\u2580\u2584\u2584\u2584\u2584    \u2584\u2580\u2584\u2584\u2584\u2584\u2580   \u2584\u2580  \u2584\u2580             *\n *       \u2588    \u2590   \u2588         \u2588       \u2588 \u2588          \u2588    \u2590   \u2588     \u2590   \u2588   \u2588               *\n *       \u2590        \u2590         \u2590       \u2590 \u2590          \u2590        \u2590         \u2590   \u2590               *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#ifndef INCLUDED_CXXABI_HPP\n    #define INCLUDED_CXXABI_HPP\n\n    #include \"../Headers.hpp\"\n\nnamespace Flint\n{\n    /**\n      * Wrapper around usefull C++/C low level functions\n      *\n      * @ingroup flint\n      *\n      * Got demangle, backtrace...\n      *\n      * @tip\n      * This class is only made of static functions. It does not contain constructor, nor destructor\n      * This means that you don't need to instanciate it, and only use it as if it was a namespace.\n    */\n    class CxxABI\n    {\n        public:\n            CxxABI() = delete;\n\n            /**\n              * Demangle a C++ name.\n              *\n              * This is usefull for : Class names, backtrace...\n              *\n              * @return string containing : demangled name, or original name, if demangle did not work\n            */\n            static std::string demangle(const char* name);\n\n            /**\n              * Get functions infos from symbol extraction\n              *\n              * @return A pair with the function names demangled, and the offset from the function\n              *\n              * @warning\n              * The function name is not EXACTLY the real name of the function.\n              * Also, the offset DOES NOT correspond to the line number, but the offset of asm instructions\n            */\n            static std::pair&lt;std::string, std::size_t&gt; getFuncInfos(const char* symbolInfos);\n\n            /**\n              * Retreive the execution trace\n              *\n              * @return Vector of pair&lt;pair&lt;string, size_t&gt;, string&gt;. I'll explain\n              *\n              * The idea is to retrieive the file, line, and function. So that's what we do :\n              * pair or : (file, line), function\n              *\n              * @warning\n              * To correctly grab function names, you will need to add compilation flag \"-rdynamic\"\n              * See this lib's CMakeLists.txt for implementation.\n              * This will export ALL symbols.\n              * If NOT done, you will get offsets from binary. It's ok, but quite disgusting on output.\n            */\n            static std::vector&lt;std::pair&lt;std::string, std::size_t&gt;&gt; getBacktrace();\n    };\n}\n\n#endif\n</code></pre>"},{"location":"coverage/flint/src/Exceptions/","title":"Exceptions","text":"Name Lines Covered Uncovered Coverage Exceptions.cpp 43 0 43 0.0% Exceptions.hpp 1 0 1 0.0% Summary 44 0 44 0.0%"},{"location":"coverage/flint/src/Exceptions/Exceptions.cpp/","title":"Exceptions.cpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Sun, Apr, 2024                                                     *\n * Title           - CppLib                                                             *\n * Description     -                                                                    *\n *     Exceptions                                                                       *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *       _|_|_|_|  _|_|_|    _|_|_|  _|_|_|_|_|  _|_|_|_|    _|_|_|  _|    _|           *\n *       _|        _|    _|    _|        _|      _|        _|        _|    _|           *\n *       _|_|_|    _|_|_|      _|        _|      _|_|_|    _|        _|_|_|_|           *\n *       _|        _|          _|        _|      _|        _|        _|    _|           *\n *       _|_|_|_|  _|        _|_|_|      _|      _|_|_|_|    _|_|_|  _|    _|           *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#include \"Exceptions.hpp\"\n\nnamespace Flint::Exceptions\n{\n    Exception::Exception(const std::string&amp; what, std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; infos):\n        _infos(infos)\n    {\n        std::vector&lt;std::pair&lt;std::string, std::size_t&gt;&gt; stackTrace = CxxABI::getBacktrace();\n        std::stringstream ss;\n\n        ss &lt;&lt; \"[\" &lt;&lt; Flint::Colors::F_PURPLE &lt;&lt; this-&gt;getClassNameFromStackTrace(stackTrace) &lt;&lt; Flint::Colors::RESET;\n\n        if (!infos.first.first.empty() &amp;&amp; !infos.second.empty()) {\n            ss &lt;&lt; \" in \" &lt;&lt;\n                Flint::Colors::F_YELLOW &lt;&lt; infos.second &lt;&lt; Flint::Colors::RESET &lt;&lt;\n                \" at \" &lt;&lt;\n                Flint::Colors::F_BLUE &lt;&lt; infos.first.first.substr(infos.first.first.find_last_of(\"/\\\\\") + 1) &lt;&lt; Flint::Colors::RESET &lt;&lt;\n                \":\" &lt;&lt;\n                Flint::Colors::F_RED &lt;&lt; infos.first.second &lt;&lt; Flint::Colors::RESET;\n        }\n        ss &lt;&lt; \"] \" &lt;&lt; what;\n\n        for (std::size_t i = 2; i &lt; stackTrace.size(); i++) {\n            std::string funcName = stackTrace[i].first;\n            std::size_t openP    = funcName.find('(');\n            if (openP == std::string::npos)\n                funcName += \"()\";\n            funcName = funcName.substr(0, funcName.find(\"(\") + 1) + \"[...])\";\n            ss &lt;&lt; std::endl &lt;&lt; \" -&gt; \" &lt;&lt;\n            Flint::Colors::CYAN &lt;&lt; funcName &lt;&lt; Flint::Colors::RESET &lt;&lt;\n            \":\" &lt;&lt;\n            Flint::Colors::YELLOW &lt;&lt; \"0x\" &lt;&lt; std::hex &lt;&lt; stackTrace[i].second &lt;&lt; Flint::Colors::RESET;\n        }\n\n        this-&gt;_what = ss.str();\n    }\n\n    std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; Exception::getInfos() const\n    {\n        return this-&gt;_infos;\n    }\n\n    std::string Exception::getClassNameFromStackTrace(const std::vector&lt;std::pair&lt;std::string, std::size_t&gt;&gt;&amp; stackTrace) const\n    {\n        if (stackTrace.size() &lt;= 2)\n            return \"[Class name undefined]\";\n\n        std::string classNameSymbol = stackTrace[2].first.substr();\n        std::size_t openP           = classNameSymbol.find('(');\n        if (openP == std::string::npos)\n            return \"[Class name undefined]\";\n\n        std::string functionName = classNameSymbol.substr(0, openP);\n        std::size_t lastColon    = functionName.rfind(\"::\");\n        if (lastColon == std::string::npos)\n            return \"[Class name undefined]\";\n        // Remove duplicate\n        return functionName.substr(0, lastColon);\n    }\n\n    std::string Exception::show(std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; fileInfos) const\n    {\n        std::stringstream ss;\n        ss &lt;&lt; \"Exception caught on \" &lt;&lt;\n              Flint::Colors::F_GREEN &lt;&lt; fileInfos.second       &lt;&lt; Flint::Colors::RESET &lt;&lt; \" at \" &lt;&lt;\n              Flint::Colors::F_BLUE  &lt;&lt; fileInfos.first.first  &lt;&lt; Flint::Colors::RESET &lt;&lt; \":\" &lt;&lt;\n              Flint::Colors::F_RED   &lt;&lt; fileInfos.first.second &lt;&lt; Flint::Colors::RESET &lt;&lt; std::endl &lt;&lt; std::endl;\n\n        ss &lt;&lt; this-&gt;_what;\n        return ss.str();\n    }\n\n    const char* Exception::what() const noexcept\n    {\n        return this-&gt;_what.c_str();\n    }\n\n    std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Exceptions::Exception&amp; obj)\n    {\n        os &lt;&lt; obj.what();\n        return os;\n    }\n}\n</code></pre>"},{"location":"coverage/flint/src/Exceptions/Exceptions.hpp/","title":"Exceptions.hpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Sun, Apr, 2024                                                     *\n * Title           - CppLib                                                             *\n * Description     -                                                                    *\n *     Exceptions                                                                       *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557  \u2588\u2588\u2557                     *\n *             \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551  \u2588\u2588\u2551                     *\n *             \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551                     *\n *             \u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551                     *\n *             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551                     *\n *             \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d     \u255a\u2550\u255d   \u255a\u2550\u255d   \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d                     *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#ifndef INCLUDED_EXCEPTIONS_HPP\n    #define INCLUDED_EXCEPTIONS_HPP\n\n    #include \"../Headers.hpp\"\n    #include \"../CxxABI/CxxABI.hpp\"\n    #include \"../Colors/Colors.hpp\"\n    #include \"../hpp/Preprocessor.hpp\"\n\nnamespace Flint::Exceptions\n{\n    /**\n      * Wrapper arround default [std::exception](https://en.cppreference.com/w/cpp/error/exception)\n      *\n      * @ingroup flint\n      *\n      * Store the the exception description as [std::string](https://en.cppreference.com/w/cpp/string/basic_string),\n      * and store some usefull localisation informations: Filename, Line, and Function Name.\n      * This is automated using the throw_exception preprocessor directive.\n      *\n      * @tip\n      * Take a look at the NotImplementedError to see how easy it is to implmeent your own Flint::Exception.\n    */\n    class Exception: public std::exception\n    {\n        protected:\n            std::string _what;\n            std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; _infos;\n        public:\n            /**\n              * Exception constructor. This need to be called, even on child classes.\n              *\n              * @param what Define the exception's description\n              * @param infos Might contain positional infos\n              *\n              * @warning\n              * You should **NOT** use any excpetion constructor manually.\n              * While they might work, the prefered way is to use the throw_exception preprocessor directive.\n              * Using it will only require you to register what type of excpetion you want to throw, and what message you want to add, and will take care of putting file name, line, and function name\n            */\n            Exception(const std::string&amp; what = \"An exception occured !\",\n                      std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; infos = {{\"\", 0}, \"\"});\n\n            /**\n              * Retreive given infos (filename, line, and function name)\n              *\n              * @return The actual infos\n            */\n            std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; getInfos() const;\n\n            /**\n              * Try to retreive the Exception class name from the StackTrace.\n              *\n              * @param stackTrace A stack trace, formated like CxxABI::getBacktrace()\n              *\n              * @warning\n              * This function **DOES NOT WORK 100% OF THE TIME**.\n              * It is really dependant on the environement, and can return undefined without aparent reason.\n              * It should **NOT** be used for anything else than debug or display.\n              *\n              * @return The actual class name or \"[Class name undefined]\"\n            */\n            std::string getClassNameFromStackTrace(const std::vector&lt;std::pair&lt;std::string, std::size_t&gt;&gt;&amp; stackTrace) const;\n\n            /**\n              * Display the error, given specific positional infos (like the constructor).\n              *\n              * @param infos Positional informations, like the constructor, used to display the infos.\n              *\n              * @note\n              * This function, while being usable without, should be used through the catch_exception preprocessor directive.\n              * This preprocessor directive let you display Python like excpetion trace.\n              *\n              * @return The formated exception, ready to be displayed.\n            */\n            std::string show(std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; infos) const;\n\n            /**\n              * Required override, deprecated by show and catch_exception.\n              *\n              * @info\n              * This is the required std::exception override.\n              * It'll return the _what as a const char*.\n              * While this will work, prefer using the show function or the catch_excpetion preprocessor directive :\n              *\n              * @example\n              * ```cpp\n              * try {\n              *     throw_exception(Flint::Exceptions::Exception, \"Sample testing exception\");\n              * } catch (const Flint::Exceptions::Exception&amp; e) {\n              *     std::cerr &lt;&lt; catch_exception(e) &lt;&lt; std::endl;\n              * }\n              * ```\n              *\n              * @return The _what as a C string\n            */\n            const char* what() const noexcept override;\n\n            /**\n              * operator&lt;&lt; override\n              *\n              * @abstract\n              * This will simply append the _what to the ostream\n            */\n            friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Exceptions::Exception&amp; obj);\n    };\n\n    /**\n      * Sample Flint::Exceptions::Exception to register NotImplemented features\n      *\n      * @ingroup flint\n      *\n      * @tip\n      * You should use that Exception as a C++ Implementation of the Rust todo!() macro.\n      *\n      * @example\n      * ```cpp\n      * throw_exception(Flint::Exceptions::NotImplementedError, \"This function haven't been implemented as of today !\");\n      * ```\n    */\n    class NotImplementedError:\n        public Flint::Exceptions::Exception\n    {\n        public:\n            NotImplementedError(const std::string&amp; what = \"Asked action haven't been implemented yet.\",\n                                std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; infos = {{\"\", 0}, \"\"}):\n                Exception(what, infos)\n            {}\n    };\n}\n\n#endif\n</code></pre>"},{"location":"coverage/flint/src/Init/","title":"Init","text":"Name Lines Covered Uncovered Coverage Init.cpp 6 0 6 0.0% Init.hpp 0 0 0 100.0% Summary 6 0 6 0.0%"},{"location":"coverage/flint/src/Init/Init.cpp/","title":"Init.cpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Thu, May, 2024                                                     *\n * Title           - Flint                                                              *\n * Description     -                                                                    *\n *     Init                                                                             *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *       \u2584\u2580\u2580\u2588\u2584\u2584\u2584\u2584  \u2584\u2580\u2580\u2584\u2580\u2580\u2580\u2584  \u2584\u2580\u2580\u2588\u2580\u2584    \u2584\u2580\u2580\u2580\u2588\u2580\u2580\u2584  \u2584\u2580\u2580\u2588\u2584\u2584\u2584\u2584  \u2584\u2580\u2584\u2584\u2584\u2584   \u2584\u2580\u2580\u2584 \u2584\u2584             *\n *      \u2590  \u2584\u2580   \u2590 \u2588   \u2588   \u2588 \u2588   \u2588  \u2588  \u2588    \u2588  \u2590 \u2590  \u2584\u2580   \u2590 \u2588 \u2588    \u258c \u2588  \u2588   \u2584\u2580            *\n *        \u2588\u2584\u2584\u2584\u2584\u2584  \u2590  \u2588\u2580\u2580\u2580\u2580  \u2590   \u2588  \u2590  \u2590   \u2588       \u2588\u2584\u2584\u2584\u2584\u2584  \u2590 \u2588      \u2590  \u2588\u2584\u2584\u2584\u2588             *\n *        \u2588    \u258c     \u2588          \u2588        \u2588        \u2588    \u258c    \u2588         \u2588   \u2588             *\n *       \u2584\u2580\u2584\u2584\u2584\u2584    \u2584\u2580        \u2584\u2580\u2580\u2580\u2580\u2580\u2584   \u2584\u2580        \u2584\u2580\u2584\u2584\u2584\u2584    \u2584\u2580\u2584\u2584\u2584\u2584\u2580   \u2584\u2580  \u2584\u2580             *\n *       \u2588    \u2590   \u2588         \u2588       \u2588 \u2588          \u2588    \u2590   \u2588     \u2590   \u2588   \u2588               *\n *       \u2590        \u2590         \u2590       \u2590 \u2590          \u2590        \u2590         \u2590   \u2590               *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#include \"Init.hpp\"\n\nnamespace Flint\n{\n    static void unhandeled_exception()\n    {\n        try {\n            std::rethrow_exception(std::current_exception());\n        } catch (const std::exception&amp; e) {\n            const Flint::Exceptions::Exception* exception = dynamic_cast&lt;const Flint::Exceptions::Exception*&gt;(&amp;e);\n            if (exception != nullptr) {\n                std::cerr &lt;&lt; Flint::Colors::RED &lt;&lt; \"/!\\\\\" &lt;&lt; Flint::Colors::RESET &lt;&lt; \" Uncaught Flint exception \" &lt;&lt; Flint::Colors::RED &lt;&lt; \"/!\\\\\" &lt;&lt; Flint::Colors::RESET &lt;&lt; std::endl &lt;&lt; std::endl &lt;&lt; *exception &lt;&lt; std::endl;\n            } else {\n                std::cerr &lt;&lt; Flint::Colors::RED &lt;&lt; \"/!\\\\\" &lt;&lt; Flint::Colors::RESET &lt;&lt; \" Uncaught exception \" &lt;&lt; Flint::Colors::RED &lt;&lt; \"/!\\\\\" &lt;&lt; Flint::Colors::RESET &lt;&lt; std::endl &lt;&lt; std::endl &lt;&lt; e.what() &lt;&lt; std::endl;\n            }\n        }\n    }\n\n    void Init()\n    {\n        std::set_terminate(unhandeled_exception);\n    }\n}\n</code></pre>"},{"location":"coverage/flint/src/Init/Init.hpp/","title":"Init.hpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Thu, May, 2024                                                     *\n * Title           - Flint                                                              *\n * Description     -                                                                    *\n *     Init                                                                             *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557  \u2588\u2588\u2557                     *\n *             \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551  \u2588\u2588\u2551                     *\n *             \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551                     *\n *             \u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551                     *\n *             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551                     *\n *             \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d     \u255a\u2550\u255d   \u255a\u2550\u255d   \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d                     *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#ifndef INCLUDED_INIT_HPP\n    #define INCLUDED_INIT_HPP\n\n    #include \"../Exceptions/Exceptions.hpp\"\n\nnamespace Flint\n{\n    [[gnu::constructor]] void Init();\n}\n\n#endif\n</code></pre>"},{"location":"coverage/flint/src/Logging/","title":"Logging","text":"Name Lines Covered Uncovered Coverage Logging.cpp 8 0 8 0.0% Logging.hpp 1 0 1 0.0% Summary 9 0 9 0.0%"},{"location":"coverage/flint/src/Logging/Logging.cpp/","title":"Logging.cpp","text":"<pre><code>#include \"Logging.hpp\"\n\nnamespace Flint\n{\n    Logging&amp; Logging::get()\n    {\n        static Logging instance;\n        return instance;\n    }\n\n    void Logging::set_log_on_stderr(bool log_on_stderr)\n    {\n        Logging::get().log_on_stderr = log_on_stderr;\n    }\n\n    void Logging::set_log_level(LogLevel level)\n    {\n        Logging::get().display_level = level;\n    }\n\n    void Logging::set_error_level(LogLevel level)\n    {\n        Logging::get().error_level = level;\n    }\n\n    void Logging::debug(const std::string&amp; message)\n    {\n        auto some_data = Flint::CxxABI::getBacktrace();\n        std::cout &lt;&lt; some_data.size() &lt;&lt; std::endl;\n        for (auto entry: some_data)\n            std::cout &lt;&lt; entry.first &lt;&lt; \" - \" &lt;&lt; entry.second &lt;&lt; std::endl;\n    }\n\n    void Logging::info(const std::string&amp; message)\n    {\n\n    }\n\n    void Logging::warning(const std::string&amp; message)\n    {\n\n    }\n\n    void Logging::error(const std::string&amp; message)\n    {\n\n    }\n\n    void Logging::critical(const std::string&amp; message)\n    {\n\n    }\n}\n</code></pre>"},{"location":"coverage/flint/src/Logging/Logging.hpp/","title":"Logging.hpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Sun, Apr, 2024                                                     *\n * Title           - CppLib                                                             *\n * Description     -                                                                    *\n *     Exceptions                                                                       *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557  \u2588\u2588\u2557                     *\n *             \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551  \u2588\u2588\u2551                     *\n *             \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551                     *\n *             \u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551                     *\n *             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551                     *\n *             \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d     \u255a\u2550\u255d   \u255a\u2550\u255d   \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d                     *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#ifndef INCLUDED_LOGGING_HPP\n    #define INCLUDED_LOGGING_HPP\n\n    #include \"../Headers.hpp\"\n    #include \"../CxxABI/CxxABI.hpp\"\n    #include \"../Colors/Colors.hpp\"\n    #include \"../Exceptions/Exceptions.hpp\"\n\nnamespace Flint\n{\n    enum LogLevel\n    {\n        Debug       = 0,\n        Info        = 1,\n        Warning     = 2,\n        Error       = 3,\n        Critical    = 4,\n    };\n\n    class TooHighLevelLoggingError:\n        public Flint::Exceptions::Exception\n    {\n        public:\n            TooHighLevelLoggingError(const std::string&amp; what = \"The message logged is of criticly high level.\",\n                                     std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; infos = {{\"\", 0}, \"\"}):\n                Exception(what, infos)\n            {}\n    };\n\n    class Logging\n    {\n        private:\n            Logging() {}\n\n            bool log_on_stderr      = false;\n            LogLevel display_level  = LogLevel::Info;\n            LogLevel error_level    = LogLevel::Critical;\n\n            static Logging&amp; get();\n\n        public:\n            Logging(const Logging&amp;)         = delete;\n            void operator=(const Logging&amp;)  = delete;\n\n            static void set_log_on_stderr(bool log_on_stderr);\n            static void set_log_level(LogLevel level);\n            static void set_error_level(LogLevel level);\n\n            static void debug(const std::string&amp; message);\n            static void info(const std::string&amp; message);\n            static void warning(const std::string&amp; message);\n            static void error(const std::string&amp; message);\n            static void critical(const std::string&amp; message);\n    };\n}\n\n#endif\n</code></pre>"},{"location":"coverage/flint/src/hpp/","title":"hpp","text":"Name Lines Covered Uncovered Coverage Inspection.hpp 8 0 8 0.0% Preprocessor.hpp 0 0 0 100.0% Summary 8 0 8 0.0%"},{"location":"coverage/flint/src/hpp/Inspection.hpp/","title":"Inspection.hpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Thu, May, 2024                                                     *\n * Title           - CppLib                                                             *\n * Description     -                                                                    *\n *     Inspection                                                                       *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *         \u2591        \u2591       \u2591\u2591        \u2591        \u2591        \u2591\u2591      \u2591\u2591  \u2591\u2591\u2591\u2591  \u2591             *\n *         \u2592  \u2592\u2592\u2592\u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592  \u2592  \u2592\u2592\u2592\u2592  \u2592             *\n *         \u2593      \u2593\u2593\u2593       \u2593\u2593\u2593\u2593\u2593  \u2593\u2593\u2593\u2593\u2593\u2593\u2593  \u2593\u2593\u2593\u2593      \u2593\u2593\u2593  \u2593\u2593\u2593\u2593\u2593\u2593\u2593        \u2593             *\n *         \u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588  \u2588  \u2588\u2588\u2588\u2588  \u2588             *\n *         \u2588        \u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588        \u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588        \u2588\u2588      \u2588\u2588  \u2588\u2588\u2588\u2588  \u2588             *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#ifndef INCLUDED_INSPECTION_HPP\n    #define INCLUDED_INSPECTION_HPP\n\n    #include \"../Headers.hpp\"\n    #include \"../CxxABI/CxxABI.hpp\"\n\nnamespace Flint\n{\n    /**\n      * Base class to implement simplet self-reflexion in C++\n      *\n      * @ingroup flint\n      *\n      * @tparam T Child class itself\n      *\n      * @tip\n      * When creating a child class, define as follow :\n      * ```cpp\n      * class ChildClass: public Inspection&lt;ChildClass&gt;\n      * ```\n      * This will extand the ChildClass with the self-reflexion class Inspection\n      *\n      * @warning\n      * If the class you want to extand as a reflected class will be a parent class\n      * (I.E. You will create childs of this \"target\" class), you might want to\n      * mark inheritence as **virtual**.\n      * This is needed if your child class _also_ need to be reflected.\n      * This way, there is no confilict between the parent reflexion, and the child reflexion.\n    */\n    template &lt;typename T&gt;\n    class Inspection\n    {\n        public:\n            /**\n              * Return the name of the reflected class\n              *\n              * @return The demangled name of the class, or just the name, if demangleing failed\n            */\n            virtual std::string getClassName() const final\n            {\n                return CxxABI::demangle(typeid(T).name());\n            }\n\n            // virtual std::unordered_set&lt;std::pair&lt;std::string, std::string&gt;&gt; getAttributes();\n\n            /**\n              * Return a string representation of the class\n              *\n              * @tip\n              * This function is not intended to be used.\n              * This is because this functions display the reflection.\n              * You might prefer to override this function in yout child\n              * class to display informations that are more relevant to\n              * your specific class.\n              *\n              * @example\n              * You have a Macro available to make the str function really\n              * easilly :\n              * ```cpp\n              * display_attr(attribute)\n              * ```\n              * Which will automaticly translate to\n              * ```cpp\n              * Flint::Colors::F_BLUE &lt;&lt; \"attribute\" &lt;&lt; Flint::Colors::RESET &lt;&lt; \"=\" &lt;&lt; Flint::Colors::RED &lt;&lt; this-&gt;attribute &lt;&lt; Flint::Colors::RESET\n              * ```\n              * There is also a `make_str` macro, which you can use as follow :\n              * ```cpp\n              * return make_str(\"a=12\" &lt;&lt; \", \" &lt;&lt; \"b=5\");\n              * ```\n              * that becomes\n              * ```cpp\n              * return ({std::stringstream ss; ss &lt;&lt; \"&lt;\" &lt;&lt; this-&gt;getClassName() &lt;&lt; \" at \" &lt;&lt; std::hex &lt;&lt; this &lt;&lt; \": \" &lt;&lt; \"a=12\" &lt;&lt; \", \" &lt;&lt; \"b=5\" &lt;&lt; \"&gt;\"; ss.str()})\n              * ```\n              * It means you can define the str function of your class as like that :\n              * ```cpp\n              * // Provided you have 3 attributes called a, b and c\n              * return make_str(display_attr(a) &lt;&lt; \", \" &lt;&lt; display_attr(b) &lt;&lt; \", \" &lt;&lt; display_attr(c));\n              * ```\n              *\n              * @return The string representation of the class\n            */\n            virtual std::string str() const\n            {\n                std::stringstream ss;\n\n                ss &lt;&lt; \"&lt;\" &lt;&lt;\n                    Flint::Colors::F_PURPLE &lt;&lt; this-&gt;getClassName() &lt;&lt; Flint::Colors::RESET &lt;&lt;\n                    \" at \" &lt;&lt;\n                    Flint::Colors::YELLOW   &lt;&lt; std::hex &lt;&lt; this     &lt;&lt; Flint::Colors::RESET &lt;&lt;\n                    \"&gt;\";\n\n                return ss.str();\n            }\n\n            /** Overload the operator &lt;&lt; to use the str method of the object\n              *\n              * @tparam T Reflected class\n              *\n              * @param os Reference of ostream (I.E. std::cout, std::cerr...)\n              *\n              * @param obj Object reference to be displayed\n              *\n              * @return Param os\n            */\n            friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Inspection&lt;T&gt;&amp; obj)\n            {\n                os &lt;&lt; obj.str();\n                return os;\n            }\n    };\n}\n\n\n#endif\n</code></pre>"},{"location":"coverage/flint/src/hpp/Preprocessor.hpp/","title":"Preprocessor.hpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Thu, May, 2024                                                     *\n * Title           - CppLib                                                             *\n * Description     -                                                                    *\n *     Preprocessor                                                                     *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *       \u2584\u2580\u2580\u2588\u2584\u2584\u2584\u2584  \u2584\u2580\u2580\u2584\u2580\u2580\u2580\u2584  \u2584\u2580\u2580\u2588\u2580\u2584    \u2584\u2580\u2580\u2580\u2588\u2580\u2580\u2584  \u2584\u2580\u2580\u2588\u2584\u2584\u2584\u2584  \u2584\u2580\u2584\u2584\u2584\u2584   \u2584\u2580\u2580\u2584 \u2584\u2584             *\n *      \u2590  \u2584\u2580   \u2590 \u2588   \u2588   \u2588 \u2588   \u2588  \u2588  \u2588    \u2588  \u2590 \u2590  \u2584\u2580   \u2590 \u2588 \u2588    \u258c \u2588  \u2588   \u2584\u2580            *\n *        \u2588\u2584\u2584\u2584\u2584\u2584  \u2590  \u2588\u2580\u2580\u2580\u2580  \u2590   \u2588  \u2590  \u2590   \u2588       \u2588\u2584\u2584\u2584\u2584\u2584  \u2590 \u2588      \u2590  \u2588\u2584\u2584\u2584\u2588             *\n *        \u2588    \u258c     \u2588          \u2588        \u2588        \u2588    \u258c    \u2588         \u2588   \u2588             *\n *       \u2584\u2580\u2584\u2584\u2584\u2584    \u2584\u2580        \u2584\u2580\u2580\u2580\u2580\u2580\u2584   \u2584\u2580        \u2584\u2580\u2584\u2584\u2584\u2584    \u2584\u2580\u2584\u2584\u2584\u2584\u2580   \u2584\u2580  \u2584\u2580             *\n *       \u2588    \u2590   \u2588         \u2588       \u2588 \u2588          \u2588    \u2590   \u2588     \u2590   \u2588   \u2588               *\n *       \u2590        \u2590         \u2590       \u2590 \u2590          \u2590        \u2590         \u2590   \u2590               *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#ifndef INCLUDED_PREPROCESSOR_HPP\n    #define INCLUDED_PREPROCESSOR_HPP\n\n#if defined(__GNUC__)\n    #define __FUNCTION__ __PRETTY_FUNCTION__\n#elif defined(_MSC_VER)\n    #define __FUNCTION__ __FUNCSIG__\n#else\n    #define __FUNCTION__ __func__\n#endif\n\n    #define __POSITION_INFOS__ {{std::string(__FILE__), __LINE__}, std::string(__FUNCTION__)}\n    #define throw_exception(exception, message) throw(exception(message, __POSITION_INFOS__))\n    #define catch_exception(exception) exception.show(__POSITION_INFOS__)\n\n// Inspection\n    #define display_attr(attribute) Flint::Colors::F_BLUE &lt;&lt; #attribute &lt;&lt; Flint::Colors::RESET &lt;&lt; \"=\" &lt;&lt; Flint::Colors::RED &lt;&lt; this-&gt;attribute &lt;&lt; Flint::Colors::RESET\n    #define make_str(display) ({std::stringstream ss; ss &lt;&lt; Flint::Colors::RESET &lt;&lt; \"&lt;\" &lt;&lt; Flint::Colors::F_PURPLE &lt;&lt; this-&gt;getClassName() &lt;&lt; Flint::Colors::RESET &lt;&lt; \" at \" &lt;&lt; Flint::Colors::YELLOW &lt;&lt; std::hex &lt;&lt; this &lt;&lt; std::dec &lt;&lt; Flint::Colors::RESET &lt;&lt; \": \" &lt;&lt; display &lt;&lt; \"&gt;\"; ss.str();})\n\n#endif\n</code></pre>"},{"location":"coverage/network/","title":"network","text":"Name Lines Covered Uncovered Coverage src 101 0 101 0.0% Security 71 0 71 0.0% DecodeError.hpp 3 0 3 0.0% GaloisField.cpp 8 0 8 0.0% GaloisField.hpp 1 0 1 0.0% HammingCodes.cpp 55 0 55 0.0% HammingCodes.hpp 1 0 1 0.0% ReedSolomon.cpp 2 0 2 0.0% ReedSolomon.hpp 1 0 1 0.0% Serialized 3 0 3 0.0% PlayerPosition.cpp 3 0 3 0.0% PlayerPosition.hpp 0 0 0 100.0% Server 27 0 27 0.0% UDP 27 0 27 0.0% UDPServer.cpp 27 0 27 0.0% UDPServer.hpp 0 0 0 100.0% Summary 71 0 71 0.0% Summary 3 0 3 0.0% Summary 27 0 27 0.0% Summary 27 0 27 0.0% Summary 101 0 101 0.0% Summary 101 0 101 0.0%"},{"location":"coverage/network/src/","title":"src","text":"Name Lines Covered Uncovered Coverage Security 71 0 71 0.0% DecodeError.hpp 3 0 3 0.0% GaloisField.cpp 8 0 8 0.0% GaloisField.hpp 1 0 1 0.0% HammingCodes.cpp 55 0 55 0.0% HammingCodes.hpp 1 0 1 0.0% ReedSolomon.cpp 2 0 2 0.0% ReedSolomon.hpp 1 0 1 0.0% Serialized 3 0 3 0.0% PlayerPosition.cpp 3 0 3 0.0% PlayerPosition.hpp 0 0 0 100.0% Server 27 0 27 0.0% UDP 27 0 27 0.0% UDPServer.cpp 27 0 27 0.0% UDPServer.hpp 0 0 0 100.0% Summary 71 0 71 0.0% Summary 3 0 3 0.0% Summary 27 0 27 0.0% Summary 27 0 27 0.0% Summary 101 0 101 0.0%"},{"location":"coverage/network/src/Security/","title":"Security","text":"Name Lines Covered Uncovered Coverage DecodeError.hpp 3 0 3 0.0% GaloisField.cpp 8 0 8 0.0% GaloisField.hpp 1 0 1 0.0% HammingCodes.cpp 55 0 55 0.0% HammingCodes.hpp 1 0 1 0.0% ReedSolomon.cpp 2 0 2 0.0% ReedSolomon.hpp 1 0 1 0.0% Summary 71 0 71 0.0%"},{"location":"coverage/network/src/Security/DecodeError.hpp/","title":"DecodeError.hpp","text":"<pre><code>#ifndef INCLUDED_NETWORK_DECODE_ERROR_HPP\n    #define INCLUDED_NETWORK_DECODE_ERROR_HPP\n\n    #include \"Flint.hpp\"\n    #include \"../export.hpp\"\n\nnamespace Network::Security\n{\n    class NETWORK_API DecodingError:\n        public Flint::Exceptions::Exception\n    {\n        public:\n            DecodingError(const std::string&amp; what = \"Could not decode/verify received data.\",\n                          std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; infos = {{\"\", 0}, \"\"}):\n                Exception(what, infos)\n            {}\n    };\n}\n\n#endif\n</code></pre>"},{"location":"coverage/network/src/Security/GaloisField.cpp/","title":"GaloisField.cpp","text":"<pre><code>#include \"GaloisField.hpp\"\n\nnamespace Network::Security\n{\n    GaloisField::GaloisField(int primitive, int field_size):\n        primitive(primitive), field_size(field_size)\n    {\n        throw_exception(Flint::Exceptions::NotImplementedError, \"GaloisField haven't been implemented yet !\");\n        this-&gt;exp_table.resize(this-&gt;field_size);\n        this-&gt;log_table.resize(this-&gt;field_size);\n\n        unsigned char x = 1;\n        for (unsigned char i = 0; i &lt; this-&gt;field_size; ++i) {\n            this-&gt;exp_table[i] = x;\n            this-&gt;log_table[x] = i;\n            x = (x * 2) % field_size;\n        }\n    }\n}\n</code></pre>"},{"location":"coverage/network/src/Security/GaloisField.hpp/","title":"GaloisField.hpp","text":"<pre><code>#ifndef INCLUDED_NETWORK_GALOIS_FIELD_HPP\n    #define INCLUDED_NETWORK_GALOIS_FIELD_HPP\n\n    #include \"Flint.hpp\"\n    #include \"DecodeError.hpp\"\n    #include \"../export.hpp\"\n\nnamespace Network::Security\n{\n    class NETWORK_API GaloisField\n    {\n        private:\n            unsigned char primitive;\n            unsigned char field_size;\n            std::string exp_table;\n            std::string log_table;\n\n        public:\n            GaloisField(int primitive, int field_size);\n            void generate_field(int primitive);\n            int add(int a, int b);\n            int multiply(int a, int b);\n            int inverse(int a);\n            int divide(int a, int b);\n    };\n}\n\n#endif\n</code></pre>"},{"location":"coverage/network/src/Security/HammingCodes.cpp/","title":"HammingCodes.cpp","text":"<pre><code>#include \"HammingCodes.hpp\"\n\nnamespace Network::Security\n{\n    unsigned HammingCodes::get_nb_parity(unsigned size)\n    {\n        int p = 0;\n        while (pow(2, p) &lt; size + p + 1)\n            ++p;\n        return p;\n    }\n\n    unsigned HammingCodes::get_nb_parity_from_final_size(unsigned size)\n    {\n        int p = 0;\n        while (pow(2, p) &lt;= size)\n            ++p;\n        return p - 1;\n    }\n\n    void HammingCodes::setBit(std::string&amp; data, std::size_t pos, bool value)\n    {\n        size_t indx = pos / 8;\n        size_t ofst = pos % 8;\n        if (indx &gt;= data.size())\n            throw_exception(Network::Security::DecodingError, \"Position is outsize of the data !\");\n        if (value)\n            data[indx] |= (1 &lt;&lt; ofst);\n        else\n            data[indx] &amp;= ~(1 &lt;&lt; ofst);\n    }\n\n    bool HammingCodes::getBit(const std::string&amp; data, std::size_t pos)\n    {\n        size_t indx = pos / 8;\n        size_t ofst = pos % 8;\n        if (indx &gt;= data.size())\n            throw_exception(Network::Security::DecodingError, \"Position is outsize of the data !\");\n        return (data[indx] &gt;&gt; ofst) &amp; 1;\n    }\n\n    void HammingCodes::setParityBits(std::string&amp; data, unsigned size)\n    {\n        unsigned p = get_nb_parity(size);\n        for (unsigned i = 0; i &lt; p; ++i) {\n            unsigned p_pos = (1 &lt;&lt; i) - 1;\n            bool parity = false;\n\n            for (unsigned j = p_pos; j &lt; size; j += 2 * (p_pos + 1))\n                for (unsigned k = j; k &lt; j + (p_pos + 1) &amp;&amp; k &lt; size; ++k)\n                    if (k != p_pos)\n                        parity ^= HammingCodes::getBit(data, k);\n\n            HammingCodes::setBit(data, p_pos, parity);\n        }\n    }\n\n    std::string HammingCodes::encode(const std::string&amp; data)\n    {\n        unsigned dataBits = data.size() * 8;\n        unsigned parityBits = get_nb_parity(dataBits);\n        unsigned totalBits = dataBits + parityBits;\n\n        std::string coded_data((totalBits + 7) / 8, 0);\n\n        unsigned dataIndex = 0;\n        for (unsigned i = 0; i &lt; totalBits; ++i) {\n            if ((i &amp; (i + 1)) == 0)\n                continue;\n            setBit(coded_data, i, getBit(data, dataIndex));\n            ++dataIndex;\n        }\n\n        setParityBits(coded_data, totalBits);\n\n        return coded_data;\n    }\n\n    std::string HammingCodes::decode(const std::string&amp; data)\n    {\n        std::string output = data;\n        unsigned totalBits = output.size() * 8;\n        unsigned parityBits = get_nb_parity_from_final_size(totalBits);\n        unsigned dataBits = totalBits - parityBits;\n\n        unsigned errorPos = 0;\n        for (unsigned i = 0; i &lt; parityBits; ++i) {\n            unsigned parityPos = (1 &lt;&lt; i) - 1;\n            bool parity = false;\n\n            for (unsigned j = parityPos; j &lt; totalBits; j += 2 * (parityPos + 1))\n                for (unsigned k = j; k &lt; j + (parityPos + 1) &amp;&amp; k &lt; totalBits; ++k)\n                    parity ^= getBit(output, k);\n\n            if (parity)\n                errorPos |= (1 &lt;&lt; i);\n        }\n\n        if (errorPos)\n            HammingCodes::setBit(output, errorPos, !getBit(output, errorPos));\n\n        std::string decoded_data((dataBits + 7) / 8, 0);\n        unsigned dataIndex = 0;\n        for (unsigned i = 0; i &lt; totalBits; ++i) {\n            if ((i &amp; (i + 1)) == 0)\n                continue;\n            setBit(decoded_data, dataIndex, getBit(output, i));\n            ++dataIndex;\n        }\n\n        size_t last_non_null = decoded_data.find_last_not_of('\\0');\n        if (last_non_null != std::string::npos)\n            decoded_data.resize(last_non_null + 1);\n        else\n            decoded_data.clear();\n\n        return decoded_data;\n    }\n}\n</code></pre>"},{"location":"coverage/network/src/Security/HammingCodes.hpp/","title":"HammingCodes.hpp","text":"<pre><code>#ifndef INCLUDED_NETWORK_HAMMING_CODE_HPP\n    #define INCLUDED_NETWORK_HAMMING_CODE_HPP\n\n    #include \"Flint.hpp\"\n    #include \"DecodeError.hpp\"\n    #include \"../export.hpp\"\n\nnamespace Network::Security\n{\n    const int PRIMITIVE = 0x11d;\n    const int FIELD_SIZE = 256;\n    const int N = 255;\n    const int K = 223;\n\n    class NETWORK_API HammingCodes\n    {\n        private:\n            static unsigned get_nb_parity(unsigned size);\n            static unsigned get_nb_parity_from_final_size(unsigned size);\n            static void setBit(std::string&amp; byte, std::size_t pos, bool value);\n            static bool getBit(const std::string&amp; byte, std::size_t pos);\n            static void setParityBits(std::string&amp; data, unsigned size);\n        public:\n            static std::string encode(const std::string&amp; data);\n            static std::string decode(const std::string&amp; data);\n    };\n}\n\n\n#endif\n</code></pre>"},{"location":"coverage/network/src/Security/ReedSolomon.cpp/","title":"ReedSolomon.cpp","text":"<pre><code>#include \"ReedSolomon.hpp\"\n\nnamespace Network::Security\n{\n    ReedSolomon::ReedSolomon(int primitive, int field_size, int n, int k):\n        gf(primitive, field_size), primitive(primitive), field_size(field_size), n(n), k(k)\n    {\n        throw_exception(Flint::Exceptions::NotImplementedError, \"ReedSolomon haven't been implemented yet !\");\n    }\n}\n</code></pre>"},{"location":"coverage/network/src/Security/ReedSolomon.hpp/","title":"ReedSolomon.hpp","text":"<pre><code>#ifndef INCLUDED_NETWORK_REED_SOLOMON_HPP\n    #define INCLUDED_NETWORK_REED_SOLOMON_HPP\n\n    #include \"Flint.hpp\"\n    #include \"DecodeError.hpp\"\n    #include \"GaloisField.hpp\"\n    #include \"../export.hpp\"\n\nnamespace Network::Security\n{\n    class NETWORK_API ReedSolomon\n    {\n        private:\n            GaloisField gf;\n            int primitive;\n            int field_size;\n            int n, k;\n\n        public:\n            ReedSolomon(int primitive, int field_size, int n, int k);\n            std::string encode(const std::string&amp; message);\n    };\n}\n#endif\n</code></pre>"},{"location":"coverage/network/src/Serialized/","title":"Serialized","text":"Name Lines Covered Uncovered Coverage PlayerPosition.cpp 3 0 3 0.0% PlayerPosition.hpp 0 0 0 100.0% Summary 3 0 3 0.0%"},{"location":"coverage/network/src/Serialized/PlayerPosition.cpp/","title":"PlayerPosition.cpp","text":"<pre><code>#include \"PlayerPosition.hpp\"\n\nnamespace Network::Serialized\n{\n    PlayerPosition::PlayerPosition(unsigned user_id, Direction player_direction):\n        user_id(user_id), player_direction(player_direction)\n    {}\n\n    std::string PlayerPosition::str() const\n    {\n        return make_str(display_attr(user_id) &lt;&lt; \", \" &lt;&lt; display_attr(player_direction));\n    }\n\n    template&lt;typename Archive&gt;\n    void PlayerPosition::serialize(Archive&amp; ar)\n    {\n        ar(this-&gt;user_id, this-&gt;player_direction);\n    }\n}\n</code></pre>"},{"location":"coverage/network/src/Serialized/PlayerPosition.hpp/","title":"PlayerPosition.hpp","text":"<pre><code>#ifndef INCLUDED_NETWORK_PLAYER_POSITION_HPP\n    #define INCLUDED_NETWORK_PLAYER_POSITION_HPP\n\n    #include \"Flint.hpp\"\n\nnamespace Network::Serialized\n{\n    enum Direction\n    {\n        NONE    = 0,\n        UP      = 1,\n        RIGHT   = 2,\n        DOWN    = 3,\n        LEFT    = 4,\n    };\n\n    /*\n     * This class contains a serialized version of the player's position.\n     *\n     * This is used as temporary \"hard coded\" version of transmitting informations within the network.\n     *\n     * @note\n     * When the network will get updated, this will get thanos snaped in order to be replaced by the actual components:\n     *\n     * The goal is to be able to send direct components, to ease the network and integration process.\n     *\n     * @warning\n     * This class does NOT contain every parts of the actual game !\n     * It only contains the position.\n    */\n    class PlayerPosition:\n        public Flint::Inspection&lt;PlayerPosition&gt;\n    {\n        // private:\n        public:\n            unsigned user_id;\n            Direction player_direction;\n            // float x;\n            // float y;\n\n        public:\n            PlayerPosition(unsigned user_id, Direction player_direction);\n\n            /**\n              * This class being a child of Flint::Inspection, overriding the str function also override the operator&lt;&lt;.\n              * This is done for debugging purposes.\n            */\n            std::string str() const override;\n\n            template&lt;typename Archive&gt;\n            void serialize(Archive&amp; ar);\n    };\n}\n\n#endif\n</code></pre>"},{"location":"coverage/network/src/Server/","title":"Server","text":"Name Lines Covered Uncovered Coverage UDP 27 0 27 0.0% UDPServer.cpp 27 0 27 0.0% UDPServer.hpp 0 0 0 100.0% Summary 27 0 27 0.0% Summary 27 0 27 0.0%"},{"location":"coverage/network/src/Server/UDP/","title":"UDP","text":"Name Lines Covered Uncovered Coverage UDPServer.cpp 27 0 27 0.0% UDPServer.hpp 0 0 0 100.0% Summary 27 0 27 0.0%"},{"location":"coverage/network/src/Server/UDP/UDPServer.cpp/","title":"UDPServer.cpp","text":"<pre><code>#include \"UDPServer.hpp\"\n\nnamespace Network::Server::UDP\n{\n    UDPServer::UDPServer(unsigned short port):\n        port(port), loop(uv_default_loop())\n    {\n        uv_udp_init(this-&gt;loop, &amp;this-&gt;server);\n    }\n\n    void UDPServer::set_callback(Network::HandlerFunction function)\n    {\n        this-&gt;handler = function;\n    }\n\n    void UDPServer::start()\n    {\n        sockaddr_in addr;\n        uv_ip4_addr(\"0.0.0.0\", port, &amp;addr);\n        uv_udp_bind(&amp;this-&gt;server, (const struct sockaddr*)&amp;addr, 0);\n        uv_udp_recv_start(&amp;this-&gt;server, on_alloc,\n            *std::function&lt;void(uv_udp_t*, ssize_t, const uv_buf_t*, const struct sockaddr*, unsigned)&gt;(\n                [this](uv_udp_t* handle, ssize_t nread, const uv_buf_t* buf, const struct sockaddr* addr, unsigned flags)\n                {\n                    UDPServer::on_receive(*this, handle, nread, buf, addr, flags);\n                }\n            ).target&lt;uv_udp_recv_cb&gt;()\n        );\n\n        flint_info(\"UDP Server listening on 0.0.0.0:\" + this-&gt;port);\n\n        uv_run(this-&gt;loop, UV_RUN_DEFAULT);\n    }\n\n    void UDPServer::stop()\n    {\n        uv_loop_close(this-&gt;loop);\n    }\n\n    void UDPServer::on_alloc(uv_handle_t* handle, size_t size, uv_buf_t* buf)\n    {\n        buf-&gt;base = new char[size];\n        buf-&gt;len = size;\n    }\n\n    void UDPServer::on_receive(const Network::Server::UDP::UDPServer&amp; self, uv_udp_t* handle, ssize_t nread, const uv_buf_t* buf, const struct sockaddr* addr, unsigned flags)\n    {\n        if (nread &lt; 0) {\n            if (nread != UV_EOF) {\n                std::cerr &lt;&lt; \"Error reading UDP message.\" &lt;&lt; std::endl;\n            }\n            return;\n        }\n\n        std::string serialized_data(buf-&gt;base, nread);\n        Network::Serialized::PlayerPosition data = UDPServer::deserialize_from_string(serialized_data);\n        delete[] buf-&gt;base;\n\n        if (self.handler)\n            self.handler(data);\n    }\n\n    Network::Serialized::PlayerPosition UDPServer::deserialize_from_string(const std::string&amp; str)\n    {\n        std::istringstream is(str);\n        cereal::BinaryInputArchive archive(is);\n        Network::Serialized::PlayerPosition data(0, Network::Serialized::Direction::NONE);\n        archive(data);\n        return data;\n    }\n\n    std::string UDPServer::serialize_to_string(const Network::Serialized::PlayerPosition&amp; data)\n    {\n        std::ostringstream os;\n        cereal::BinaryOutputArchive archive(os);\n        archive(data);\n        return os.str();\n    }\n}\n</code></pre>"},{"location":"coverage/network/src/Server/UDP/UDPServer.hpp/","title":"UDPServer.hpp","text":"<pre><code>#ifndef INCLUDED_NETWORK_UDP_SERVER_HPP\n    #define INCLUDED_NETWORK_UDP_SERVER_HPP\n\n    #include &lt;cstring&gt;\n    #include &lt;uv.h&gt;\n    #include &lt;cereal/archives/binary.hpp&gt;\n    #include &lt;cereal/types/string.hpp&gt;\n    #include &lt;sstream&gt;\n    #include &lt;functional&gt;\n\n    #include \"../../Exceptions.hpp\"\n    #include \"../../Serialized/PlayerPosition.hpp\"\n    #include \"../../HandlerFunction.hpp\"\n    #include \"Flint.hpp\"\n\nnamespace Network::Server::UDP\n{\n    class UDPServer\n    {\n        private:\n            uv_loop_t* loop = NULL;\n            uv_udp_t server;\n            unsigned short port;\n\n            Network::HandlerFunction handler = nullptr;\n\n        private:\n            static void on_alloc(uv_handle_t* handle, size_t size, uv_buf_t* buf);\n            static void on_receive(const Network::Server::UDP::UDPServer&amp; self, uv_udp_t* handle, ssize_t nread, const uv_buf_t* buf, const struct sockaddr* addr, unsigned flags);\n\n            static Network::Serialized::PlayerPosition deserialize_from_string(const std::string&amp; str);\n            static std::string serialize_to_string(const Network::Serialized::PlayerPosition&amp; data);\n\n        public:\n            UDPServer(unsigned short port);\n\n            void set_callback(HandlerFunction function);\n            void start();\n            void stop();\n    };\n}\n\n#endif\n</code></pre>"},{"location":"coverage/server/","title":"server","text":"Name Lines Covered Uncovered Coverage src 175 0 175 0.0% Network 32 0 32 0.0% Socket.cpp 32 0 32 0.0% Socket.hpp 0 0 0 100.0% Server 143 0 143 0.0% Client.cpp 28 0 28 0.0% Client.hpp 0 0 0 100.0% Core.cpp 98 0 98 0.0% Core.hpp 0 0 0 100.0% PlayerInfo.cpp 9 0 9 0.0% PlayerInfo.hpp 0 0 0 100.0% ThreadSafeQueue.hpp 8 0 8 0.0% Summary 32 0 32 0.0% Summary 143 0 143 0.0% Summary 175 0 175 0.0% Summary 175 0 175 0.0%"},{"location":"coverage/server/src/","title":"src","text":"Name Lines Covered Uncovered Coverage Network 32 0 32 0.0% Socket.cpp 32 0 32 0.0% Socket.hpp 0 0 0 100.0% Server 143 0 143 0.0% Client.cpp 28 0 28 0.0% Client.hpp 0 0 0 100.0% Core.cpp 98 0 98 0.0% Core.hpp 0 0 0 100.0% PlayerInfo.cpp 9 0 9 0.0% PlayerInfo.hpp 0 0 0 100.0% ThreadSafeQueue.hpp 8 0 8 0.0% Summary 32 0 32 0.0% Summary 143 0 143 0.0% Summary 175 0 175 0.0%"},{"location":"coverage/server/src/Network/","title":"Network","text":"Name Lines Covered Uncovered Coverage Socket.cpp 32 0 32 0.0% Socket.hpp 0 0 0 100.0% Summary 32 0 32 0.0%"},{"location":"coverage/server/src/Network/Socket.cpp/","title":"Socket.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Server\n** File description:\n** Core\n*/\n\n#include \"Socket.hpp\"\n#include &lt;iostream&gt;\n\nSocket::Socket() : serverSocket(-1) {}\n\nSocket::~Socket() {\n    if (serverSocket != -1) {\n        close(serverSocket); // Clean up server socket on destruction\n    }\n}\n\nbool Socket::bindSocket(int port, const std::string&amp; ip) {\n    serverSocket = socket(AF_INET, SOCK_STREAM, 0);\n    if (serverSocket == -1) {\n        std::cerr &lt;&lt; \"Error: Failed to create socket!\" &lt;&lt; std::endl;\n        return false;\n    }\n\n    memset(&amp;serverAddr, 0, sizeof(serverAddr));\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, ip.c_str(), &amp;serverAddr.sin_addr) &lt;= 0) {\n        std::cerr &lt;&lt; \"Error: Invalid address or address not supported!\" &lt;&lt; std::endl;\n        return false;\n    }\n\n    if (bind(serverSocket, (struct sockaddr*)&amp;serverAddr, sizeof(serverAddr)) == -1) {\n        std::cerr &lt;&lt; \"Error: Failed to bind socket!\" &lt;&lt; std::endl;\n        return false;\n    }\n\n    return true;\n}\n\nbool Socket::listenForClients() {\n    if (listen(serverSocket, 100) == -1) {\n        std::cerr &lt;&lt; \"Error: Failed to listen on socket!\" &lt;&lt; std::endl;\n        return false;\n    }\n    return true;\n}\n\nint Socket::acceptClient() {\n    int clientSocket = accept(serverSocket, nullptr, nullptr);\n    if (clientSocket == -1) {\n        std::cerr &lt;&lt; \"Error: Failed to accept client connection!\" &lt;&lt; std::endl;\n    }\n    return clientSocket;\n}\n\nbool Socket::sendData(int clientSocket, const std::string&amp; data) {\n    int bytesSent = send(clientSocket, data.c_str(), data.length(), 0);\n    return bytesSent != -1;\n}\n\nstd::string Socket::receiveData(int clientSocket) {\n    char buffer[1024];\n    int bytesReceived = recv(clientSocket, buffer, sizeof(buffer), 0);\n    if (bytesReceived &lt;= 0) {\n        return \"\";\n    }\n    buffer[bytesReceived] = '\\0';\n    return std::string(buffer);\n}\n</code></pre>"},{"location":"coverage/server/src/Network/Socket.hpp/","title":"Socket.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Server\n** File description:\n** Core\n*/\n\n\n#ifndef SOCKET_HPP_\n    #define SOCKET_HPP_\n\n    #include &lt;string&gt;\n    #include &lt;sys/socket.h&gt;\n    #include &lt;netinet/in.h&gt;\n    #include &lt;arpa/inet.h&gt;\n    #include &lt;unistd.h&gt;\n    #include &lt;cstring&gt; // For memset\n\n    /**\n    * Simple encapsulation of unistd socket\n    * It assures proper connection to the client and handles the data exchange.\n    */\n    class Socket {\n    public:\n        Socket();\n        ~Socket();\n\n        bool bindSocket(int port, const std::string&amp; ip);\n        bool listenForClients();\n        int acceptClient();\n        bool sendData(int clientSocket, const std::string&amp; data);\n        std::string receiveData(int clientSocket);\n\n    private:\n        int serverSocket;\n        sockaddr_in serverAddr;\n    };\n\n#endif // SOCKET_HPP_\n</code></pre>"},{"location":"coverage/server/src/Server/","title":"Server","text":"Name Lines Covered Uncovered Coverage Client.cpp 28 0 28 0.0% Client.hpp 0 0 0 100.0% Core.cpp 98 0 98 0.0% Core.hpp 0 0 0 100.0% PlayerInfo.cpp 9 0 9 0.0% PlayerInfo.hpp 0 0 0 100.0% ThreadSafeQueue.hpp 8 0 8 0.0% Summary 143 0 143 0.0%"},{"location":"coverage/server/src/Server/Client.cpp/","title":"Client.cpp","text":"<pre><code>#include \"Client.hpp\"\n#include &lt;iostream&gt;\n#include &lt;unistd.h&gt; // For close()\n\nServer::Client::Client(int socket)\n    : _clientSocket(socket), _running(false)\n{\n}\n\nServer::Client::~Client()\n{\n    stop();\n    if (_clientSocket != -1) {\n        close(_clientSocket); // Close the socket when the client is destroyed\n    }\n}\n\nvoid Server::Client::start()\n{\n    _running = true;\n\n    // Make sure that the thread is detached or joined properly\n    try {\n        _clientThread = std::thread(&amp;Client::handleClient, this);\n\n        // Check if the thread was created successfully\n        if (!_clientThread.joinable()) {\n            throw std::runtime_error(\"Failed to create thread.\");\n        }\n\n        _clientThread.detach(); // Detach the thread to run independently\n    } catch (const std::exception&amp; e) {\n        std::cerr &lt;&lt; \"Error starting client thread: \" &lt;&lt; e.what() &lt;&lt; std::endl;\n        // Handle the exception appropriately\n    }\n}\n\nvoid Server::Client::stop()\n{\n    if (_running) {\n        _running = false;\n        if (_clientThread.joinable()) {\n            _clientThread.join();\n        }\n    }\n}\n\nvoid Server::Client::handleClient()\n{\n    // Handle communication with the client\n    this-&gt;sendMessage(\"connect\");\n    while (_running) {\n        // Receive message from the client\n        std::string message = _socket.receiveData(_clientSocket);\n        if (message.empty()) {\n            std::cout &lt;&lt; \"Client disconnected from socket \" &lt;&lt; _clientSocket &lt;&lt; \" !\\n\";\n            break; // Exit if client disconnects\n        }\n\n        if (message != \"\") {\n            // Add received message to the message queue for the server to process\n            _messageQueue.push(message);\n        }\n    }\n}\n\nvoid Server::Client::receiveMessage()\n{\n    std::string message = _socket.receiveData(_clientSocket);\n    if (message.empty()) {\n        std::cout &lt;&lt; \"Client disconnected from socket \" &lt;&lt; _clientSocket &lt;&lt; \" !\\n\";\n        return; // Exit if client disconnects or sends empty data\n    }\n\n    // Add received message to the message queue for the server to process\n    _messageQueue.push(message);\n\n    // Optionally, send an acknowledgment to the client\n    sendMessage(\"Message received\");\n}\n\nvoid Server::Client::sendMessage(const std::string&amp; message)\n{\n    if (!_socket.sendData(_clientSocket, message + \"\\n\")) {\n        std::cerr &lt;&lt; \"Failed to send message to client!\" &lt;&lt; std::endl;\n    }\n}\n\nThreadSafeQueue&lt;std::string&gt;&amp; Server::Client::getMessageQueue()\n{\n    return _messageQueue;\n}\n</code></pre>"},{"location":"coverage/server/src/Server/Client.hpp/","title":"Client.hpp","text":"<pre><code>#ifndef CLIENT_HPP_\n    #define CLIENT_HPP_\n\n    #include \"ThreadSafeQueue.hpp\"\n    #include \"Network/Socket.hpp\"\n    #include &lt;thread&gt;\n    #include &lt;string&gt;\n\n    namespace Server\n    {\n\n        /**\n        * Threaded class that handles communication between the server and the client.\n        * It uses the encapsulated socket.\n        */\n        class Client\n        {\n        public:\n            Client(int socket);\n            ~Client();\n\n            /**\n            * Starts the client thread and socket\n            */\n            void start();\n\n            /**\n            * Starts the client thread\n            */\n            void stop();\n\n            /**\n            * Send message to the client\n            * @param message Message to send\n            */\n            void sendMessage(const std::string&amp; message);\n\n            /**\n            * Check if the client sent data to the server and stores them in the queue, closes the thread if there is no message or is disconnected\n            */\n            void receiveMessage();\n\n            /**\n            * Returns the message queue that contains the messages sent by the client\n            */\n            ThreadSafeQueue&lt;std::string&gt;&amp; getMessageQueue();\n\n        private:\n            int _clientSocket;\n            std::thread _clientThread;\n            ThreadSafeQueue&lt;std::string&gt; _messageQueue;\n            bool _running;\n            Socket _socket;\n\n            void handleClient();\n        };\n\n    }\n\n#endif // CLIENT_HPP_\n</code></pre>"},{"location":"coverage/server/src/Server/Core.cpp/","title":"Core.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** EpiGimp\n** File description:\n** main\n*/\n\n#include \"Core.hpp\"\n#include \"ErrorException.hpp\"\n#include &lt;iostream&gt;\n#include &lt;thread&gt;\n\nServer::Core::Core(int port, std::string ip)\n    : _port(port), _ip(ip)\n{\n    this-&gt;_ecsManager = std::make_shared&lt;ECS::ECSManager&gt;(\"Server\", false, true);\n    this-&gt;_ecsManager-&gt;createWorld(\"Waiting\");\n}\n\nServer::Core::~Core()\n{\n    for (auto&amp; client : _clients) {\n        client.second-&gt;stop();\n    }\n}\n\nvoid Server::Core::run()\n{\n    if (!_socket.bindSocket(_port, _ip)) {\n        throw ErrorException(\"Error: Server failed to initialize!\");\n    }\n    if (!_socket.listenForClients()) {\n        throw ErrorException(\"Error: Server failed to listen for clients!\");\n    }\n    std::cout &lt;&lt; \"Server is running on \" &lt;&lt; _ip &lt;&lt; \":\" &lt;&lt; _port &lt;&lt; std::endl;\n\n    // Start accepting clients in a separate thread\n    std::thread acceptThread(&amp;Server::Core::acceptClients, this);\n    acceptThread.detach(); // Detach so it runs independently\n\n    while (true) {\n        processClientMessages();\n        std::cout &lt;&lt; \"\";\n        if (!this-&gt;_gameStarted) {\n            continue;\n        }\n        this-&gt;checkPlayersCapabilities();\n        this-&gt;_ecsManager-&gt;loopServer();\n        this-&gt;checkEvent();\n        this-&gt;sendGameUpdate();\n        if (this-&gt;_playerInfos.size() &lt;= 0) {\n            this-&gt;sendToAll(\"end\");\n            this-&gt;_gameStarted = false;\n        }\n        std::this_thread::sleep_for(std::chrono::duration&lt;float&gt;(0.016f));\n    }\n    this-&gt;sendToAll(\"end\");\n}\n\nvoid Server::Core::acceptClients()\n{\n    int nbrClients = 0;\n    while (true) {\n        if (nbrClients &gt;= 4) {\n            break;\n        }\n        int clientSocket = _socket.acceptClient();\n        if (clientSocket != -1) {\n            std::cout &lt;&lt; \"Client connected!\\n\";\n            this-&gt;_clients[nbrClients] = std::make_unique&lt;Client&gt;(clientSocket);\n            this-&gt;_clients[nbrClients]-&gt;start();\n            nbrClients++;\n        }\n    }\n}\n\nvoid Server::Core::processClientMessages()\n{\n    for (auto&amp; client : _clients) {\n        if (client.second == nullptr) continue;\n        std::string message = client.second-&gt;getMessageQueue().pop();\n        if (!message.empty()) {\n            this-&gt;handleCommand(message, client.first + 1);\n        }\n    }\n}\n\nvoid Server::Core::handleCommand(std::string message, int clientNbr)\n{\n    if (message == \"\") {\n        return;\n    }\n    ECS::entity_id id;\n    std::regex reg(\"[\\\\ \\\\n]\");\n    auto begin = std::sregex_token_iterator(message.begin(), message.end(), reg, -1);\n    auto end = std::sregex_token_iterator();\n    std::vector&lt;std::string&gt; command(begin, end);\n    if (command[0] == \"start\") {\n        this-&gt;sendToAll(\"start \" + std::to_string(this-&gt;_clients.size()));\n        this-&gt;_ecsManager-&gt;loadWorld(\"assets/world/test.json\");\n        int nbrPlayers = 1;\n        while (nbrPlayers &lt;= this-&gt;_clients.size()) {\n            id = this-&gt;_ecsManager-&gt;createEntityFromPrefab(\"player\" + std::to_string(nbrPlayers));\n            this-&gt;_ecsManager-&gt;getComponent&lt;ECS::Component::Position&gt;(id)-&gt;x = 100;\n            this-&gt;_ecsManager-&gt;getComponent&lt;ECS::Component::Position&gt;(id)-&gt;y = 300 + (100 * nbrPlayers);\n            this-&gt;_playerInfos[nbrPlayers] = std::make_unique&lt;Server::PlayerInfo&gt;(id);\n            nbrPlayers++;\n        }\n        this-&gt;_gameStarted = true;\n        return;\n    }\n    if (!_gameStarted) {\n        return;\n    }\n    if (this-&gt;_playerInfos.count(clientNbr) == 0) {\n        return;\n    }\n    auto vel = this-&gt;_ecsManager-&gt;getComponent&lt;ECS::Component::Velocity&gt;(this-&gt;_playerInfos[clientNbr]-&gt;getEntityID());\n    if (command[0] == \"up\") {\n        vel-&gt;y = -300 * (command[1] == \"1\"); return;\n    }\n    if (command[0] == \"down\") {\n        vel-&gt;y = 300 * (command[1] == \"1\"); return;\n    }\n    if (command[0] == \"left\") {\n        vel-&gt;x = -300 * (command[1] == \"1\"); return;\n    }\n    if (command[0] == \"right\") {\n        vel-&gt;x = 300 * (command[1] == \"1\"); return;\n    }\n    if (command[0] == \"action\") {\n        this-&gt;_playerInfos[clientNbr]-&gt;setIsShooting(command[1] == \"1\");\n    }\n    return;\n}\n\nvoid Server::Core::sendToAll(std::string message)\n{\n    for (auto&amp; client : _clients) {\n        client.second-&gt;sendMessage(message);\n    }\n}\n\nvoid Server::Core::checkPlayersCapabilities()\n{\n    for (auto&amp; player : _playerInfos) {\n        auto pos = this-&gt;_ecsManager-&gt;getComponent&lt;ECS::Component::Position&gt;(player.second-&gt;getEntityID());\n        if (pos == nullptr) {\n            this-&gt;sendToAll(\"playerDead \" + std::to_string(player.first));\n            this-&gt;_playerInfos.erase(player.first);\n            break;\n        }\n        pos-&gt;x = pos-&gt;x &lt; 20 ? 20 : pos-&gt;x;\n        pos-&gt;x = pos-&gt;x &gt; 1580 ? 1580 : pos-&gt;x;\n        pos-&gt;y = pos-&gt;y &lt; 20 ? 20 : pos-&gt;y;\n        pos-&gt;y = pos-&gt;y &gt; 880 ? 880 : pos-&gt;y;\n        player.second-&gt;reduceShootCooldown(0.016f);\n        if (player.second-&gt;getIsShooting() &amp;&amp; player.second-&gt;getShootCooldown() &lt;= 0) {\n            ECS::entity_id id = this-&gt;_ecsManager-&gt;createEntityFromPrefab(\"bullet\");\n            this-&gt;_ecsManager-&gt;getComponent&lt;ECS::Component::Position&gt;(id)-&gt;x = pos-&gt;x + 20;\n            this-&gt;_ecsManager-&gt;getComponent&lt;ECS::Component::Position&gt;(id)-&gt;y = pos-&gt;y;\n            player.second-&gt;setShootCooldown(0.3f);\n        }\n    }\n}\n\nvoid Server::Core::sendGameUpdate()\n{\n    std::ostringstream update;\n\n    std::vector&lt;ECS::entity_id&gt; entities = this-&gt;_ecsManager-&gt;getCurrentRegistry().getEntitiesWithComponent&lt;ECS::Component::Tag&gt;();\n    for (auto &amp;entity : entities) {\n        auto tag = this-&gt;_ecsManager-&gt;getComponent&lt;ECS::Component::Tag&gt;(entity);\n        if (tag-&gt;value == \"player\") {\n            continue;\n        }\n        auto pos = this-&gt;_ecsManager-&gt;getComponent&lt;ECS::Component::Position&gt;(entity);\n        if (pos-&gt;x &gt; -10 &amp;&amp; pos-&gt;x &lt; 1700) {\n            update &lt;&lt; \"place \" &lt;&lt; tag-&gt;value &lt;&lt; \" \" &lt;&lt; pos-&gt;x &lt;&lt; \" \" &lt;&lt; pos-&gt;y &lt;&lt; std::endl;\n        }\n    }\n    for (auto &amp;player : this-&gt;_playerInfos) {\n        auto pos = this-&gt;_ecsManager-&gt;getComponent&lt;ECS::Component::Position&gt;(player.second-&gt;getEntityID());\n        if (pos != nullptr) {\n            update &lt;&lt; \"player \" &lt;&lt; player.first &lt;&lt; \" \" &lt;&lt; pos-&gt;x &lt;&lt; \" \" &lt;&lt; pos-&gt;y &lt;&lt; std::endl;\n        }\n    }\n    this-&gt;sendToAll(update.str());\n    update.clear();\n}\n\nvoid Server::Core::checkEvent()\n{\n    for (auto &amp;e : this-&gt;_ecsManager-&gt;getAllEventsThisFrame()) {\n        this-&gt;sendToAll(e);\n    }\n}\n</code></pre>"},{"location":"coverage/server/src/Server/Core.hpp/","title":"Core.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Server\n** File description:\n** Core\n*/\n\n#ifndef CORE_HPP_\n    #define CORE_HPP_\n\n    #include \"ECSManager.hpp\"\n    #include \"Client.hpp\"\n    #include \"PlayerInfo.hpp\"\n    #include &lt;string&gt;\n    #include &lt;memory&gt;\n    #include &lt;thread&gt;\n    #include &lt;unordered_map&gt;\n\n    namespace Server\n    {\n\n        class Core\n        {\n        public:\n            Core(int port, std::string ip);\n            ~Core();\n\n            /**\n            * Run the server's loop and threads\n            */\n            void run();\n\n            /**\n            * Checks if any client sent a message to process with the handleCommand() method\n            */\n            void processClientMessages();\n\n            /**\n            * Handles the client's command\n            * @param message Client message containing the command\n            * @param clientNbr Number of the client\n            *\n            */\n            void handleCommand(std::string message, int clientNbr);\n\n            /**\n            * Sends a message to all the clients at once\n            * @param message Message to send\n            *\n            */\n            void sendToAll(std::string message);\n\n            /**\n            * Checks player positiona and cooldown to prevent cheating or out of bounds\n            *\n            */\n            void checkPlayersCapabilities();\n\n            /**\n            * Sends the player and all element positions.\n            *\n            */\n            void sendGameUpdate();\n\n            /**\n            * Check if the ECSManager has any events this frame and sends them to clients.\n            * The events are defined in the .so scripts\n            *\n            */\n            void checkEvent();\n\n        private:\n            std::shared_ptr&lt;ECS::ECSManager&gt; _ecsManager;\n            Socket _socket;\n            int _port;\n            std::string _ip;\n            std::unordered_map&lt;int, std::unique_ptr&lt;Server::Client&gt;&gt; _clients;\n\n            bool _gameStarted = false;\n            double _sendInfoCooldown = 0.1f;\n            std::unordered_map&lt;int, std::unique_ptr&lt;PlayerInfo&gt;&gt; _playerInfos;\n\n            double _ennemySpawnCountdown = 0.5f;\n\n            void acceptClients();\n        };\n\n    }\n\n#endif // CORE_HPP_\n</code></pre>"},{"location":"coverage/server/src/Server/PlayerInfo.cpp/","title":"PlayerInfo.cpp","text":"<pre><code>#include \"PlayerInfo.hpp\"\n\nServer::PlayerInfo::PlayerInfo(ECS::entity_id id)\n{\n    this-&gt;_entityID = id;\n    this-&gt;_shootCooldown = 0.3f;\n}\n\nServer::PlayerInfo::~PlayerInfo()\n{\n\n}\n\nECS::entity_id Server::PlayerInfo::getEntityID() const\n{\n    return this-&gt;_entityID;\n}\n\nvoid Server::PlayerInfo::setEntityID(ECS::entity_id id)\n{\n    this-&gt;_entityID = id;\n}\n\ndouble Server::PlayerInfo::getShootCooldown() const\n{\n    return this-&gt;_shootCooldown;\n}\n\nvoid Server::PlayerInfo::setShootCooldown(double cooldown)\n{\n    this-&gt;_shootCooldown = cooldown;\n}\n\nbool Server::PlayerInfo::getIsShooting() const\n{\n    return this-&gt;_isShooting;\n}\n\nvoid Server::PlayerInfo::setIsShooting(bool isShooting)\n{\n    this-&gt;_isShooting = isShooting;\n}\n\nvoid Server::PlayerInfo::reduceShootCooldown(double f)\n{\n    this-&gt;_shootCooldown -= f;\n}\n</code></pre>"},{"location":"coverage/server/src/Server/PlayerInfo.hpp/","title":"PlayerInfo.hpp","text":"<pre><code>#ifndef PLAYER_INFO_HPP_\n    #define PLAYER_INFO_HPP_\n\n    #include \"Entity.hpp\"\n    #include &lt;thread&gt;\n    #include &lt;string&gt;\n\n    namespace Server\n    {\n\n        /**\n        * Contains all gameplay information of the player in game\n        *\n        */\n        class PlayerInfo\n        {\n        public:\n            PlayerInfo(ECS::entity_id id);\n            ~PlayerInfo();\n\n            ECS::entity_id getEntityID() const;\n            void setEntityID(ECS::entity_id id);\n\n            double getShootCooldown() const;\n            void setShootCooldown(double cooldown);\n            void reduceShootCooldown(double f);\n\n            bool getIsShooting() const;\n            void setIsShooting(bool isShooting);\n\n\n\n        private:\n            ECS::entity_id _entityID;\n            double _shootCooldown = 0.3f;\n            bool _isShooting;\n\n        };\n\n    }\n\n#endif // CLIENT_HPP_\n</code></pre>"},{"location":"coverage/server/src/Server/ThreadSafeQueue.hpp/","title":"ThreadSafeQueue.hpp","text":"<pre><code>#ifndef THREADSAFEQUEUE_HPP_\n    #define THREADSAFEQUEUE_HPP_\n\n    #include &lt;queue&gt;\n    #include &lt;mutex&gt;\n    #include &lt;condition_variable&gt;\n\n    template &lt;typename T&gt;\n    class ThreadSafeQueue {\n        public:\n            void push(const T&amp; item) {\n                std::lock_guard&lt;std::mutex&gt; lock(mtx_);\n                queue_.push(item);\n                cv_.notify_one();\n            }\n\n            T pop() {\n                std::lock_guard&lt;std::mutex&gt; lock(mtx_);\n                if (queue_.empty()) {\n                    return T();\n                }\n                T item = queue_.front();\n                queue_.pop();\n                return item;\n            }\n\n            bool empty() const {\n                std::lock_guard&lt;std::mutex&gt; lock(mtx_);\n                return queue_.empty();\n            }\n\n        private:\n            std::queue&lt;T&gt; queue_;\n            mutable std::mutex mtx_;\n            std::condition_variable cv_;\n    };\n\n#endif\n</code></pre>"},{"location":"ecs/","title":"Entity Component System","text":"<p>While not a required part of the project, the Entity Component System (or ECS) is quite important. That is why it is built as a separate library</p>"},{"location":"flint/","title":"Flint","text":"<p>A custom implementation of the Flint library</p>"},{"location":"flint/#types","title":"Types","text":"Name Description Colors This class defined a good set of ANSI colors. CxxABI Wrapper around usefull C++/C low level functions Got demangle, backtrace... !!! tip This class is only made of static functions. It does not contain constructor, nor destructor This means that you don't need to instanciate it, and only use it as if it was a namespace. Exception Wrapper arround default std::exception Store the the exception description as std::string, and store some usefull localisation informations: Filename, Line, and Function Name. This is automated using the throw_exception preprocessor directive. !!! tip Take a look at the NotImplementedError to see how easy it is to implmeent your own Flint::Exception. Inspection Base class to implement simplet self-reflexion in C++  <code>T</code> :    Child class itself !!! tip When creating a child class, define as follow : <code>cpp class ChildClass: public Inspection&lt;ChildClass&gt;</code> This will extand the ChildClass with the self-reflexion class Inspection !!! warning If the class you want to extand as a reflected class will be a parent class (I.E. You will create childs of this \"target\" class), you might want to mark inheritence as virtual. This is needed if your child class also need to be reflected. This way, there is no confilict between the parent reflexion, and the child reflexion. NotImplementedError Sample Flint::Exceptions::Exception to register NotImplemented features !!! tip You should use that Exception as a C++ Implementation of the Rust todo!() macro. !!! example <code>cpp throw_exception(Flint::Exceptions::NotImplementedError, \"This function haven't been implemented as of today !\");</code>"},{"location":"flint/Colors/","title":"Colors","text":"<p>class Colors</p> <p>This class defined a good set of ANSI colors.</p> <p>Tip</p> <p>It is recomended to use those through streams : std::cout &lt;&lt; Flint::Colors::GREEN &lt;&lt; \"Hacker time\" &lt;&lt; Flint::Colors::RESET &lt;&lt; std::endl;</p> <p>Info</p> <p>Please ALWAYS remember to close your colors with Flint::Colors::RESET. Failure to do si might result in broken displays, with weird colors everywhere</p>"},{"location":"flint/CxxABI/","title":"CxxABI","text":"<p>class CxxABI</p> <p>Wrapper around usefull C++/C low level functions</p> <p>Got demangle, backtrace...</p> <p>Tip</p> <p>This class is only made of static functions. It does not contain constructor, nor destructor This means that you don't need to instanciate it, and only use it as if it was a namespace.</p>"},{"location":"flint/CxxABI/#functions","title":"Functions","text":"Name Description demangle Demangle a C++ name. getFuncInfos Get functions infos from symbol extraction  Return :    A pair with the function names demangled, and the offset from the function !!! warning The function name is not EXACTLY the real name of the function. Also, the offset DOES NOT correspond to the line number, but the offset of asm instructions getBacktrace Retreive the execution trace  Return :    Vector of pair, string&gt;. I'll explain The idea is to retrieive the file, line, and function. So that's what we do : pair or : (file, line), function !!! warning To correctly grab function names, you will need to add compilation flag \"-rdynamic\" See this lib's CMakeLists.txt for implementation. This will export ALL symbols. If NOT done, you will get offsets from binary. It's ok, but quite disgusting on output."},{"location":"flint/CxxABI/#function-details","title":"Function Details","text":""},{"location":"flint/CxxABI/#demangle","title":"demangle","text":"<p>static std::string demangle(const char* name)</p> <p>Demangle a C++ name.</p> <p>This is usefull for : Class names, backtrace...</p> Return string containing : demangled name, or original name, if demangle did not work"},{"location":"flint/CxxABI/#getfuncinfos","title":"getFuncInfos","text":"<p>static std::pair&lt;std::string, std::size_t&gt; getFuncInfos(const char* symbolInfos)</p> <p>Get functions infos from symbol extraction</p> Return A pair with the function names demangled, and the offset from the function <p>Warning</p> <p>The function name is not EXACTLY the real name of the function. Also, the offset DOES NOT correspond to the line number, but the offset of asm instructions</p>"},{"location":"flint/CxxABI/#getbacktrace","title":"getBacktrace","text":"<p>static std::vector&lt;std::pair&lt;std::string, std::size_t&gt;&gt; getBacktrace()</p> <p>Retreive the execution trace</p> Return Vector of pair, string&gt;. I'll explain <p>The idea is to retrieive the file, line, and function. So that's what we do : pair or : (file, line), function</p> <p>Warning</p> <p>To correctly grab function names, you will need to add compilation flag \"-rdynamic\" See this lib's CMakeLists.txt for implementation. This will export ALL symbols. If NOT done, you will get offsets from binary. It's ok, but quite disgusting on output.</p>"},{"location":"flint/Exception/","title":"Exception","text":"<p>class Exception: public std::exception</p> <p>Wrapper arround default std::exception</p> <p>Store the the exception description as std::string, and store some usefull localisation informations: Filename, Line, and Function Name. This is automated using the throw_exception preprocessor directive.</p> <p>Tip</p> <p>Take a look at the NotImplementedError to see how easy it is to implmeent your own Flint::Exception.</p>"},{"location":"flint/Exception/#operators","title":"Operators","text":"Name Description operator&lt;&lt; operator&lt;&lt; override !!! abstract This will simply append the _what to the ostream"},{"location":"flint/Exception/#functions","title":"Functions","text":"Name Description Exception Exception constructor. getInfos Retreive given infos (filename, line, and function name)  Return :    The actual infos getClassNameFromStackTrace Try to retreive the Exception class name from the StackTrace. show Display the error, given specific positional infos (like the constructor). what Required override, deprecated by show and catch_exception."},{"location":"flint/Exception/#operator-details","title":"Operator Details","text":""},{"location":"flint/Exception/#operator","title":"operator&lt;&lt;","text":"<p>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Exceptions::Exception&amp; obj)</p> <p>operator&lt;&lt; override</p> <p>Abstract</p> <p>This will simply append the _what to the ostream</p>"},{"location":"flint/Exception/#function-details","title":"Function Details","text":""},{"location":"flint/Exception/#exception_1","title":"Exception","text":"<p>Exception(const std::string&amp; what = \"An exception occured !\", std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; infos = {{\"\", 0}, \"\"})</p> <p>Exception constructor. This need to be called, even on child classes.</p> <code>what</code> Define the exception's description <code>infos</code> Might contain positional infos <p>Warning</p> <p>You should NOT use any excpetion constructor manually. While they might work, the prefered way is to use the throw_exception preprocessor directive. Using it will only require you to register what type of excpetion you want to throw, and what message you want to add, and will take care of putting file name, line, and function name</p>"},{"location":"flint/Exception/#getinfos","title":"getInfos","text":"<p>std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; getInfos() const</p> <p>Retreive given infos (filename, line, and function name)</p> Return The actual infos"},{"location":"flint/Exception/#getclassnamefromstacktrace","title":"getClassNameFromStackTrace","text":"<p>std::string getClassNameFromStackTrace(const std::vector&lt;std::pair&lt;std::string, std::size_t&gt;&gt;&amp; stackTrace) const</p> <p>Try to retreive the Exception class name from the StackTrace.</p> <code>stackTrace</code> A stack trace, formated like CxxABI::getBacktrace() <p>Warning</p> <p>This function DOES NOT WORK 100% OF THE TIME. It is really dependant on the environement, and can return undefined without aparent reason. It should NOT be used for anything else than debug or display.</p> Return The actual class name or \"[Class name undefined]\""},{"location":"flint/Exception/#show","title":"show","text":"<p>std::string show(std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; infos) const</p> <p>Display the error, given specific positional infos (like the constructor).</p> <code>infos</code> Positional informations, like the constructor, used to display the infos. <p>Note</p> <p>This function, while being usable without, should be used through the catch_exception preprocessor directive. This preprocessor directive let you display Python like excpetion trace.</p> Return The formated exception, ready to be displayed."},{"location":"flint/Exception/#what","title":"what","text":"<p>const char* what() const noexcept override</p> <p>Required override, deprecated by show and catch_exception.</p> <p>Info</p> <p>This is the required std::exception override. It'll return the _what as a const char*. While this will work, prefer using the show function or the catch_excpetion preprocessor directive :</p> <p>Example</p> <pre><code>try {\n    throw_exception(Flint::Exceptions::Exception, \"Sample testing exception\");\n} catch (const Flint::Exceptions::Exception&amp; e) {\n    std::cerr &lt;&lt; catch_exception(e) &lt;&lt; std::endl;\n}\n</code></pre> Return The _what as a C string"},{"location":"flint/Inspection/","title":"Inspection","text":"<p>template &lt;typename T&gt; class Inspection</p> <p>Base class to implement simplet self-reflexion in C++</p> <code>T</code> Child class itself <p>Tip</p> <p>When creating a child class, define as follow : <pre><code>class ChildClass: public Inspection&lt;ChildClass&gt;\n</code></pre> This will extand the ChildClass with the self-reflexion class Inspection</p> <p>Warning</p> <p>If the class you want to extand as a reflected class will be a parent class (I.E. You will create childs of this \"target\" class), you might want to mark inheritence as virtual. This is needed if your child class also need to be reflected. This way, there is no confilict between the parent reflexion, and the child reflexion.</p>"},{"location":"flint/Inspection/#operators","title":"Operators","text":"Name Description operator&lt;&lt; Overload the operator &lt;&lt; to use the str method of the object  <code>T</code> :    Reflected class  <code>os</code> :    Reference of ostream (I.E. std::cout, std::cerr...)  <code>obj</code> :    Object reference to be displayed  Return :    Param os"},{"location":"flint/Inspection/#functions","title":"Functions","text":"Name Description getClassName Return the name of the reflected class  Return :    The demangled name of the class, or just the name, if demangleing failed str Return a string representation of the class !!! tip This function is not intended to be used. This is because this functions display the reflection. You might prefer to override this function in yout child class to display informations that are more relevant to your specific class. !!! example You have a Macro available to make the str function really easilly : <code>cpp display_attr(attribute)</code> Which will automaticly translate to <code>cpp Flint::Colors::F_BLUE &lt;&lt; \"attribute\" &lt;&lt; Flint::Colors::RESET &lt;&lt; \"=\" &lt;&lt; Flint::Colors::RED &lt;&lt; this-&gt;attribute &lt;&lt; Flint::Colors::RESET</code> There is also a <code>make_str</code> macro, which you can use as follow : <code>cpp return make_str(\"a=12\" &lt;&lt; \", \" &lt;&lt; \"b=5\");</code> that becomes <code>cpp return ({std::stringstream ss; ss &lt;&lt; \"&lt;\" &lt;&lt; this-&gt;getClassName() &lt;&lt; \" at \" &lt;&lt; std::hex &lt;&lt; this &lt;&lt; \": \" &lt;&lt; \"a=12\" &lt;&lt; \", \" &lt;&lt; \"b=5\" &lt;&lt; \"&gt;\"; ss.str()})</code> It means you can define the str function of your class as like that : <code>cpp // Provided you have 3 attributes called a, b and c return make_str(display_attr(a) &lt;&lt; \", \" &lt;&lt; display_attr(b) &lt;&lt; \", \" &lt;&lt; display_attr(c));</code> Return :    The string representation of the class"},{"location":"flint/Inspection/#operator-details","title":"Operator Details","text":""},{"location":"flint/Inspection/#operator","title":"operator&lt;&lt;","text":"<p>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Inspection&lt;T&gt;&amp; obj)</p> <p>Overload the operator &lt;&lt; to use the str method of the object</p> <code>T</code> Reflected class <code>os</code> Reference of ostream (I.E. std::cout, std::cerr...) <code>obj</code> Object reference to be displayed Return Param os"},{"location":"flint/Inspection/#function-details","title":"Function Details","text":""},{"location":"flint/Inspection/#getclassname","title":"getClassName","text":"<p>virtual std::string getClassName() const final</p> <p>Return the name of the reflected class</p> Return The demangled name of the class, or just the name, if demangleing failed"},{"location":"flint/Inspection/#str","title":"str","text":"<p>virtual std::string str() const</p> <p>Return a string representation of the class</p> <p>Tip</p> <p>This function is not intended to be used. This is because this functions display the reflection. You might prefer to override this function in yout child class to display informations that are more relevant to your specific class.</p> <p>Example</p> <p>You have a Macro available to make the str function really easilly : <pre><code>display_attr(attribute)\n</code></pre> Which will automaticly translate to <pre><code>Flint::Colors::F_BLUE &lt;&lt; \"attribute\" &lt;&lt; Flint::Colors::RESET &lt;&lt; \"=\" &lt;&lt; Flint::Colors::RED &lt;&lt; this-&gt;attribute &lt;&lt; Flint::Colors::RESET\n</code></pre> There is also a <code>make_str</code> macro, which you can use as follow : <pre><code>return make_str(\"a=12\" &lt;&lt; \", \" &lt;&lt; \"b=5\");\n</code></pre> that becomes <pre><code>return ({std::stringstream ss; ss &lt;&lt; \"&lt;\" &lt;&lt; this-&gt;getClassName() &lt;&lt; \" at \" &lt;&lt; std::hex &lt;&lt; this &lt;&lt; \": \" &lt;&lt; \"a=12\" &lt;&lt; \", \" &lt;&lt; \"b=5\" &lt;&lt; \"&gt;\"; ss.str()})\n</code></pre> It means you can define the str function of your class as like that : <pre><code>// Provided you have 3 attributes called a, b and c\nreturn make_str(display_attr(a) &lt;&lt; \", \" &lt;&lt; display_attr(b) &lt;&lt; \", \" &lt;&lt; display_attr(c));\n</code></pre></p> Return The string representation of the class"},{"location":"flint/NotImplementedError/","title":"NotImplementedError","text":"<p>class NotImplementedError: public Flint::Exceptions::Exception</p> <p>Sample Flint::Exceptions::Exception to register NotImplemented features</p> <p>Tip</p> <p>You should use that Exception as a C++ Implementation of the Rust todo!() macro.</p> <p>Example</p> <pre><code>throw_exception(Flint::Exceptions::NotImplementedError, \"This function haven't been implemented as of today !\");\n</code></pre>"},{"location":"network/","title":"Network","text":"<p>Custom classes handeling all the networking. This allows you to create your own network wrapper (Hell, you could play through HTTP WebSockets if you want ! (Don't do that please)).</p>"},{"location":"server/","title":"Server","text":"<p>As important as all of the other parts (if not more), the server is the masterchief of the orchestra. It connect all players, and handle all the game logic.</p>"}]}