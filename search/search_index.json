{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"RType","text":"<p>A GAME ENGINE THAT ROARS !</p> RType Client Client side part of the RType project. Entity Component System While not a required part of the project, the Entity Component System (or ECS) is quite important. Flint A custom implementation of the Flint library Network Custom classes handeling all the networking. Server As important as all of the other parts (if not more), the server is the masterchief of the orchestra. Client ECS Network Server <p> Code Coverage</p>"},{"location":"#types","title":"Types","text":"Name Description ComponentStorageBase ComponentStorage Interface ComponentStorage Stores all of the components of a same type wrapped in a std::shared_ptr  <code>Component</code> :    Struct of the component."},{"location":"ComponentStorage/","title":"ComponentStorage","text":"<p>template &lt;typename Component&gt; class ComponentStorage : public ComponentStorageBase</p> <p>Stores all of the components of a same type wrapped in a std::shared_ptr</p> <code>Component</code> Struct of the component."},{"location":"ComponentStorage/#functions","title":"Functions","text":"Name Description get Get component wrapped in a std::optional  <code>id</code> :    Entity ID. add Add a component for an entity  <code>id</code> :    Entity ID. remove Remove component from an entity  <code>id</code> :    Entity ID."},{"location":"ComponentStorage/#function-details","title":"Function Details","text":""},{"location":"ComponentStorage/#add","title":"add","text":"<p>void add(ECS::entity_id id, std::shared_ptr&lt;Component&gt; component)</p> <p>Add a component for an entity</p> <code>id</code> Entity ID."},{"location":"ComponentStorage/#get","title":"get","text":"<p>std::optional&lt;std::shared_ptr&lt;Component&gt;&gt; get(ECS::entity_id id)</p> <p>Get component wrapped in a std::optional</p> <code>id</code> Entity ID."},{"location":"ComponentStorage/#remove","title":"remove","text":"<p>void remove(ECS::entity_id id)</p> <p>Remove component from an entity</p> <code>id</code> Entity ID."},{"location":"ComponentStorageBase/","title":"ComponentStorageBase","text":"<p>class ComponentStorageBase</p> <p>ComponentStorage Interface</p>"},{"location":"Client/","title":"Client","text":""},{"location":"Client/#types","title":"Types","text":"Name Description Commands Handles the commands of the client Handles and manage all client commands Core Handles the core loop of the client Handles the ECSManager and the connection to the server in one thread."},{"location":"Client/Commands/","title":"Commands","text":"<p>class Commands</p> <p>Handles the commands of the client Handles and manage all client commands</p>"},{"location":"Client/Commands/#functions","title":"Functions","text":"Name Description startCMD Handles the \"start\" command It switches to the game world in the ECSManager ad spawns the players endCMD Handles the \"end\" command It switches back to the title screen and cleans all entities in the game world placeCMD Handles the \"place\" command Creates entity prefabs and places them in the correct position playerCMD Handles the \"player\" command Places the correct player at the x and y positions provided by the server playerDeadCMD Handles the \"playerDead\" command It deletes the player game object and spawns an explosion animation bulletHitCMD Handles the \"bulletHit\" command spawns an explosion at the impact ennemyDeadCMD Handles the \"start\" command Spawns an explosion at the enemy's position"},{"location":"Client/Commands/#function-details","title":"Function Details","text":""},{"location":"Client/Commands/#bullethitcmd","title":"bulletHitCMD","text":"<p>static void bulletHitCMD(Core&amp; core, std::vector&lt;std::string&gt; args)</p> <p>Handles the \"bulletHit\" command spawns an explosion at the impact</p>"},{"location":"Client/Commands/#endcmd","title":"endCMD","text":"<p>static void endCMD(Core&amp; core, std::vector&lt;std::string&gt; args)</p> <p>Handles the \"end\" command It switches back to the title screen and cleans all entities in the game world</p>"},{"location":"Client/Commands/#ennemydeadcmd","title":"ennemyDeadCMD","text":"<p>static void ennemyDeadCMD(Core&amp; core, std::vector&lt;std::string&gt; args)</p> <p>Handles the \"start\" command Spawns an explosion at the enemy's position</p>"},{"location":"Client/Commands/#placecmd","title":"placeCMD","text":"<p>static void placeCMD(Core&amp; core, std::vector&lt;std::string&gt; args)</p> <p>Handles the \"place\" command Creates entity prefabs and places them in the correct position</p>"},{"location":"Client/Commands/#playercmd","title":"playerCMD","text":"<p>static void playerCMD(Core&amp; core, std::vector&lt;std::string&gt; args)</p> <p>Handles the \"player\" command Places the correct player at the x and y positions provided by the server</p>"},{"location":"Client/Commands/#playerdeadcmd","title":"playerDeadCMD","text":"<p>static void playerDeadCMD(Core&amp; core, std::vector&lt;std::string&gt; args)</p> <p>Handles the \"playerDead\" command It deletes the player game object and spawns an explosion animation</p>"},{"location":"Client/Commands/#startcmd","title":"startCMD","text":"<p>static void startCMD(Core&amp; core, std::vector&lt;std::string&gt; args)</p> <p>Handles the \"start\" command It switches to the game world in the ECSManager ad spawns the players</p>"},{"location":"Client/Core/","title":"Core","text":"<p>class Core</p> <p>Handles the core loop of the client Handles the ECSManager and the connection to the server in one thread.</p>"},{"location":"Client/Core/#functions","title":"Functions","text":"Name Description run Run the client's loop handleEvent Handles the window's event like button press. handleServerMessage Checks the message sent by the server and executes the correct CMD method  <code>message</code> :    Message sent by the server hideNonUpdatedElements Removes all ECS elements that were not updated by the server this frame createPlayers Creates X number of player entities in the ECS based on the server's \"start\" command  <code>nbrPlayers</code> :    Number of players this game"},{"location":"Client/Core/#function-details","title":"Function Details","text":""},{"location":"Client/Core/#createplayers","title":"createPlayers","text":"<p>void createPlayers(int nbrPlayers)</p> <p>Creates X number of player entities in the ECS based on the server's \"start\" command</p> <code>nbrPlayers</code> Number of players this game"},{"location":"Client/Core/#handleevent","title":"handleEvent","text":"<p>void handleEvent()</p> <p>Handles the window's event like button press.</p>"},{"location":"Client/Core/#handleservermessage","title":"handleServerMessage","text":"<p>void handleServerMessage(std::string message)</p> <p>Checks the message sent by the server and executes the correct CMD method</p> <code>message</code> Message sent by the server"},{"location":"Client/Core/#hidenonupdatedelements","title":"hideNonUpdatedElements","text":"<p>void hideNonUpdatedElements()</p> <p>Removes all ECS elements that were not updated by the server this frame</p>"},{"location":"Client/Core/#run","title":"run","text":"<p>void run()</p> <p>Run the client's loop</p>"},{"location":"ECS/","title":"ECS","text":"Component"},{"location":"ECS/#types","title":"Types","text":"Name Description AScript Default abstract of IScript, only global functions are defined. AudioManager This class loads the audios from the asset directory All of the ressource's key names correspond to the name of their files in the asset directory. ComponentManager Stores and Manages all of the components of all entities currently existing The template \"Component\" corresponds to all of the structs avaliable in Components.hpp EntityManager GlobalDataManager Responsible for storing and sending global variables to allow communication between scripts The variables can be of any type IAudio The interface for Audio assets used in the engine The abstraction has to use it's own methods to make the asset work. ICamera The interface for the Camera used in the engine The abstraction has to use it's own methods to make the camera work. IDrawable The interface for Drawable assets used in the engine The abstraction has to use it's own methods to make the asset work. IDrawableText The interface for Drawable text assets used in the engine The abstraction has to use its own methods to make the text work. IScript Interface for script classes ISystem The interface for the Camera used in the engine The abstraction has to use it's own methods to make the camera work. IWindow The interface for the window used in the engine It is both responsible for window management as well as input management The abstraction has to use it's own methods to make the window work. Key This is the enumeration of all the key inputs scancodes used by the engine The input check is handled my the window abstraction PrefabManager This class loads the prefabs from the asset directory All of the ressource's key names correspond to the name of their files in the asset directory. Rect2D This class defines a standardisation for rect in the game engine. Registry Mediator that wraps Component and Entity manager, this should be where you manipulate a world's content. ScriptManager This class loads the scripts from the asset directory All of the resource's key names correspond to the name of their files in the asset directory. SpriteManager This class loads the sprites from the asset directory All of the ressource's key names correspond to the name of their files in the asset directory. SystemManager Responsible for running and adding systems that are active during the execution It also keeps track of the deltaTime between frames Vector2D This class defines a standardisation for vectors in the game engine."},{"location":"ECS/AScript/","title":"AScript","text":"<p>class AScript : public ECS::IScript</p> <p>Default abstract of IScript, only global functions are defined.</p> <p>This script's methods will be called by the engine in specific moments, they cannot be called elsewhere</p> <p>Classes that inherit from this (the scripts you will create) can have their own private variables or component pointers (see example scripts in the ScriptSource folder for example)</p> <code>Game</code> Pointer to access the engine class's content <code>_selfID</code> ID of the script's entity"},{"location":"ECS/AScript/#functions","title":"Functions","text":"Name Description onStart Called on Entity's first frame of existence, usefull for getting all components once onUpdate Called every frame onCollision Called when an entity collides with another, they need a hitbox component to be activatable  <code>id</code> :    ID of the entity who collided the script's owner onClick Called when mouse clicks on the entity, they need to have an hitbox onEvent Can be called by other scripts to do an action based on name of the event onEnterCamera Called when an entity enters the camera onExitCamera Called when an entity exits the camera setEcsManager Called when Script is assigned to an entity so that they can manipulate the engine  <code>ecsManager</code> :    Pointer to ECSManager Class (the engine). setEntityID Defines the script's user ID  <code>id</code> :    Entity ID. spawnPrefabAt Automatically spawn a prefab at (x, y), useful for spawning decor or temporary animation elements !!! warning NOT RECOMMENDED, MODIFYING ENTITIES CREATED BY THIS METHOD MAY CAUSE CRASH  <code>prefabName</code> :    Prefab name.  <code>x</code> :    X position  <code>y</code> :    Y position"},{"location":"ECS/AScript/#function-details","title":"Function Details","text":""},{"location":"ECS/AScript/#onclick","title":"onClick","text":"<p>void onClick()</p> <p>Called when mouse clicks on the entity, they need to have an hitbox</p>"},{"location":"ECS/AScript/#oncollision","title":"onCollision","text":"<p>void onCollision(ECS::entity_id id)</p> <p>Called when an entity collides with another, they need a hitbox component to be activatable</p> <code>id</code> ID of the entity who collided the script's owner"},{"location":"ECS/AScript/#onentercamera","title":"onEnterCamera","text":"<p>void onEnterCamera()</p> <p>Called when an entity enters the camera</p>"},{"location":"ECS/AScript/#onevent","title":"onEvent","text":"<p>void onEvent(std::string event) {}</p> <p>Can be called by other scripts to do an action based on name of the event</p>"},{"location":"ECS/AScript/#onexitcamera","title":"onExitCamera","text":"<p>void onExitCamera()</p> <p>Called when an entity exits the camera</p>"},{"location":"ECS/AScript/#onstart","title":"onStart","text":"<p>void onStart()</p> <p>Called on Entity's first frame of existence, usefull for getting all components once</p>"},{"location":"ECS/AScript/#onupdate","title":"onUpdate","text":"<p>void onUpdate()</p> <p>Called every frame</p>"},{"location":"ECS/AScript/#setecsmanager","title":"setEcsManager","text":"<p>bool setEcsManager(ECS::ECSManager* ecsManager)</p> <p>Called when Script is assigned to an entity so that they can manipulate the engine</p> <code>ecsManager</code> Pointer to ECSManager Class (the engine)."},{"location":"ECS/AScript/#setentityid","title":"setEntityID","text":"<p>void setEntityID(ECS::entity_id id)</p> <p>Defines the script's user ID</p> <code>id</code> Entity ID."},{"location":"ECS/AScript/#spawnprefabat","title":"spawnPrefabAt","text":"<p>ECS::entity_id spawnPrefabAt(std::string prefabName, int x, int y)</p> <p>Automatically spawn a prefab at (x, y), useful for spawning decor or temporary animation elements</p> <p>Warning</p> <p>NOT RECOMMENDED, MODIFYING ENTITIES CREATED BY THIS METHOD MAY CAUSE CRASH</p> <code>prefabName</code> Prefab name. <code>x</code> X position <code>y</code> Y position"},{"location":"ECS/AudioManager/","title":"AudioManager","text":"<p>class AudioManager</p> <p>This class loads the audios from the asset directory All of the ressource's key names correspond to the name of their files in the asset directory.</p> <p>The asset directory's structure cannot be modified</p>"},{"location":"ECS/AudioManager/#functions","title":"Functions","text":"Name Description getAudio Returns a audio, returns an empty one if not found  <code>key</code> :    name of the audio  Return :    Audio"},{"location":"ECS/AudioManager/#function-details","title":"Function Details","text":""},{"location":"ECS/AudioManager/#getaudio","title":"getAudio","text":"<p>std::shared_ptr&lt;ECS::IAudio&gt; getAudio(const std::string&amp; key)</p> <p>Returns a audio, returns an empty one if not found</p> <code>key</code> name of the audio Return Audio"},{"location":"ECS/ComponentManager/","title":"ComponentManager","text":"<p>class ComponentManager</p> <p>Stores and Manages all of the components of all entities currently existing The template \"Component\" corresponds to all of the structs avaliable in Components.hpp</p>"},{"location":"ECS/ComponentManager/#functions","title":"Functions","text":"Name Description addComponent Add a component to an entity in the current world  <code>id</code> :    Entity ID  <code>Component</code> :    Component's struct which's values are setup or not removeComponent Remove a component from an entity in the current world  <code>id</code> :    Entity ID  <code>Component</code> :    Component's struct !!! warning It should be called like this: removeComponent(id) removeAllComponents Remove all of the components from an entity  <code>id</code> :    Entity ID getComponent Get a component from an entity in the current world, you can then modify the shared_ptr component to directly modify it's information inside the entity, no need to re-add it  <code>id</code> :    Entity ID  <code>Component</code> :    Component's struct !!! warning It should be called like this: getComponent(id)  Return :    Entity's component wrapped in a shared_ptr getEntitiesWithComponent Returns a list of all the entities that have a component type, usefull when you create a System or want to know only certain entities to increase performance  <code>Component</code> :    Component's struct !!! warning It should be called like this: getEntitiesWithComponent() getComponentStorage Returns the component storage of a component type  <code>Component</code> :    Component's struct !!! warning It should be called like this: getComponentStorage(id)  Return :    Entity's component Storage"},{"location":"ECS/ComponentManager/#function-details","title":"Function Details","text":""},{"location":"ECS/ComponentManager/#addcomponent","title":"addComponent","text":"<p>template &lt;typename Component&gt; void addComponent(ECS::entity_id id, Component component)</p> <p>Add a component to an entity in the current world</p> <code>id</code> Entity ID <code>Component</code> Component's struct which's values are setup or not"},{"location":"ECS/ComponentManager/#getcomponent","title":"getComponent","text":"<p>template &lt;typename Component&gt; std::optional&lt;std::shared_ptr&lt;Component&gt;&gt; getComponent(ECS::entity_id id)</p> <p>Get a component from an entity in the current world, you can then modify the shared_ptr component to directly modify it's information inside the entity, no need to re-add it</p> <code>id</code> Entity ID <code>Component</code> Component's struct <p>Warning</p> <p>It should be called like this: getComponent(id) Return Entity's component wrapped in a shared_ptr"},{"location":"ECS/ComponentManager/#getcomponentstorage","title":"getComponentStorage","text":"<p>template &lt;typename Component&gt; ComponentStorage&lt;Component&gt;&amp; getComponentStorage()</p> <p>Returns the component storage of a component type</p> <code>Component</code> Component's struct <p>Warning</p> <p>It should be called like this: getComponentStorage(id) Return Entity's component Storage"},{"location":"ECS/ComponentManager/#getentitieswithcomponent","title":"getEntitiesWithComponent","text":"<p>template &lt;typename Component&gt; std::vector&lt;ECS::entity_id&gt; getEntitiesWithComponent()</p> <p>Returns a list of all the entities that have a component type, usefull when you create a System or want to know only certain entities to increase performance</p> <code>Component</code> Component's struct <p>Warning</p> <p>It should be called like this: getEntitiesWithComponent()"},{"location":"ECS/ComponentManager/#removeallcomponents","title":"removeAllComponents","text":"<p>void removeAllComponents(ECS::entity_id id)</p> <p>Remove all of the components from an entity</p> <code>id</code> Entity ID"},{"location":"ECS/ComponentManager/#removecomponent","title":"removeComponent","text":"<p>template &lt;typename Component&gt; void removeComponent(ECS::entity_id id)</p> <p>Remove a component from an entity in the current world</p> <code>id</code> Entity ID <code>Component</code> Component's struct <p>Warning</p> <p>It should be called like this: removeComponent(id)"},{"location":"ECS/EntityManager/","title":"EntityManager","text":"<p>class EntityManager</p>"},{"location":"ECS/EntityManager/#functions","title":"Functions","text":"Name Description createEntity Create an empty entity in the current world  Return :    Created entity ID destroyEntity Destroy an entity in the current world  <code>id</code> :    ID of the entity to destroy getAllEntities Returns all of the entities in the registry  Return :    List of all entities"},{"location":"ECS/EntityManager/#function-details","title":"Function Details","text":""},{"location":"ECS/EntityManager/#createentity","title":"createEntity","text":"<p>const entity_id &amp;createEntity()</p> <p>Create an empty entity in the current world</p> Return Created entity ID"},{"location":"ECS/EntityManager/#destroyentity","title":"destroyEntity","text":"<p>void destroyEntity(const entity_id &amp;id)</p> <p>Destroy an entity in the current world</p> <code>id</code> ID of the entity to destroy"},{"location":"ECS/EntityManager/#getallentities","title":"getAllEntities","text":"<p>std::vector&lt;entity_id&gt; getAllEntities()</p> <p>Returns all of the entities in the registry</p> Return List of all entities"},{"location":"ECS/GlobalDataManager/","title":"GlobalDataManager","text":"<p>class GlobalDataManager</p> <p>Responsible for storing and sending global variables to allow communication between scripts</p> <p>The variables can be of any type</p>"},{"location":"ECS/GlobalDataManager/#functions","title":"Functions","text":"Name Description set Sets a variable of any type at an index  <code>Variable</code> :    type !!! warning It should be called like this: set(index, value) get Returns a variable of any type at an index  <code>Variable</code> :    type !!! warning It should be called like this: get(index)  Return :    Variable of type VariableType"},{"location":"ECS/GlobalDataManager/#function-details","title":"Function Details","text":""},{"location":"ECS/GlobalDataManager/#get","title":"get","text":"<p>template &lt;typename T&gt; T get(const std::string &amp;index)</p> <p>Returns a variable of any type at an index</p> <code>Variable</code> type <p>Warning</p> <p>It should be called like this: get(index) Return Variable of type VariableType"},{"location":"ECS/GlobalDataManager/#set","title":"set","text":"<p>template &lt;typename T&gt; void set(const std::string &amp;index, const T&amp; value)</p> <p>Sets a variable of any type at an index</p> <code>Variable</code> type <p>Warning</p> <p>It should be called like this: set(index, value)"},{"location":"ECS/IAudio/","title":"IAudio","text":"<p>class IAudio</p> <p>The interface for Audio assets used in the engine</p> <p>The abstraction has to use it's own methods to make the asset work.</p>"},{"location":"ECS/ICamera/","title":"ICamera","text":"<p>class ICamera</p> <p>The interface for the Camera used in the engine</p> <p>The abstraction has to use it's own methods to make the camera work. The abstraction of this interface will be managed by the Window abstraction.</p>"},{"location":"ECS/IDrawable/","title":"IDrawable","text":"<p>class IDrawable</p> <p>The interface for Drawable assets used in the engine</p> <p>The abstraction has to use it's own methods to make the asset work.</p>"},{"location":"ECS/IDrawableText/","title":"IDrawableText","text":"<p>class IDrawableText</p> <p>The interface for Drawable text assets used in the engine</p> <p>The abstraction has to use its own methods to make the text work.</p>"},{"location":"ECS/IScript/","title":"IScript","text":"<p>class IScript</p> <p>Interface for script classes</p>"},{"location":"ECS/ISystem/","title":"ISystem","text":"<p>class ISystem</p> <p>The interface for the Camera used in the engine</p> <p>The abstraction has to use it's own methods to make the camera work. The abstraction of this interface will be managed by the Window abstraction.</p>"},{"location":"ECS/IWindow/","title":"IWindow","text":"<p>class IWindow</p> <p>The interface for the window used in the engine It is both responsible for window management as well as input management</p> <p>The abstraction has to use it's own methods to make the window work.</p>"},{"location":"ECS/Key/","title":"Key","text":"<p>enum Key</p> <p>This is the enumeration of all the key inputs scancodes used by the engine The input check is handled my the window abstraction</p> Unknown = -1 Unhandled key A = 0 The A key B The B key C The C key D The D key E The E key F The F key G The G key H The H key I The I key J The J key K The K key L The L key M The M key N The N key O The O key P The P key Q The Q key R The R key S The S key T The T key U The U key V The V key W The W key X The X key Y The Y key Z The Z key Num0 The 0 key Num1 The 1 key Num2 The 2 key Num3 The 3 key Num4 The 4 key Num5 The 5 key Num6 The 6 key Num7 The 7 key Num8 The 8 key Num9 The 9 key Escape The Escape key LControl The left Control key LShift The left Shift key LAlt The left Alt key LSystem The left OS specific key: window (Windows and Linux), apple (macOS), ... RControl The right Control key RShift The right Shift key RAlt The right Alt key RSystem The right OS specific key: window (Windows and Linux), apple (macOS), ... Menu The Menu key LBracket The [ key RBracket The ] key Semicolon The ; key Comma The , key Period The . key Apostrophe The ' key Slash The / key Backslash The \\ key Grave The ` key Equal The = key Hyphen The - key (hyphen) Space The Space key Enter The Enter/Return keys Backspace The Backspace key Tab The Tabulation key PageUp The Page up key PageDown The Page down key End The End key Home The Home key Insert The Insert key Delete The Delete key Add The + key Subtract The - key (minus, usually from numpad) Multiply The * key Divide The / key Left Left arrow Right Right arrow Up Up arrow Down Down arrow Numpad0 The numpad 0 key Numpad1 The numpad 1 key Numpad2 The numpad 2 key Numpad3 The numpad 3 key Numpad4 The numpad 4 key Numpad5 The numpad 5 key Numpad6 The numpad 6 key Numpad7 The numpad 7 key Numpad8 The numpad 8 key Numpad9 The numpad 9 key F1 The F1 key F2 The F2 key F3 The F3 key F4 The F4 key F5 The F5 key F6 The F6 key F7 The F7 key F8 The F8 key F9 The F9 key F10 The F10 key F11 The F11 key F12 The F12 key F13 The F13 key F14 The F14 key F15 The F15 key Pause The Pause key KeyCount Keep last -- the total number of keyboard keys Tilde     = Grave \\deprecated Use Grave instead Dash      = Hyphen \\deprecated Use Hyphen instead BackSpace = Backspace \\deprecated Use Backspace instead BackSlash = Backslash \\deprecated Use Backslash instead SemiColon = Semicolon \\deprecated Use Semicolon instead Return    = Enter \\deprecated Use Enter instead Quote     = Apostrophe \\deprecated Use Apostrophe instead"},{"location":"ECS/PrefabManager/","title":"PrefabManager","text":"<p>class PrefabManager</p> <p>This class loads the prefabs from the asset directory All of the ressource's key names correspond to the name of their files in the asset directory.</p> <p>The asset directory's structure cannot be modified</p>"},{"location":"ECS/PrefabManager/#functions","title":"Functions","text":"Name Description getPrefab Returns a prefab's json configuration, returns an empty one if not found  <code>key</code> :    name of the prefab  Return :    Prefab's configuration !!! warning This function should not necessarily be used as the engine already uses it in it's regular methods. for any prefab call, refer to script's methods or ECSManager's methods"},{"location":"ECS/PrefabManager/#function-details","title":"Function Details","text":""},{"location":"ECS/PrefabManager/#getprefab","title":"getPrefab","text":"<p>const nlohmann::json&amp; getPrefab(const std::string&amp; key) const</p> <p>Returns a prefab's json configuration, returns an empty one if not found</p> <code>key</code> name of the prefab Return Prefab's configuration <p>Warning</p> <p>This function should not necessarily be used as the engine already uses it in it's     regular methods. for any prefab call, refer to script's methods or ECSManager's methods</p>"},{"location":"ECS/Rect2D/","title":"Rect2D","text":"<p>template &lt;typename T&gt; class Rect2D</p> <p>This class defines a standardisation for rect in the game engine. The abstractions of the interfaces have to adapt their values to it</p> <code>type</code> of the stored values"},{"location":"ECS/Rect2D/#functions","title":"Functions","text":"Name Description contains Checks if a point is inside the rect  <code>px</code> :    X position  <code>py</code> :    Y position  Return :    True if there is a collision intersects Checks if a rect intersects with another rect  <code>other</code> :    rect to check the intersection  Return :    True if there is an intersection"},{"location":"ECS/Rect2D/#function-details","title":"Function Details","text":""},{"location":"ECS/Rect2D/#contains","title":"contains","text":"<p>bool contains(T px, T py) const</p> <p>Checks if a point is inside the rect</p> <code>px</code> X position <code>py</code> Y position Return True if there is a collision"},{"location":"ECS/Rect2D/#intersects","title":"intersects","text":"<p>bool intersects(const Rect2D&amp; other) const</p> <p>Checks if a rect intersects with another rect</p> <code>other</code> rect to check the intersection Return True if there is an intersection"},{"location":"ECS/Registry/","title":"Registry","text":"<p>class Registry</p> <p>Mediator that wraps Component and Entity manager, this should be where you manipulate a world's content. It also contains all the entities of the world.</p>"},{"location":"ECS/ScriptManager/","title":"ScriptManager","text":"<p>class ScriptManager</p> <p>This class loads the scripts from the asset directory All of the resource's key names correspond to the name of their files in the asset directory.</p> <p>The asset directory's structure cannot be modified.</p>"},{"location":"ECS/ScriptManager/#functions","title":"Functions","text":"Name Description getScript Returns a script wrapped in a shared_ptr, returns nullptr if not found."},{"location":"ECS/ScriptManager/#function-details","title":"Function Details","text":""},{"location":"ECS/ScriptManager/#getscript","title":"getScript","text":"<p>std::shared_ptr&lt;ECS::IScript&gt; getScript(const std::string &amp;key)</p> <p>Returns a script wrapped in a shared_ptr, returns nullptr if not found.</p> <code>key</code> name of the script Return Script <p>Warning</p> <p>This function should not necessarily be used as the engine already uses it in its     regular methods. For any prefab call, refer to script's methods or ECSManager's methods.</p>"},{"location":"ECS/SpriteManager/","title":"SpriteManager","text":"<p>class SpriteManager</p> <p>This class loads the sprites from the asset directory All of the ressource's key names correspond to the name of their files in the asset directory.</p> <p>The asset directory's structure cannot be modified</p>"},{"location":"ECS/SpriteManager/#functions","title":"Functions","text":"Name Description getSprite Returns a sprite, returns an empty one if not found  <code>key</code> :    name of the sprite  Return :    Sprite"},{"location":"ECS/SpriteManager/#function-details","title":"Function Details","text":""},{"location":"ECS/SpriteManager/#getsprite","title":"getSprite","text":"<p>std::shared_ptr&lt;ECS::IDrawable&gt; getSprite(const std::string&amp; key)</p> <p>Returns a sprite, returns an empty one if not found</p> <code>key</code> name of the sprite Return Sprite"},{"location":"ECS/SystemManager/","title":"SystemManager","text":"<p>class SystemManager</p> <p>Responsible for running and adding systems that are active during the execution It also keeps track of the deltaTime between frames</p>"},{"location":"ECS/Vector2D/","title":"Vector2D","text":"<p>template &lt;typename T&gt; class Vector2D</p> <p>This class defines a standardisation for vectors in the game engine. The abstractions of the interfaces have to adapt their values to it</p>"},{"location":"ECS/Vector2D/#functions","title":"Functions","text":"Name Description dot Computes the dot of two vectors  <code>other</code> :    vector to compute with  Return :    The computed vector magnitude Computes the magnitude of two vectors  <code>other</code> :    vector to compute with  Return :    The computed vector normalize Returns the normalised vector  Return :    The normalised vector"},{"location":"ECS/Vector2D/#function-details","title":"Function Details","text":""},{"location":"ECS/Vector2D/#dot","title":"dot","text":"<p>T dot(const Vector2D&amp; other) const</p> <p>Computes the dot of two vectors</p> <code>other</code> vector to compute with Return The computed vector"},{"location":"ECS/Vector2D/#magnitude","title":"magnitude","text":"<p>T magnitude() const</p> <p>Computes the magnitude of two vectors</p> <code>other</code> vector to compute with Return The computed vector"},{"location":"ECS/Vector2D/#normalize","title":"normalize","text":"<p>Vector2D normalize() const</p> <p>Returns the normalised vector</p> Return The normalised vector"},{"location":"ECS/Component/","title":"Component","text":""},{"location":"ECS/Component/#types","title":"Types","text":"Name Description Acceleration Acceleration of entity  <code>x</code> :    X acceleration.  <code>y</code> :    Y acceleration. Animation Animation rect of entity  <code>rect</code> :    Frame for sprite.  <code>fps</code> :    Frame per second.  <code>destroyAtEnt</code> :    If true, the entity will automatically be destroyed at the end of the animation, perfect for particles Drawable Visual for entity  <code>sprite</code> :    Sprite.  <code>center</code> :    If true, the sprite will be centered based on it's position DrawableText Displayable text on the screen  <code>text</code> :    Text  <code>size</code> :    Size of the text  <code>center</code> :    If true, the sprite will be centered based on it's position Health Health information for component  <code>health</code> :    Health value Hitbox Rectangle box for collisions/zone/etc...  <code>x</code> :    X outset.  <code>y</code> :    Y outset.  <code>w</code> :    width.  <code>h</code> :    height. Parallax Parallax movement for entity  <code>speed</code> :    Speed of parallax, goes backwards if negative value. !!! warning Float values can sometimes not work, for onsistency, only use int values Position Position inside world space  <code>x</code> :    X position.  <code>y</code> :    Y position. RigidBody Physics information for component  <code>gravityScale</code> :    impact scale of the gravity  <code>mass</code> :    mass of the object  <code>bounce</code> :    defines if the entity acts like a wall for other entities Script Scripting on entity  <code>name</code> :    Script name. SpriteSheet Spritesheet info for selecting Sprite part on One line  <code>nbrOfState</code> :    nbr of different states avaliable.  <code>state</code> :    state selected. !!! warning THIS COMPONENT IS NOT IMPLEMENTED OR FUNCTIONAL State State value usable for StateMachine or simply indicating a state  <code>name</code> :    State name. Tag Tag value usable for entity labeling/categorisation Usefull for entity differentiation when colliding for example  <code>name</code> :    State name. Velocity Velocity of entity  <code>x</code> :    X speed.  <code>y</code> :    Y speed."},{"location":"ECS/Component/Acceleration/","title":"Acceleration","text":"<p>struct Acceleration</p> <p>Acceleration of entity</p> <code>x</code> X acceleration. <code>y</code> Y acceleration."},{"location":"ECS/Component/Animation/","title":"Animation","text":"<p>struct Animation</p> <p>Animation rect of entity</p> <code>rect</code> Frame for sprite. <code>fps</code> Frame per second. <code>destroyAtEnt</code> If true, the entity will automatically be destroyed at the end of the animation, perfect for particles"},{"location":"ECS/Component/Drawable/","title":"Drawable","text":"<p>struct Drawable</p> <p>Visual for entity</p> <code>sprite</code> Sprite. <code>center</code> If true, the sprite will be centered based on it's position"},{"location":"ECS/Component/DrawableText/","title":"DrawableText","text":"<p>struct DrawableText</p> <p>Displayable text on the screen</p> <code>text</code> Text <code>size</code> Size of the text <code>center</code> If true, the sprite will be centered based on it's position"},{"location":"ECS/Component/Health/","title":"Health","text":"<p>struct Health</p> <p>Health information for component</p> <code>health</code> Health value"},{"location":"ECS/Component/Hitbox/","title":"Hitbox","text":"<p>struct Hitbox</p> <p>Rectangle box for collisions/zone/etc...</p> <code>x</code> X outset. <code>y</code> Y outset. <code>w</code> width. <code>h</code> height."},{"location":"ECS/Component/Parallax/","title":"Parallax","text":"<p>struct Parallax</p> <p>Parallax movement for entity</p> <code>speed</code> Speed of parallax, goes backwards if negative value. <p>Warning</p> <p>Float values can sometimes not work, for onsistency, only use int values</p>"},{"location":"ECS/Component/Position/","title":"Position","text":"<p>struct Position</p> <p>Position inside world space</p> <code>x</code> X position. <code>y</code> Y position."},{"location":"ECS/Component/RigidBody/","title":"RigidBody","text":"<p>struct RigidBody</p> <p>Physics information for component</p> <code>gravityScale</code> impact scale of the gravity <code>mass</code> mass of the object <code>bounce</code> defines if the entity acts like a wall for other entities"},{"location":"ECS/Component/Script/","title":"Script","text":"<p>struct Script</p> <p>Scripting on entity</p> <code>name</code> Script name."},{"location":"ECS/Component/SpriteSheet/","title":"SpriteSheet","text":"<p>struct SpriteSheet</p> <p>Spritesheet info for selecting Sprite part on One line</p> <code>nbrOfState</code> nbr of different states avaliable. <code>state</code> state selected. <p>Warning</p> <p>THIS COMPONENT IS NOT IMPLEMENTED OR FUNCTIONAL</p>"},{"location":"ECS/Component/State/","title":"State","text":"<p>struct State</p> <p>State value usable for StateMachine or simply indicating a state</p> <code>name</code> State name."},{"location":"ECS/Component/Tag/","title":"Tag","text":"<p>struct Tag</p> <p>Tag value usable for entity labeling/categorisation Usefull for entity differentiation when colliding for example</p> <code>name</code> State name."},{"location":"ECS/Component/Velocity/","title":"Velocity","text":"<p>struct Velocity</p> <p>Velocity of entity</p> <code>x</code> X speed. <code>y</code> Y speed."},{"location":"Network/","title":"Network","text":"Serialized"},{"location":"Network/Serialized/","title":"Serialized","text":""},{"location":"Network/Serialized/#types","title":"Types","text":"Name Description PlayerPosition"},{"location":"Network/Serialized/PlayerPosition/","title":"PlayerPosition","text":"<p>class PlayerPosition: public Flint::Inspection&lt;PlayerPosition&gt;</p>"},{"location":"Network/Serialized/PlayerPosition/#functions","title":"Functions","text":"Name Description str This class being a child of Flint::Inspection, overriding the str function also override the operator&lt;&lt;. This is done for debugging purposes."},{"location":"Network/Serialized/PlayerPosition/#function-details","title":"Function Details","text":""},{"location":"Network/Serialized/PlayerPosition/#str","title":"str","text":"<p>std::string str() const override</p> <p>This class being a child of Flint::Inspection, overriding the str function also override the operator&lt;&lt;. This is done for debugging purposes.</p>"},{"location":"Server/","title":"Server","text":""},{"location":"Server/#types","title":"Types","text":"Name Description Client Threaded class that handles communication between the server and the client. Core PlayerInfo Contains all gameplay information of the player in game"},{"location":"Server/Client/","title":"Client","text":"<p>class Client</p> <p>Threaded class that handles communication between the server and the client. It uses the encapsulated socket.</p>"},{"location":"Server/Client/#functions","title":"Functions","text":"Name Description start Starts the client thread and socket stop Starts the client thread sendMessage Send message to the client  <code>message</code> :    Message to send receiveMessage Check if the client sent data to the server and stores them in the queue, closes the thread if there is no message or is disconnected getMessageQueue Returns the message queue that contains the messages sent by the client"},{"location":"Server/Client/#function-details","title":"Function Details","text":""},{"location":"Server/Client/#getmessagequeue","title":"getMessageQueue","text":"<p>ThreadSafeQueue&lt;std::string&gt;&amp; getMessageQueue()</p> <p>Returns the message queue that contains the messages sent by the client</p>"},{"location":"Server/Client/#receivemessage","title":"receiveMessage","text":"<p>void receiveMessage()</p> <p>Check if the client sent data to the server and stores them in the queue, closes the thread if there is no message or is disconnected</p>"},{"location":"Server/Client/#sendmessage","title":"sendMessage","text":"<p>void sendMessage(const std::string&amp; message)</p> <p>Send message to the client</p> <code>message</code> Message to send"},{"location":"Server/Client/#start","title":"start","text":"<p>void start()</p> <p>Starts the client thread and socket</p>"},{"location":"Server/Client/#stop","title":"stop","text":"<p>void stop()</p> <p>Starts the client thread</p>"},{"location":"Server/Core/","title":"Core","text":"<p>class Core</p>"},{"location":"Server/Core/#functions","title":"Functions","text":"Name Description run Run the server's loop and threads processClientMessages Checks if any client sent a message to process with the handleCommand() method handleCommand Handles the client's command  <code>message</code> :    Client message containing the command  <code>clientNbr</code> :    Number of the client sendToAll Sends a message to all the clients at once  <code>message</code> :    Message to send checkPlayersCapabilities Checks player positiona and cooldown to prevent cheating or out of bounds sendGameUpdate Sends the player and all element positions. checkEvent Check if the ECSManager has any events this frame and sends them to clients."},{"location":"Server/Core/#function-details","title":"Function Details","text":""},{"location":"Server/Core/#checkevent","title":"checkEvent","text":"<p>void checkEvent()</p> <p>Check if the ECSManager has any events this frame and sends them to clients. The events are defined in the .so scripts</p>"},{"location":"Server/Core/#checkplayerscapabilities","title":"checkPlayersCapabilities","text":"<p>void checkPlayersCapabilities()</p> <p>Checks player positiona and cooldown to prevent cheating or out of bounds</p>"},{"location":"Server/Core/#handlecommand","title":"handleCommand","text":"<p>void handleCommand(std::string message, int clientNbr)</p> <p>Handles the client's command</p> <code>message</code> Client message containing the command <code>clientNbr</code> Number of the client"},{"location":"Server/Core/#processclientmessages","title":"processClientMessages","text":"<p>void processClientMessages()</p> <p>Checks if any client sent a message to process with the handleCommand() method</p>"},{"location":"Server/Core/#run","title":"run","text":"<p>void run()</p> <p>Run the server's loop and threads</p>"},{"location":"Server/Core/#sendgameupdate","title":"sendGameUpdate","text":"<p>void sendGameUpdate()</p> <p>Sends the player and all element positions.</p>"},{"location":"Server/Core/#sendtoall","title":"sendToAll","text":"<p>void sendToAll(std::string message)</p> <p>Sends a message to all the clients at once</p> <code>message</code> Message to send"},{"location":"Server/PlayerInfo/","title":"PlayerInfo","text":"<p>class PlayerInfo</p> <p>Contains all gameplay information of the player in game</p>"},{"location":"client/","title":"RType Client","text":"<p>Client side part of the RType project. Runs using SFML and connect to the server in order to play.</p>"},{"location":"coverage/","title":"Code Coverage","text":"Name Lines Covered Uncovered Coverage client 121 0 121 0.0% src 121 0 121 0.0% Client 85 0 85 0.0% Commands 26 0 26 0.0% Commands.cpp 26 0 26 0.0% Commands.hpp 0 0 0 100.0% Core.cpp 59 0 59 0.0% Core.hpp 0 0 0 100.0% PrefabList.hpp 0 0 0 100.0% Network 36 0 36 0.0% Socket.cpp 36 0 36 0.0% Socket.hpp 0 0 0 100.0% ecs 443 0 443 0.0% src 443 0 443 0.0% Assets 117 0 117 0.0% AudioManager.cpp 14 0 14 0.0% AudioManager.hpp 0 0 0 100.0% PrefabManager.cpp 16 0 16 0.0% PrefabManager.hpp 0 0 0 100.0% ScriptManager.cpp 27 0 27 0.0% ScriptManager.hpp 0 0 0 100.0% SpriteManager.cpp 14 0 14 0.0% SpriteManager.hpp 0 0 0 100.0% SystemPluginManager.cpp 46 0 46 0.0% SystemPluginManager.hpp 0 0 0 100.0% Component 0 0 0 100.0% Acceleration.hpp 0 0 0 100.0% Animation.hpp 0 0 0 100.0% Components.hpp 0 0 0 100.0% Drawable.hpp 0 0 0 100.0% DrawableText.hpp 0 0 0 100.0% Health.hpp 0 0 0 100.0% Hitbox.hpp 0 0 0 100.0% Parallax.hpp 0 0 0 100.0% Position.hpp 0 0 0 100.0% RigidBody.hpp 0 0 0 100.0% Script.hpp 0 0 0 100.0% SpriteSheet.hpp 0 0 0 100.0% State.hpp 0 0 0 100.0% Tag.hpp 0 0 0 100.0% Velocity.hpp 0 0 0 100.0% Interfaces 0 0 0 100.0% IAudio.hpp 0 0 0 100.0% ICamera.hpp 0 0 0 100.0% IDrawable.hpp 0 0 0 100.0% IDrawableText.hpp 0 0 0 100.0% ISystem.hpp 0 0 0 100.0% IWindow.hpp 0 0 0 100.0% Managers 82 0 82 0.0% ComponentManager.cpp 0 0 0 100.0% ComponentManager.hpp 20 0 20 0.0% ComponentStorage.hpp 9 0 9 0.0% EntityManager.cpp 14 0 14 0.0% EntityManager.hpp 0 0 0 100.0% GlobalDataManager.cpp 0 0 0 100.0% GlobalDataManager.hpp 6 0 6 0.0% Registry.hpp 19 0 19 0.0% SystemManager.cpp 13 0 13 0.0% SystemManager.hpp 1 0 1 0.0% Systems.hpp 0 0 0 100.0% SFMLEncaps 155 0 155 0.0% SFMLAudio.cpp 16 0 16 0.0% SFMLAudio.hpp 0 0 0 100.0% SFMLCamera.hpp 30 0 30 0.0% SFMLDrawable.cpp 29 0 29 0.0% SFMLDrawable.hpp 0 0 0 100.0% SFMLDrawableText.cpp 16 0 16 0.0% SFMLDrawableText.hpp 0 0 0 100.0% SFMLWindow.cpp 64 0 64 0.0% SFMLWindow.hpp 0 0 0 100.0% Script 11 0 11 0.0% AScript.hpp 11 0 11 0.0% IScript.hpp 0 0 0 100.0% Types 78 0 78 0.0% Inputs.hpp 0 0 0 100.0% Rect2D.hpp 42 0 42 0.0% Vector2D.hpp 36 0 36 0.0% flint 101 0 101 0.0% src 101 0 101 0.0% Colors 0 0 0 100.0% Colors.cpp 0 0 0 100.0% Colors.hpp 0 0 0 100.0% CxxABI 34 0 34 0.0% CxxABI.cpp 34 0 34 0.0% CxxABI.hpp 0 0 0 100.0% Exceptions 44 0 44 0.0% Exceptions.cpp 43 0 43 0.0% Exceptions.hpp 1 0 1 0.0% Init 6 0 6 0.0% Init.cpp 6 0 6 0.0% Init.hpp 0 0 0 100.0% Logging 9 0 9 0.0% Logging.cpp 8 0 8 0.0% Logging.hpp 1 0 1 0.0% hpp 8 0 8 0.0% Inspection.hpp 8 0 8 0.0% Preprocessor.hpp 0 0 0 100.0% network 101 0 101 0.0% src 101 0 101 0.0% Security 71 0 71 0.0% DecodeError.hpp 3 0 3 0.0% GaloisField.cpp 8 0 8 0.0% GaloisField.hpp 1 0 1 0.0% HammingCodes.cpp 55 0 55 0.0% HammingCodes.hpp 1 0 1 0.0% ReedSolomon.cpp 2 0 2 0.0% ReedSolomon.hpp 1 0 1 0.0% Serialized 3 0 3 0.0% PlayerPosition.cpp 3 0 3 0.0% PlayerPosition.hpp 0 0 0 100.0% Server 27 0 27 0.0% UDP 27 0 27 0.0% UDPServer.cpp 27 0 27 0.0% UDPServer.hpp 0 0 0 100.0% server 183 0 183 0.0% src 183 0 183 0.0% Network 40 0 40 0.0% Socket.cpp 40 0 40 0.0% Socket.hpp 0 0 0 100.0% Server 143 0 143 0.0% Client.cpp 28 0 28 0.0% Client.hpp 0 0 0 100.0% Core.cpp 98 0 98 0.0% Core.hpp 0 0 0 100.0% PlayerInfo.cpp 9 0 9 0.0% PlayerInfo.hpp 0 0 0 100.0% ThreadSafeQueue.hpp 8 0 8 0.0% Summary 26 0 26 0.0% Summary 85 0 85 0.0% Summary 36 0 36 0.0% Summary 121 0 121 0.0% Summary 121 0 121 0.0% Summary 117 0 117 0.0% Summary 0 0 0 100.0% Summary 0 0 0 100.0% Summary 82 0 82 0.0% Summary 155 0 155 0.0% Summary 11 0 11 0.0% Summary 78 0 78 0.0% Summary 443 0 443 0.0% Summary 443 0 443 0.0% Summary 0 0 0 100.0% Summary 34 0 34 0.0% Summary 44 0 44 0.0% Summary 6 0 6 0.0% Summary 9 0 9 0.0% Summary 8 0 8 0.0% Summary 101 0 101 0.0% Summary 101 0 101 0.0% Summary 71 0 71 0.0% Summary 3 0 3 0.0% Summary 27 0 27 0.0% Summary 27 0 27 0.0% Summary 101 0 101 0.0% Summary 101 0 101 0.0% Summary 40 0 40 0.0% Summary 143 0 143 0.0% Summary 183 0 183 0.0% Summary 183 0 183 0.0% Summary 949 0 949 0.0%"},{"location":"coverage/client/","title":"client","text":"Name Lines Covered Uncovered Coverage src 121 0 121 0.0% Client 85 0 85 0.0% Commands 26 0 26 0.0% Commands.cpp 26 0 26 0.0% Commands.hpp 0 0 0 100.0% Core.cpp 59 0 59 0.0% Core.hpp 0 0 0 100.0% PrefabList.hpp 0 0 0 100.0% Network 36 0 36 0.0% Socket.cpp 36 0 36 0.0% Socket.hpp 0 0 0 100.0% Summary 26 0 26 0.0% Summary 85 0 85 0.0% Summary 36 0 36 0.0% Summary 121 0 121 0.0% Summary 121 0 121 0.0%"},{"location":"coverage/client/src/","title":"src","text":"Name Lines Covered Uncovered Coverage Client 85 0 85 0.0% Commands 26 0 26 0.0% Commands.cpp 26 0 26 0.0% Commands.hpp 0 0 0 100.0% Core.cpp 59 0 59 0.0% Core.hpp 0 0 0 100.0% PrefabList.hpp 0 0 0 100.0% Network 36 0 36 0.0% Socket.cpp 36 0 36 0.0% Socket.hpp 0 0 0 100.0% Summary 26 0 26 0.0% Summary 85 0 85 0.0% Summary 36 0 36 0.0% Summary 121 0 121 0.0%"},{"location":"coverage/client/src/Client/","title":"Client","text":"Name Lines Covered Uncovered Coverage Commands 26 0 26 0.0% Commands.cpp 26 0 26 0.0% Commands.hpp 0 0 0 100.0% Core.cpp 59 0 59 0.0% Core.hpp 0 0 0 100.0% PrefabList.hpp 0 0 0 100.0% Summary 26 0 26 0.0% Summary 85 0 85 0.0%"},{"location":"coverage/client/src/Client/Core.cpp/","title":"Core.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** EpiGimp\n** File description:\n** main\n*/\n\n#include \"Core.hpp\"\n#include \"ErrorException.hpp\"\n#include \"SFMLEncaps/SFMLWindow.hpp\"\n#include &lt;iostream&gt;\n#include &lt;unistd.h&gt;\n\nClient::Core::Core(const std::string&amp; ip, int port)\n    : _ip(ip), _port(port), _clientSocket(-1)\n{\n    this-&gt;_ecsManager = std::make_shared&lt;ECS::ECSManager&gt;(\"RType\", \"./assets\");\n    this-&gt;_ecsManager-&gt;loadWorld(\"test\");\n    for (int i = 0; i &lt; 5; i++) {\n        this-&gt;_buttonsPressed.push_back(false);\n    }\n    this-&gt;_previousButtonsPressed = this-&gt;_buttonsPressed;\n\n    this-&gt;_commandControls[0] = \"up\";\n    this-&gt;_commandControls[1] = \"down\";\n    this-&gt;_commandControls[2] = \"left\";\n    this-&gt;_commandControls[3] = \"right\";\n    this-&gt;_commandControls[4] = \"action\";\n\n    this-&gt;_commands[\"start\"] = [this](std::vector&lt;std::string&gt; args) { Client::Commands::startCMD(*this, args);};\n    this-&gt;_commands[\"end\"] = [this](std::vector&lt;std::string&gt; args) { Client::Commands::endCMD(*this, args);};\n    this-&gt;_commands[\"place\"] = [this](std::vector&lt;std::string&gt; args) { Client::Commands::placeCMD(*this, args);};\n    this-&gt;_commands[\"player\"] = [this](std::vector&lt;std::string&gt; args) { Client::Commands::playerCMD(*this, args);};\n    this-&gt;_commands[\"playerDead\"] = [this](std::vector&lt;std::string&gt; args) { Client::Commands::playerDeadCMD(*this, args);};\n    this-&gt;_commands[\"bulletHit\"] = [this](std::vector&lt;std::string&gt; args) { Client::Commands::bulletHitCMD(*this, args);};\n    this-&gt;_commands[\"ennemyDead\"] = [this](std::vector&lt;std::string&gt; args) { Client::Commands::ennemyDeadCMD(*this, args);};\n\n}\n\nClient::Core::~Core()\n{\n    if (_clientSocket != -1) {\n        close(_clientSocket);\n    }\n}\n\nvoid Client::Core::run()\n{\n    if (!_socket.connectToServer(_ip, _port)) {\n        throw ErrorException(\"Error: Failed to connect to server!\");\n    }\n    _clientSocket = _socket.getSocket();\n    while (this-&gt;_ecsManager-&gt;getWindow()-&gt;isOpen()) {\n        this-&gt;_ecsManager-&gt;getWindow()-&gt;clear();\n        this-&gt;handleEvent();\n        std::string receivedMessage = _socket.receiveData(_clientSocket);\n        if (!receivedMessage.empty()) {\n            this-&gt;handleServerMessage(receivedMessage);\n        }\n        if (!this-&gt;_gameStarted &amp;&amp; this-&gt;_buttonsPressed[ACTION]) {\n            this-&gt;_socket.sendData(_clientSocket, \"start\");\n        }\n\n        for (int i = 0; i &lt; 5; i++) {\n            if (this-&gt;_buttonsPressed[i] != this-&gt;_previousButtonsPressed[i]) {\n                _socket.sendData(_clientSocket, this-&gt;_commandControls[i] + \" \" + std::to_string(this-&gt;_buttonsPressed[i]));\n            }\n        }\n        this-&gt;_ecsManager-&gt;update();\n        this-&gt;_ecsManager-&gt;getWindow()-&gt;display();\n        this-&gt;hideNonUpdatedElements();\n        this-&gt;_previousButtonsPressed = this-&gt;_buttonsPressed;\n    }\n}\n\nvoid Client::Core::handleEvent()\n{\n    if (true) {\n        this-&gt;_buttonsPressed[UP] = this-&gt;_ecsManager-&gt;getWindow()-&gt;isKeyPressed(ECS::Key::Up);\n        this-&gt;_buttonsPressed[DOWN] = this-&gt;_ecsManager-&gt;getWindow()-&gt;isKeyPressed(ECS::Key::Down);\n        this-&gt;_buttonsPressed[LEFT] = this-&gt;_ecsManager-&gt;getWindow()-&gt;isKeyPressed(ECS::Key::Left);\n        this-&gt;_buttonsPressed[RIGHT] = this-&gt;_ecsManager-&gt;getWindow()-&gt;isKeyPressed(ECS::Key::Right);\n        this-&gt;_buttonsPressed[ACTION] = this-&gt;_ecsManager-&gt;getWindow()-&gt;isKeyPressed(ECS::Key::Space);\n    }\n}\n\nvoid Client::Core::handleServerMessage(std::string message)\n{\n    std::regex reg2(\"\\n\");\n    auto begin = std::sregex_token_iterator(message.begin(), message.end(), reg2, -1);\n    auto end = std::sregex_token_iterator();\n    std::vector&lt;std::string&gt; commandList(begin, end);\n\n    for (auto &amp;currentCommand : commandList) {\n        std::regex reg(\"\\\\ \");\n        begin = std::sregex_token_iterator(currentCommand.begin(), currentCommand.end(), reg, -1);\n        end = std::sregex_token_iterator();\n        std::vector&lt;std::string&gt; command(begin, end);\n\n        if (command.empty()) continue;\n        const std::string &amp;cmd = command[0];\n        if (this-&gt;_commands.find(cmd) != this-&gt;_commands.end()) {\n            this-&gt;_commands[cmd](command);\n        } else {\n            // std::cerr &lt;&lt; \"Unknown command: \" &lt;&lt; cmd &lt;&lt; std::endl;\n            continue;\n        }\n    }\n}\n\nvoid Client::Core::createPlayers(int nbrPlayers)\n{\n    int n = 1;\n    while (n &lt;= nbrPlayers) {\n        ECS::entity_id id = this-&gt;_ecsManager-&gt;createEntityFromPrefab(\"player\" + std::to_string(n));\n        this-&gt;_players[n] = id;\n        n++;\n    }\n}\n\nvoid Client::Core::hideNonUpdatedElements()\n{\n    for (auto &amp;e : this-&gt;_placedEntities) {\n        this-&gt;_ecsManager-&gt;destroyEntity(e);\n    }\n    this-&gt;_placedEntities.clear();\n}\n</code></pre>"},{"location":"coverage/client/src/Client/Core.hpp/","title":"Core.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Server\n** File description:\n** Core\n*/\n\n#ifndef CLIENT_CORE_HPP_\n#define CLIENT_CORE_HPP_\n\n#include \"Network/Socket.hpp\"\n#include \"Types/Inputs.hpp\"\n#include \"ECSManager.hpp\"\n#include \"Commands/Commands.hpp\"\n#include &lt;memory&gt;\n#include &lt;string&gt;\n\nnamespace Client\n{\n    enum Controls {\n        UP,\n        DOWN,\n        LEFT,\n        RIGHT,\n        ACTION\n    };\n\n    /**\n    * Handles the core loop of the client\n    * Handles the ECSManager and the connection to the server in one thread.\n    */\n    class Core\n    {\n        public:\n            friend class Commands;\n            typedef void(Client::Core::*FnPtr)(std::vector&lt;std::string&gt;);\n\n            Core(const std::string&amp; ip, int port);\n            ~Core();\n\n            /**\n            * Run the client's loop\n            */\n            void run();\n\n            /**\n            * Handles the window's event like button press.\n            */\n            void handleEvent();\n\n            /**\n            * Checks the message sent by the server and executes the correct CMD method\n            * @param message Message sent by the server\n            */\n            void handleServerMessage(std::string message);\n\n            /**\n            * Removes all ECS elements that were not updated by the server this frame\n            */\n            void hideNonUpdatedElements();\n\n            /**\n            * Creates X number of player entities in the ECS based on the server's \"start\" command\n            * @param nbrPlayers Number of players this game\n            */\n            void createPlayers(int nbrPlayers);\n\n        private:\n            std::string _ip;\n            int _port;\n            Socket _socket;\n            int _clientSocket;\n\n            std::shared_ptr&lt;ECS::ECSManager&gt; _ecsManager;\n            std::shared_ptr&lt;ECS::IWindow&gt; _win;\n            sf::Event _event;\n\n            bool _gameStarted = false;\n\n            //checks if the control buttons are pressed (up, down, left, right, action)\n            std::vector&lt;bool&gt; _buttonsPressed;\n\n            //Check if the control buttons were pressed this frame (usefull for checking if buttons is pressed this frame)\n            std::vector&lt;bool&gt; _previousButtonsPressed;\n            std::unordered_map&lt;int, std::string&gt; _commandControls;\n            std::unordered_map&lt;std::string, std::function&lt;void(std::vector&lt;std::string&gt;)&gt;&gt; _commands;\n\n            //List of player entities\n            std::unordered_map&lt;int, ECS::entity_id&gt; _players;\n\n            //Contains all entities placed by the \"place\" command this frame.\n            std::vector&lt;ECS::entity_id&gt; _placedEntities;\n\n\n    };\n}\n\n#endif\n</code></pre>"},{"location":"coverage/client/src/Client/PrefabList.hpp/","title":"PrefabList.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Server\n** File description:\n** Core\n*/\n\n\n#ifndef PREFAB_LIST_HPP_\n#define PREFAB_LIST_HPP_\n\n#include &lt;string&gt;\n#include &lt;unistd.h&gt;\n#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n\n#include \"Entity.hpp\"\n\nnamespace Client\n{\n    class PrefabList\n    {\n    public:\n        PrefabList();\n        ~PrefabList();\n\n\n    private:\n        std::unordered_map&lt;int, ECS::entity_id&gt; _ids;\n    };\n}\n\n#endif // SOCKET_HPP_\n</code></pre>"},{"location":"coverage/client/src/Client/Commands/","title":"Commands","text":"Name Lines Covered Uncovered Coverage Commands.cpp 26 0 26 0.0% Commands.hpp 0 0 0 100.0% Summary 26 0 26 0.0%"},{"location":"coverage/client/src/Client/Commands/Commands.cpp/","title":"Commands.cpp","text":"<pre><code>#include \"Commands.hpp\"\n\nvoid Client::Commands::startCMD(Core&amp; core, std::vector&lt;std::string&gt; args)\n{\n    core._gameStarted = true;\n    core._ecsManager-&gt;loadWorld(\"game\");\n    core.createPlayers(std::stoi(args[1]));\n}\n\nvoid Client::Commands::endCMD(Core&amp; core, std::vector&lt;std::string&gt; args)\n{\n    core._ecsManager-&gt;loadWorld(\"test\");\n    core._players.clear();\n    core._placedEntities.clear();\n    core._gameStarted = false;\n}\n\nvoid Client::Commands::placeCMD(Core&amp; core, std::vector&lt;std::string&gt; args)\n{\n    ECS::entity_id id = core._ecsManager-&gt;createEntityFromPrefab(args[1]);\n    core._ecsManager-&gt;getComponent&lt;ECS::Component::Position&gt;(id)-&gt;vect.x = std::stoi(args[2]);\n    core._ecsManager-&gt;getComponent&lt;ECS::Component::Position&gt;(id)-&gt;vect.y = std::stoi(args[3]);\n    core._placedEntities.push_back(id);\n}\n\nvoid Client::Commands::playerCMD(Core&amp; core, std::vector&lt;std::string&gt; args)\n{\n    auto pos = core._ecsManager-&gt;getComponent&lt;ECS::Component::Position&gt;(core._players[std::stoi(args[1])]);\n    pos-&gt;vect.x = std::stoi(args[2]);\n    pos-&gt;vect.y = std::stoi(args[3]);\n}\n\nvoid Client::Commands::playerDeadCMD(Core&amp; core, std::vector&lt;std::string&gt; args)\n{\n    auto pos = core._ecsManager-&gt;getComponent&lt;ECS::Component::Position&gt;(core._players[std::stoi(args[1])]);\n    ECS::entity_id id = core._ecsManager-&gt;createEntityFromPrefab(\"explosion_tm\");\n    core._ecsManager-&gt;getComponent&lt;ECS::Component::Position&gt;(id)-&gt;vect.x = pos-&gt;vect.x;\n    core._ecsManager-&gt;getComponent&lt;ECS::Component::Position&gt;(id)-&gt;vect.y = pos-&gt;vect.y;\n    core._ecsManager-&gt;destroyEntity(core._players[std::stoi(args[1])]);\n    core._players.erase(std::stoi(args[1]));\n}\n\nvoid Client::Commands::bulletHitCMD(Core&amp; core, std::vector&lt;std::string&gt; args)\n{\n    ECS::entity_id id = core._ecsManager-&gt;createEntityFromPrefab(\"explosion\");\n    core._ecsManager-&gt;getComponent&lt;ECS::Component::Position&gt;(id)-&gt;vect.x = std::stoi(args[1]);\n    core._ecsManager-&gt;getComponent&lt;ECS::Component::Position&gt;(id)-&gt;vect.y = std::stoi(args[2]);\n}\n\nvoid Client::Commands::ennemyDeadCMD(Core&amp; core, std::vector&lt;std::string&gt; args)\n{\n    ECS::entity_id id = core._ecsManager-&gt;createEntityFromPrefab(\"explosion_tm\");\n    core._ecsManager-&gt;getComponent&lt;ECS::Component::Position&gt;(id)-&gt;vect.x = std::stoi(args[1]);\n    core._ecsManager-&gt;getComponent&lt;ECS::Component::Position&gt;(id)-&gt;vect.y = std::stoi(args[2]);\n}\n</code></pre>"},{"location":"coverage/client/src/Client/Commands/Commands.hpp/","title":"Commands.hpp","text":"<pre><code>#ifndef CLIENT_COMMANDS_HPP_\n    #define CLIENT_COMMANDS_HPP_\n\n#include \"Headers.hpp\"\n#include \"../Core.hpp\"\n\nnamespace Client {\n    class Core;\n    /**\n    * Handles the commands of the client\n    * Handles and manage all client commands\n    */\n    class Commands {\n    public:\n        /**\n        * Handles the \"start\" command\n        * It switches to the game world in the ECSManager ad spawns the players\n        */\n        static void startCMD(Core&amp; core, std::vector&lt;std::string&gt; args);\n\n        /**\n        * Handles the \"end\" command\n        * It switches back to the title screen and cleans all entities in the game world\n        */\n        static void endCMD(Core&amp; core, std::vector&lt;std::string&gt; args);\n\n        /**\n        * Handles the \"place\" command\n        * Creates entity prefabs and places them in the correct position\n        */\n        static void placeCMD(Core&amp; core, std::vector&lt;std::string&gt; args);\n\n        /**\n        * Handles the \"player\" command\n        * Places the correct player at the x and y positions provided by the server\n        */\n        static void playerCMD(Core&amp; core, std::vector&lt;std::string&gt; args);\n\n        /**\n        * Handles the \"playerDead\" command\n        * It deletes the player game object and spawns an explosion animation\n        */\n        static void playerDeadCMD(Core&amp; core, std::vector&lt;std::string&gt; args);\n\n        /**\n        * Handles the \"bulletHit\" command\n        * spawns an explosion at the impact\n        */\n        static void bulletHitCMD(Core&amp; core, std::vector&lt;std::string&gt; args);\n\n        /**\n        * Handles the \"start\" command\n        * Spawns an explosion at the enemy's position\n        */\n        static void ennemyDeadCMD(Core&amp; core, std::vector&lt;std::string&gt; args);\n    };\n}\n\n#endif\n</code></pre>"},{"location":"coverage/client/src/Network/","title":"Network","text":"Name Lines Covered Uncovered Coverage Socket.cpp 36 0 36 0.0% Socket.hpp 0 0 0 100.0% Summary 36 0 36 0.0%"},{"location":"coverage/client/src/Network/Socket.cpp/","title":"Socket.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Server\n** File description:\n** Core\n*/\n\n#include \"Socket.hpp\"\n\n#ifdef _WIN32\n    using socklen_t = int; // For compatibility\n#endif\n\nSocket::Socket()\n    : _socket(-1)\n{\n#ifdef _WIN32\n    WSADATA wsaData;\n    if (WSAStartup(MAKEWORD(2, 2), &amp;wsaData) != 0) {\n        std::cerr &lt;&lt; \"WSAStartup failed!\" &lt;&lt; std::endl;\n    }\n#endif\n}\n\nSocket::~Socket()\n{\n    if (_socket != -1) {\n#ifdef _WIN32\n        closesocket(_socket);\n        WSACleanup();\n#else\n        close(_socket);\n#endif\n    }\n}\n\nbool Socket::connectToServer(const std::string&amp; ip, int port)\n{\n    _socket = socket(AF_INET, SOCK_STREAM, 0);\n    if (_socket == -1) {\n        std::cerr &lt;&lt; \"Failed to create socket!\" &lt;&lt; std::endl;\n        return false;\n    }\n\n    struct sockaddr_in serverAddr = {};\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_port = htons(port);\n    if (inet_pton(AF_INET, ip.c_str(), &amp;serverAddr.sin_addr) &lt;= 0) {\n        std::cerr &lt;&lt; \"Invalid address!\" &lt;&lt; std::endl;\n        return false;\n    }\n\n    if (connect(_socket, (struct sockaddr*)&amp;serverAddr, sizeof(serverAddr)) &lt; 0) {\n        std::cerr &lt;&lt; \"Connection failed!\" &lt;&lt; std::endl;\n        return false;\n    }\n\n    return setNonBlocking(_socket);\n}\n\nbool Socket::setNonBlocking(int socket)\n{\n#ifdef _WIN32\n    u_long mode = 1;\n    if (ioctlsocket(socket, FIONBIO, &amp;mode) != 0) {\n        std::cerr &lt;&lt; \"Failed to set non-blocking mode!\" &lt;&lt; std::endl;\n        return false;\n    }\n#else\n    int flags = fcntl(socket, F_GETFL, 0);\n    if (flags == -1 || fcntl(socket, F_SETFL, flags | O_NONBLOCK) == -1) {\n        std::cerr &lt;&lt; \"Failed to set non-blocking mode!\" &lt;&lt; std::endl;\n        return false;\n    }\n#endif\n    return true;\n}\n\nbool Socket::sendData(int socket, const std::string&amp; data)\n{\n    std::string dataSent = data + \"\\n\";\n    int bytesSent = send(socket, dataSent.c_str(), dataSent.length(), 0);\n    return (bytesSent == static_cast&lt;int&gt;(dataSent.length()));\n}\n\nstd::string Socket::receiveData(int socket)\n{\n    char buffer[1024];\n    int bytesReceived = recv(socket, buffer, sizeof(buffer), 0);\n\n    if (bytesReceived &gt; 0) {\n        return std::string(buffer, bytesReceived);\n    }\n\n    return \"\";\n}\n\nint Socket::getSocket() const\n{\n    return _socket;\n}\n</code></pre>"},{"location":"coverage/client/src/Network/Socket.hpp/","title":"Socket.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Server\n** File description:\n** Core\n*/\n\n\n#ifndef SOCKET_HPP_\n#define SOCKET_HPP_\n\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n\n#ifdef _WIN32\n    #include &lt;winsock2.h&gt;\n    #include &lt;ws2tcpip.h&gt;\n    #pragma comment(lib, \"ws2_32.lib\") // Link with Winsock library\n#else\n    #include &lt;sys/socket.h&gt;\n    #include &lt;arpa/inet.h&gt;\n    #include &lt;unistd.h&gt;\n    #include &lt;fcntl.h&gt;\n#endif\n\nclass Socket\n{\npublic:\n    Socket();\n    ~Socket();\n\n    bool connectToServer(const std::string&amp; ip, int port);\n    bool sendData(int socket, const std::string&amp; data);\n    std::string receiveData(int socket);\n    int getSocket() const;\n\nprivate:\n    int _socket;\n\n    // Helper for cross-platform non-blocking mode\n    bool setNonBlocking(int socket);\n};\n\n#endif // SOCKET_HPP_\n</code></pre>"},{"location":"coverage/ecs/","title":"ecs","text":"Name Lines Covered Uncovered Coverage src 443 0 443 0.0% Assets 117 0 117 0.0% AudioManager.cpp 14 0 14 0.0% AudioManager.hpp 0 0 0 100.0% PrefabManager.cpp 16 0 16 0.0% PrefabManager.hpp 0 0 0 100.0% ScriptManager.cpp 27 0 27 0.0% ScriptManager.hpp 0 0 0 100.0% SpriteManager.cpp 14 0 14 0.0% SpriteManager.hpp 0 0 0 100.0% SystemPluginManager.cpp 46 0 46 0.0% SystemPluginManager.hpp 0 0 0 100.0% Component 0 0 0 100.0% Acceleration.hpp 0 0 0 100.0% Animation.hpp 0 0 0 100.0% Components.hpp 0 0 0 100.0% Drawable.hpp 0 0 0 100.0% DrawableText.hpp 0 0 0 100.0% Health.hpp 0 0 0 100.0% Hitbox.hpp 0 0 0 100.0% Parallax.hpp 0 0 0 100.0% Position.hpp 0 0 0 100.0% RigidBody.hpp 0 0 0 100.0% Script.hpp 0 0 0 100.0% SpriteSheet.hpp 0 0 0 100.0% State.hpp 0 0 0 100.0% Tag.hpp 0 0 0 100.0% Velocity.hpp 0 0 0 100.0% Interfaces 0 0 0 100.0% IAudio.hpp 0 0 0 100.0% ICamera.hpp 0 0 0 100.0% IDrawable.hpp 0 0 0 100.0% IDrawableText.hpp 0 0 0 100.0% ISystem.hpp 0 0 0 100.0% IWindow.hpp 0 0 0 100.0% Managers 82 0 82 0.0% ComponentManager.cpp 0 0 0 100.0% ComponentManager.hpp 20 0 20 0.0% ComponentStorage.hpp 9 0 9 0.0% EntityManager.cpp 14 0 14 0.0% EntityManager.hpp 0 0 0 100.0% GlobalDataManager.cpp 0 0 0 100.0% GlobalDataManager.hpp 6 0 6 0.0% Registry.hpp 19 0 19 0.0% SystemManager.cpp 13 0 13 0.0% SystemManager.hpp 1 0 1 0.0% Systems.hpp 0 0 0 100.0% SFMLEncaps 155 0 155 0.0% SFMLAudio.cpp 16 0 16 0.0% SFMLAudio.hpp 0 0 0 100.0% SFMLCamera.hpp 30 0 30 0.0% SFMLDrawable.cpp 29 0 29 0.0% SFMLDrawable.hpp 0 0 0 100.0% SFMLDrawableText.cpp 16 0 16 0.0% SFMLDrawableText.hpp 0 0 0 100.0% SFMLWindow.cpp 64 0 64 0.0% SFMLWindow.hpp 0 0 0 100.0% Script 11 0 11 0.0% AScript.hpp 11 0 11 0.0% IScript.hpp 0 0 0 100.0% Types 78 0 78 0.0% Inputs.hpp 0 0 0 100.0% Rect2D.hpp 42 0 42 0.0% Vector2D.hpp 36 0 36 0.0% Summary 117 0 117 0.0% Summary 0 0 0 100.0% Summary 0 0 0 100.0% Summary 82 0 82 0.0% Summary 155 0 155 0.0% Summary 11 0 11 0.0% Summary 78 0 78 0.0% Summary 443 0 443 0.0% Summary 443 0 443 0.0%"},{"location":"coverage/ecs/src/","title":"src","text":"Name Lines Covered Uncovered Coverage Assets 117 0 117 0.0% AudioManager.cpp 14 0 14 0.0% AudioManager.hpp 0 0 0 100.0% PrefabManager.cpp 16 0 16 0.0% PrefabManager.hpp 0 0 0 100.0% ScriptManager.cpp 27 0 27 0.0% ScriptManager.hpp 0 0 0 100.0% SpriteManager.cpp 14 0 14 0.0% SpriteManager.hpp 0 0 0 100.0% SystemPluginManager.cpp 46 0 46 0.0% SystemPluginManager.hpp 0 0 0 100.0% Component 0 0 0 100.0% Acceleration.hpp 0 0 0 100.0% Animation.hpp 0 0 0 100.0% Components.hpp 0 0 0 100.0% Drawable.hpp 0 0 0 100.0% DrawableText.hpp 0 0 0 100.0% Health.hpp 0 0 0 100.0% Hitbox.hpp 0 0 0 100.0% Parallax.hpp 0 0 0 100.0% Position.hpp 0 0 0 100.0% RigidBody.hpp 0 0 0 100.0% Script.hpp 0 0 0 100.0% SpriteSheet.hpp 0 0 0 100.0% State.hpp 0 0 0 100.0% Tag.hpp 0 0 0 100.0% Velocity.hpp 0 0 0 100.0% Interfaces 0 0 0 100.0% IAudio.hpp 0 0 0 100.0% ICamera.hpp 0 0 0 100.0% IDrawable.hpp 0 0 0 100.0% IDrawableText.hpp 0 0 0 100.0% ISystem.hpp 0 0 0 100.0% IWindow.hpp 0 0 0 100.0% Managers 82 0 82 0.0% ComponentManager.cpp 0 0 0 100.0% ComponentManager.hpp 20 0 20 0.0% ComponentStorage.hpp 9 0 9 0.0% EntityManager.cpp 14 0 14 0.0% EntityManager.hpp 0 0 0 100.0% GlobalDataManager.cpp 0 0 0 100.0% GlobalDataManager.hpp 6 0 6 0.0% Registry.hpp 19 0 19 0.0% SystemManager.cpp 13 0 13 0.0% SystemManager.hpp 1 0 1 0.0% Systems.hpp 0 0 0 100.0% SFMLEncaps 155 0 155 0.0% SFMLAudio.cpp 16 0 16 0.0% SFMLAudio.hpp 0 0 0 100.0% SFMLCamera.hpp 30 0 30 0.0% SFMLDrawable.cpp 29 0 29 0.0% SFMLDrawable.hpp 0 0 0 100.0% SFMLDrawableText.cpp 16 0 16 0.0% SFMLDrawableText.hpp 0 0 0 100.0% SFMLWindow.cpp 64 0 64 0.0% SFMLWindow.hpp 0 0 0 100.0% Script 11 0 11 0.0% AScript.hpp 11 0 11 0.0% IScript.hpp 0 0 0 100.0% Types 78 0 78 0.0% Inputs.hpp 0 0 0 100.0% Rect2D.hpp 42 0 42 0.0% Vector2D.hpp 36 0 36 0.0% Summary 117 0 117 0.0% Summary 0 0 0 100.0% Summary 0 0 0 100.0% Summary 82 0 82 0.0% Summary 155 0 155 0.0% Summary 11 0 11 0.0% Summary 78 0 78 0.0% Summary 443 0 443 0.0%"},{"location":"coverage/ecs/src/Assets/","title":"Assets","text":"Name Lines Covered Uncovered Coverage AudioManager.cpp 14 0 14 0.0% AudioManager.hpp 0 0 0 100.0% PrefabManager.cpp 16 0 16 0.0% PrefabManager.hpp 0 0 0 100.0% ScriptManager.cpp 27 0 27 0.0% ScriptManager.hpp 0 0 0 100.0% SpriteManager.cpp 14 0 14 0.0% SpriteManager.hpp 0 0 0 100.0% SystemPluginManager.cpp 46 0 46 0.0% SystemPluginManager.hpp 0 0 0 100.0% Summary 117 0 117 0.0%"},{"location":"coverage/ecs/src/Assets/AudioManager.cpp/","title":"AudioManager.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** ComponentManager\n** File description:\n** Component Manager\n*/\n\n#include \"AudioManager.hpp\"\n#include \"SFMLEncaps/SFMLAudio.hpp\"\n\nECS::AudioManager::AudioManager(std::string path)\n{\n    this-&gt;_defaultAudio = std::make_shared&lt;ECS::SFMLAudio&gt;();\n    if (!std::filesystem::exists(path + \"/audio\")) {\n        return;\n    }\n    std::string key;\n    for (const auto &amp;entry : std::filesystem::directory_iterator(path + \"/audio\")) {\n        if (entry.path().extension() == \".mp3\" || entry.path().extension() == \".ogg\") {\n            key = entry.path().stem().string();\n            this-&gt;_audios[key] = std::make_shared&lt;ECS::SFMLAudio&gt;();\n            if (this-&gt;_audios[key]-&gt;loadFromFile(entry.path().string())) {\n                std::cout &lt;&lt; \"Successfully loaded audio: \" &lt;&lt; key &lt;&lt; std::endl;\n                continue;\n            }\n            std::cerr &lt;&lt; \"Failed to load audio: \" &lt;&lt; key &lt;&lt; std::endl;\n        }\n    }\n}\n\nECS::AudioManager::~AudioManager()\n{\n\n}\n\nstd::shared_ptr&lt;ECS::IAudio&gt; ECS::AudioManager::getAudio(const std::string&amp; key) {\n    auto it = _audios.find(key);\n    if (it != _audios.end()) {\n        return it-&gt;second;\n    }\n    return _defaultAudio;\n}\n</code></pre>"},{"location":"coverage/ecs/src/Assets/AudioManager.hpp/","title":"AudioManager.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** RType\n** File description:\n** EntityManager Class\n*/\n\n#ifndef AUDIO_MANAGER_HPP_\n    #define AUDIO_MANAGER_HPP_\n\n    #include &lt;filesystem&gt;\n    #include &lt;memory&gt;\n    #include &lt;unordered_map&gt;\n    #include &lt;fstream&gt;\n    #include &lt;iostream&gt;\n    #include &lt;functional&gt;\n\n    #include \"Component/Components.hpp\"\n    #include \"Interfaces/IAudio.hpp\"\n\n    namespace ECS\n    {\n        /**\n        * This class loads the audios from the asset directory\n        * All of the ressource's key names correspond to the name of their files in the asset directory.\n        *\n        * The asset directory's structure cannot be modified\n        *\n        */\n        class AudioManager {\n            public:\n\n                AudioManager(std::string path);\n                ~AudioManager();\n\n                /**\n                * Returns a audio, returns an empty one if not found\n                * @param key name of the audio\n                *\n                * @return Audio\n                *\n                */\n                std::shared_ptr&lt;ECS::IAudio&gt; getAudio(const std::string&amp; key);\n\n            private:\n                std::unordered_map&lt;std::string, std::shared_ptr&lt;ECS::IAudio&gt;&gt; _audios;\n                std::shared_ptr&lt;ECS::IAudio&gt; _defaultAudio;\n        };\n    }\n\n#endif\n</code></pre>"},{"location":"coverage/ecs/src/Assets/PrefabManager.cpp/","title":"PrefabManager.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** ComponentManager\n** File description:\n** Component Manager\n*/\n\n#include \"PrefabManager.hpp\"\n\nECS::PrefabManager::PrefabManager(std::string path)\n{\n    if (!std::filesystem::exists(path + \"/prefab\")) {\n        return;\n    }\n    for (const auto&amp; entry : std::filesystem::directory_iterator(path + \"/prefab\")) {\n        std::string prefabName = entry.path().stem().string();\n        if (entry.is_regular_file() &amp;&amp; entry.path().extension() == \".json\") {\n            loadPrefab(entry.path().string(), prefabName);\n            std::cout &lt;&lt; \"Successfully loaded prefab: \" &lt;&lt; prefabName &lt;&lt; std::endl;\n            continue;\n        }\n        std::cerr &lt;&lt; \"Failed to load prefab: \" &lt;&lt; prefabName &lt;&lt; std::endl;\n    }\n}\n\nECS::PrefabManager::~PrefabManager()\n{\n\n}\n\nconst nlohmann::json&amp; ECS::PrefabManager::getPrefab(const std::string&amp; key) const {\n    auto it = _prefabs.find(key);\n    if (it != _prefabs.end()) {\n        return it-&gt;second;\n    }\n    static nlohmann::json defaultJson;\n    return defaultJson; // Return empty json object if not found\n}\n\nvoid ECS::PrefabManager::loadPrefab(const std::string&amp; filePath, const std::string&amp; prefabName)\n{\n    std::ifstream file(filePath);\n    if (file.is_open()) {\n        nlohmann::json prefabData;\n        file &gt;&gt; prefabData;\n        _prefabs[prefabName] = prefabData; // Store the prefab data by its name\n    } else {\n        std::cerr &lt;&lt; \"Failed to load prefab from file: \" &lt;&lt; filePath &lt;&lt; std::endl;\n    }\n}\n</code></pre>"},{"location":"coverage/ecs/src/Assets/PrefabManager.hpp/","title":"PrefabManager.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** RType\n** File description:\n** EntityManager Class\n*/\n\n#ifndef PREFAB_MANAGER_HPP_\n    #define PREFAB_MANAGER_HPP_\n\n    #include &lt;filesystem&gt;\n    #include &lt;memory&gt;\n    #include &lt;unordered_map&gt;\n    #include &lt;fstream&gt;\n    #include &lt;iostream&gt;\n    #include &lt;functional&gt;\n\n    #include \"json.hpp\"\n    #include \"Component/Components.hpp\"\n\n    namespace ECS\n    {\n        /**\n        * This class loads the prefabs from the asset directory\n        * All of the ressource's key names correspond to the name of their files in the asset directory.\n        *\n        * The asset directory's structure cannot be modified\n        *\n        */\n        class PrefabManager {\n            public:\n\n                PrefabManager(std::string path);\n                ~PrefabManager();\n\n                /**\n                * Returns a prefab's json configuration, returns an empty one if not found\n                * @param key name of the prefab\n                *\n                * @return Prefab's configuration\n                * \n                * @warning This function should not necessarily be used as the engine already uses it in it's\n                * regular methods. for any prefab call, refer to script's methods or ECSManager's methods\n                *\n                */\n                const nlohmann::json&amp; getPrefab(const std::string&amp; key) const;\n                void loadPrefab(const std::string&amp; filePath, const std::string&amp; prefabName);\n\n            private:\n                std::unordered_map&lt;std::string, nlohmann::json&gt; _prefabs;\n        };\n    }\n\n#endif\n</code></pre>"},{"location":"coverage/ecs/src/Assets/ScriptManager.cpp/","title":"ScriptManager.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** ComponentManager\n** File description:\n** Component Manager\n*/\n\n#include \"ScriptManager.hpp\"\n\nECS::ScriptManager::ScriptManager(std::string path)\n{\n    if (!std::filesystem::exists(path + \"/script\")) {\n        return;\n    }\n    for (const auto&amp; entry : std::filesystem::directory_iterator(path + \"/script\")) {\n        if (entry.path().extension() == getSharedLibraryExtension()) {\n            // Load the shared object\n            void* handle = loadSharedLibrary(entry.path().string().c_str()\n);\n            if (!handle) {\n                std::cerr &lt;&lt; \"Error loading shared object.\" &lt;&lt; std::endl;\n                continue;\n            }\n\n            // Get the createScript function\n            auto createScript = (ECS::IScript* (*)())getFunctionFromLibrary(handle, \"createScript\");\n            if (!createScript) {\n                std::cerr &lt;&lt; \"Error finding symbol createScript.\" &lt;&lt; std::endl;\n                unloadSharedLibrary(handle);\n                continue;\n            }\n\n            // Store the script in the map using std::shared_ptr\n            this-&gt;_scripts[entry.path().stem().string()] = [handle = handle, createScript]() -&gt; std::shared_ptr&lt;ECS::IScript&gt; {\n                return std::shared_ptr&lt;ECS::IScript&gt;(createScript());\n            };\n            std::cout &lt;&lt; \"Successfully loaded script: \" &lt;&lt; entry.path().stem().string() &lt;&lt; std::endl;\n        }\n    }\n}\n\nECS::ScriptManager::~ScriptManager()\n{\n    // Optionally, you can add cleanup here if you need to unload libraries explicitly.\n}\n\nstd::shared_ptr&lt;ECS::IScript&gt; ECS::ScriptManager::getScript(const std::string &amp;key)\n{\n    if (_scripts.count(key) == 0) {\n        return nullptr;\n    }\n    auto s = _scripts[key]();\n    return s;\n}\n\n// Platform-specific implementations\n\n#ifdef _WIN32\n\n// Windows-specific implementations\nstd::string ECS::ScriptManager::getSharedLibraryExtension() {\n    return \".dll\";\n}\n\nvoid* ECS::ScriptManager::loadSharedLibrary(const char* path) {\n    return LoadLibrary(path);\n}\n\nvoid ECS::ScriptManager::unloadSharedLibrary(void* handle) {\n    FreeLibrary(reinterpret_cast&lt;HMODULE&gt;(handle));\n}\n\nvoid* ECS::ScriptManager::getFunctionFromLibrary(void* handle, const char* funcName) {\n    return reinterpret_cast&lt;void*&gt;(GetProcAddress(reinterpret_cast&lt;HMODULE&gt;(handle), funcName));\n}\n\n#else\n\n// Linux/macOS specific implementations\nstd::string ECS::ScriptManager::getSharedLibraryExtension() {\n    #ifdef __APPLE__\n        return \".dylib\";  // macOS\n    #else\n        return \".so\";  // Linux\n    #endif\n}\n\nvoid* ECS::ScriptManager::loadSharedLibrary(const char* path) {\n    return dlopen(path, RTLD_LAZY | RTLD_GLOBAL);\n}\n\nvoid ECS::ScriptManager::unloadSharedLibrary(void* handle) {\n    dlclose(handle);\n}\n\nvoid* ECS::ScriptManager::getFunctionFromLibrary(void* handle, const char* funcName) {\n    return dlsym(handle, funcName);\n}\n\n#endif\n</code></pre>"},{"location":"coverage/ecs/src/Assets/ScriptManager.hpp/","title":"ScriptManager.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** RType\n** File description:\n** EntityManager Class\n*/\n\n#ifndef SCRIPT_MANAGER_HPP_\n    #define SCRIPT_MANAGER_HPP_\n\n    #include &lt;filesystem&gt;\n    #include &lt;memory&gt;\n    #include &lt;unordered_map&gt;\n    #include &lt;fstream&gt;\n    #include &lt;iostream&gt;\n    #include &lt;functional&gt;\n\n    #include \"Component/Components.hpp\"\n\n    #ifdef _WIN32\n        #include &lt;windows.h&gt;\n    #else\n        #include &lt;dlfcn.h&gt;\n    #endif\n\n    namespace ECS\n    {\n        /**\n        * This class loads the scripts from the asset directory\n        * All of the resource's key names correspond to the name of their files in the asset directory.\n        *\n        * The asset directory's structure cannot be modified.\n        *\n        */\n        class ScriptManager {\n            public:\n\n                ScriptManager(std::string path);\n                ~ScriptManager();\n\n                /**\n                * Returns a script wrapped in a shared_ptr, returns nullptr if not found.\n                * @param key name of the script\n                *\n                * @return Script\n                *\n                * @warning This function should not necessarily be used as the engine already uses it in its\n                * regular methods. For any prefab call, refer to script's methods or ECSManager's methods.\n                *\n                */\n                std::shared_ptr&lt;ECS::IScript&gt; getScript(const std::string &amp;key);\n\n            private:\n                std::unordered_map&lt;std::string, std::function&lt;std::shared_ptr&lt;ECS::IScript&gt;()&gt;&gt; _scripts;\n\n                // Platform-specific functions for loading libraries\n                std::string getSharedLibraryExtension();\n                void* loadSharedLibrary(const char* path);\n                void unloadSharedLibrary(void* handle);\n                void* getFunctionFromLibrary(void* handle, const char* funcName);\n        };\n    }\n\n#endif\n</code></pre>"},{"location":"coverage/ecs/src/Assets/SpriteManager.cpp/","title":"SpriteManager.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** ComponentManager\n** File description:\n** Component Manager\n*/\n\n#include \"SpriteManager.hpp\"\n\nECS::SpriteManager::SpriteManager(std::string path)\n{\n    this-&gt;_defaultSprite = std::make_shared&lt;ECS::SFMLDrawable&gt;();\n    if (!std::filesystem::exists(path + \"/sprite\")) {\n        return;\n    }\n    std::string key;\n    for (const auto &amp;entry : std::filesystem::directory_iterator(path + \"/sprite\")) {\n        if (entry.path().extension() == \".png\" || entry.path().extension() == \".jpg\") {\n            key = entry.path().stem().string();\n            this-&gt;_sprites[key] = std::make_shared&lt;ECS::SFMLDrawable&gt;();\n            if (this-&gt;_sprites[key]-&gt;loadFromFile(entry.path().string())) {\n                std::cout &lt;&lt; \"Successfully loaded sprite: \" &lt;&lt; key &lt;&lt; std::endl;\n                continue;\n            }\n            std::cerr &lt;&lt; \"Failed to load sprite: \" &lt;&lt; key &lt;&lt; std::endl;\n        }\n    }\n}\n\nECS::SpriteManager::~SpriteManager()\n{\n\n}\n\nstd::shared_ptr&lt;ECS::IDrawable&gt; ECS::SpriteManager::getSprite(const std::string&amp; key) {\n    auto it = _sprites.find(key);\n    if (it != _sprites.end()) {\n        return it-&gt;second-&gt;clone();\n    }\n    return _defaultSprite-&gt;clone();\n}\n</code></pre>"},{"location":"coverage/ecs/src/Assets/SpriteManager.hpp/","title":"SpriteManager.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** RType\n** File description:\n** EntityManager Class\n*/\n\n#ifndef SPRITE_MANAGER_HPP_\n    #define SPRITE_MANAGER_HPP_\n\n    #include &lt;filesystem&gt;\n    #include &lt;memory&gt;\n    #include &lt;unordered_map&gt;\n    #include &lt;fstream&gt;\n    #include &lt;iostream&gt;\n    #include &lt;functional&gt;\n\n    #include \"Component/Components.hpp\"\n    #include \"Interfaces/IDrawable.hpp\"\n    #include \"SFMLEncaps/SFMLDrawable.hpp\"\n\n    namespace ECS\n    {\n        /**\n        * This class loads the sprites from the asset directory\n        * All of the ressource's key names correspond to the name of their files in the asset directory.\n        *\n        * The asset directory's structure cannot be modified\n        *\n        */\n        class SpriteManager {\n            public:\n\n                SpriteManager(std::string path);\n                ~SpriteManager();\n\n                /**\n                * Returns a sprite, returns an empty one if not found\n                * @param key name of the sprite\n                *\n                * @return Sprite\n                *\n                */\n                std::shared_ptr&lt;ECS::IDrawable&gt; getSprite(const std::string&amp; key);\n\n            private:\n                std::unordered_map&lt;std::string, std::shared_ptr&lt;ECS::IDrawable&gt;&gt; _sprites;\n                std::shared_ptr&lt;ECS::IDrawable&gt; _defaultSprite;\n        };\n    }\n\n#endif\n</code></pre>"},{"location":"coverage/ecs/src/Assets/SystemPluginManager.cpp/","title":"SystemPluginManager.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** ComponentManager\n** File description:\n** Component Manager\n*/\n\n#include \"SystemPluginManager.hpp\"\n#include &lt;chrono&gt;\n#include &lt;fstream&gt;\n\nECS::SystemPluginManager::SystemPluginManager(std::string path)\n{\n    this-&gt;_assetsPath = path;\n    this-&gt;_lastFolderTimestamp = std::filesystem::last_write_time(path + \"/systems\");  // Get initial folder timestamp\n    this-&gt;setupSystemsFromFolder(path);\n}\n\nECS::SystemPluginManager::~SystemPluginManager() {}\n\nstd::shared_ptr&lt;ECS::ISystem&gt; ECS::SystemPluginManager::getSystem(const std::string &amp;key)\n{\n    if (_systems.count(key) == 0) {\n        return nullptr;\n    }\n    return _systems[key]();\n}\n\nstd::vector&lt;std::shared_ptr&lt;ECS::ISystem&gt;&gt; ECS::SystemPluginManager::getAllSystem(std::shared_ptr&lt;ECS::IWindow&gt;&amp; winPtr)\n{\n    std::vector&lt;std::pair&lt;std::string, std::function&lt;std::shared_ptr&lt;ECS::ISystem&gt;()&gt;&gt;&gt; systemsVec(\n        this-&gt;_systems.begin(), this-&gt;_systems.end());\n\n    std::sort(systemsVec.begin(), systemsVec.end(),\n              [](const auto&amp; a, const auto&amp; b) { return a.first &lt; b.first; });\n\n    std::vector&lt;std::shared_ptr&lt;ECS::ISystem&gt;&gt; list;\n    for (auto &amp;e : systemsVec) {\n        auto s = e.second();\n        if (s-&gt;doesNeedWindow()) {\n            s-&gt;setWindow(winPtr);\n        }\n        list.push_back(s);\n    }\n    return list;\n}\n\nvoid ECS::SystemPluginManager::setupSystemsFromFolder(const std::string &amp;path)\n{\n    if (!std::filesystem::exists(path + \"/systems\")) {\n        return;\n    }\n\n    for (const auto&amp; entry : std::filesystem::directory_iterator(path + \"/systems\")) {\n        if (entry.path().extension() == getSharedLibraryExtension()) {\n            void* handle = loadSharedLibrary(entry.path().string().c_str());\n            if (!handle) {\n                std::cerr &lt;&lt; \"Error loading shared object.\" &lt;&lt; std::endl;\n                continue;\n            }\n\n            auto createScript = (ECS::ISystem* (*)())getFunctionFromLibrary(handle, \"createSystem\");\n            if (!createScript) {\n                std::cerr &lt;&lt; \"Error finding symbol createSystem.\" &lt;&lt; std::endl;\n                unloadSharedLibrary(handle);\n                continue;\n            }\n\n            this-&gt;_systems[entry.path().stem().string()] = [handle = handle, createScript]() -&gt; std::shared_ptr&lt;ECS::ISystem&gt; {\n                return std::shared_ptr&lt;ECS::ISystem&gt;(createScript());\n            };\n\n            std::cout &lt;&lt; \"Successfully loaded system: \" &lt;&lt; entry.path().stem().string() &lt;&lt; std::endl;\n        }\n    }\n}\n\nbool ECS::SystemPluginManager::checkForFolderModifications()\n{\n    // Get the current folder's timestamp\n    std::filesystem::file_time_type currentFolderTimestamp = std::filesystem::last_write_time(this-&gt;_assetsPath + \"/systems\");\n\n    // Compare if the folder's timestamp has changed\n    if (currentFolderTimestamp &gt; _lastFolderTimestamp) {\n        std::cout &lt;&lt; \"Modification detected in the systems folder. Reloading systems...\" &lt;&lt; std::endl;\n        _lastFolderTimestamp = currentFolderTimestamp;  // Update the last known folder timestamp\n        this-&gt;_systems.clear();  // Clear existing systems\n        setupSystemsFromFolder(this-&gt;_assetsPath);  // Reload systems from folder\n        return true;\n    }\n\n    return false;\n}\n\n// Platform-specific implementations\n\n#ifdef _WIN32\n\n// Windows-specific implementations\nstd::string ECS::SystemPluginManager::getSharedLibraryExtension() {\n    return \".dll\";\n}\n\nvoid* ECS::SystemPluginManager::loadSharedLibrary(const char* path) {\n    return LoadLibrary(path);\n}\n\nvoid ECS::SystemPluginManager::unloadSharedLibrary(void* handle) {\n    FreeLibrary(reinterpret_cast&lt;HMODULE&gt;(handle));\n}\n\nvoid* ECS::SystemPluginManager::getFunctionFromLibrary(void* handle, const char* funcName) {\n    return reinterpret_cast&lt;void*&gt;(GetProcAddress(reinterpret_cast&lt;HMODULE&gt;(handle), funcName));\n}\n\n#else\n\n// Linux/macOS specific implementations\nstd::string ECS::SystemPluginManager::getSharedLibraryExtension() {\n    #ifdef __APPLE__\n        return \".dylib\";  // macOS\n    #else\n        return \".so\";  // Linux\n    #endif\n}\n\nvoid* ECS::SystemPluginManager::loadSharedLibrary(const char* path) {\n    return dlopen(path, RTLD_LAZY | RTLD_GLOBAL);\n}\n\nvoid ECS::SystemPluginManager::unloadSharedLibrary(void* handle) {\n    dlclose(handle);\n}\n\nvoid* ECS::SystemPluginManager::getFunctionFromLibrary(void* handle, const char* funcName) {\n    return dlsym(handle, funcName);\n}\n\n#endif\n</code></pre>"},{"location":"coverage/ecs/src/Assets/SystemPluginManager.hpp/","title":"SystemPluginManager.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** RType\n** File description:\n** EntityManager Class\n*/\n\n#ifndef SYSTEM_PLUGIN_MANAGER_HPP_\n    #define SYSTEM_PLUGIN_MANAGER_HPP_\n\n    #include &lt;filesystem&gt;\n    #include &lt;memory&gt;\n    #include &lt;unordered_map&gt;\n    #include &lt;fstream&gt;\n    #include &lt;iostream&gt;\n    #include &lt;functional&gt;\n    #include &lt;chrono&gt;\n\n    #include \"Interfaces/ISystem.hpp\"\n\n    #ifdef _WIN32\n        #include &lt;windows.h&gt;\n    #else\n        #include &lt;dlfcn.h&gt;\n    #endif\n\n    namespace ECS\n    {\n        class SystemPluginManager {\n            public:\n\n                SystemPluginManager(std::string path);\n                ~SystemPluginManager();\n\n                std::shared_ptr&lt;ECS::ISystem&gt; getSystem(const std::string &amp;key);\n                std::vector&lt;std::shared_ptr&lt;ECS::ISystem&gt;&gt; getAllSystem(std::shared_ptr&lt;ECS::IWindow&gt;&amp; winPtr);\n                void setupSystemsFromFolder(const std::string &amp;path);\n                bool checkForFolderModifications();\n\n            private:\n                std::unordered_map&lt;std::string, std::function&lt;std::shared_ptr&lt;ECS::ISystem&gt;()&gt;&gt; _systems;\n                std::string _assetsPath;\n                std::filesystem::file_time_type _lastFolderTimestamp;\n\n                std::string getSharedLibraryExtension();\n                void* loadSharedLibrary(const char* path);\n                void unloadSharedLibrary(void* handle);\n                void* getFunctionFromLibrary(void* handle, const char* funcName);\n        };\n    }\n\n#endif\n</code></pre>"},{"location":"coverage/ecs/src/Component/","title":"Component","text":"Name Lines Covered Uncovered Coverage Acceleration.hpp 0 0 0 100.0% Animation.hpp 0 0 0 100.0% Components.hpp 0 0 0 100.0% Drawable.hpp 0 0 0 100.0% DrawableText.hpp 0 0 0 100.0% Health.hpp 0 0 0 100.0% Hitbox.hpp 0 0 0 100.0% Parallax.hpp 0 0 0 100.0% Position.hpp 0 0 0 100.0% RigidBody.hpp 0 0 0 100.0% Script.hpp 0 0 0 100.0% SpriteSheet.hpp 0 0 0 100.0% State.hpp 0 0 0 100.0% Tag.hpp 0 0 0 100.0% Velocity.hpp 0 0 0 100.0% Summary 0 0 0 100.0%"},{"location":"coverage/ecs/src/Component/Acceleration.hpp/","title":"Acceleration.hpp","text":"<pre><code>#ifndef ACCELERATION_HPP_\n#define ACCELERATION_HPP_\n\n#include \"Types/Vector2D.hpp\"\n\nnamespace ECS::Component {\n\n    /**\n    * Acceleration of entity\n    *\n    * @param x X acceleration.\n    * @param y Y acceleration.\n    */\n    struct Acceleration {\n        ECS::Vector2Df vect;\n    };\n}\n\n#endif // ACCELERATION_HPP_\n</code></pre>"},{"location":"coverage/ecs/src/Component/Animation.hpp/","title":"Animation.hpp","text":"<pre><code>#ifndef ANIMATION_HPP_\n#define ANIMATION_HPP_\n\n#include \"Types/Rect2D.hpp\"\n\nnamespace ECS::Component {\n\n    /**\n    * Animation rect of entity\n    *\n    * @param rect Frame for sprite.\n    * @param fps Frame per second.\n    * @param destroyAtEnt If true, the entity will automatically be destroyed at the end of the animation, perfect for particles\n    */\n    struct Animation {\n        ECS::Rect2Di rect;\n        int fps;\n        int currentFps = 0;\n        bool animating = false;\n        bool destroyAtEnd = false;\n    };\n}\n\n#endif // ANIMATION_HPP_\n</code></pre>"},{"location":"coverage/ecs/src/Component/Components.hpp/","title":"Components.hpp","text":"<pre><code>#ifndef COMPONENTS_HPP_\n    #define COMPONENTS_HPP_\n\n    #include &lt;iostream&gt;\n    #include \"Types/Vector2D.hpp\"\n    #include \"Types/Rect2D.hpp\"\n    #include \"Interfaces/IDrawable.hpp\"\n    #include \"Interfaces/IAudio.hpp\"\n\n    #include \"../GUI_SFML_Graphics.hpp\"\n    #include \"../Script/IScript.hpp\"\n\n    #include \"Position.hpp\"\n    #include \"Velocity.hpp\"\n    #include \"Acceleration.hpp\"\n    #include \"Hitbox.hpp\"\n    #include \"State.hpp\"\n    #include \"Tag.hpp\"\n    #include \"Script.hpp\"\n    #include \"Drawable.hpp\"\n    #include \"Animation.hpp\"\n    #include \"SpriteSheet.hpp\"\n    #include \"Parallax.hpp\"\n    #include \"Health.hpp\"\n    #include \"RigidBody.hpp\"\n    #include \"DrawableText.hpp\"\n\n#endif // COMPONENTS_HPP_\n</code></pre>"},{"location":"coverage/ecs/src/Component/Drawable.hpp/","title":"Drawable.hpp","text":"<pre><code>#ifndef DRAWABLE_HPP_\n#define DRAWABLE_HPP_\n\n#include &lt;memory&gt;\n#include \"Interfaces/IDrawable.hpp\"\n\nnamespace ECS::Component {\n\n    /**\n    * Visual for entity\n    *\n    * @param sprite Sprite.\n    * @param center If true, the sprite will be centered based on it's position\n    */\n    struct Drawable {\n        std::shared_ptr&lt;ECS::IDrawable&gt; sprite;\n        bool center = false;\n    };\n}\n\n#endif // DRAWABLE_HPP_\n</code></pre>"},{"location":"coverage/ecs/src/Component/DrawableText.hpp/","title":"DrawableText.hpp","text":"<pre><code>#ifndef DRAWABLE_TEXT_HPP_\n    #define DRAWABLE_TEXT_HPP_\n\n    #include &lt;string&gt;\n\n    namespace ECS::Component {\n\n        /**\n        * Displayable text on the screen\n        *\n        * @param text Text\n        * @param size Size of the text\n        * @param center If true, the sprite will be centered based on it's position\n        */\n        struct DrawableText {\n            std::string text = \"\";\n            unsigned int size = 16;\n            bool center = false;\n        };\n    }\n\n#endif // DRAWABLE_TEXT_HPP_\n</code></pre>"},{"location":"coverage/ecs/src/Component/Health.hpp/","title":"Health.hpp","text":"<pre><code>#ifndef HEALTH_HPP_\n#define HEALTH_HPP_\n\nnamespace ECS::Component {\n\n    /**\n    * Health information for component\n    *\n    * @param health Health value\n    *\n    */\n    struct Health {\n        int health = 1;\n    };\n}\n\n#endif // HEALTH_HPP_\n</code></pre>"},{"location":"coverage/ecs/src/Component/Hitbox.hpp/","title":"Hitbox.hpp","text":"<pre><code>#ifndef HITBOX_HPP_\n#define HITBOX_HPP_\n\n#include \"Types/Rect2D.hpp\"\n\nnamespace ECS::Component {\n\n    /**\n    * Rectangle box for collisions/zone/etc...\n    *\n    * @param x X outset.\n    * @param y Y outset.\n    * @param w width.\n    * @param h height.\n    */\n    struct Hitbox {\n        ECS::Rect2Df bounds;\n    };\n}\n\n#endif // HITBOX_HPP_\n</code></pre>"},{"location":"coverage/ecs/src/Component/Parallax.hpp/","title":"Parallax.hpp","text":"<pre><code>#ifndef PARALLAX_HPP_\n#define PARALLAX_HPP_\n\nnamespace ECS::Component {\n\n    /**\n    * Parallax movement for entity\n    *\n    * @param speed Speed of parallax, goes backwards if negative value.\n    *\n    * @warning Float values can sometimes not work, for onsistency, only use int values\n    */\n    struct Parallax {\n        float speed = 0.5f;\n    };\n}\n\n#endif // PARALLAX_HPP_\n</code></pre>"},{"location":"coverage/ecs/src/Component/Position.hpp/","title":"Position.hpp","text":"<pre><code>#ifndef POSITION_HPP_\n#define POSITION_HPP_\n\n#include \"Types/Vector2D.hpp\"\n\nnamespace ECS::Component {\n\n    /**\n    * Position inside world space\n    *\n    * @param x X position.\n    * @param y Y position.\n    */\n    struct Position {\n        ECS::Vector2Df vect;\n    };\n}\n\n#endif // POSITION_HPP_\n</code></pre>"},{"location":"coverage/ecs/src/Component/RigidBody.hpp/","title":"RigidBody.hpp","text":"<pre><code>#ifndef RIGIDBODY_HPP_\n#define RIGIDBODY_HPP_\n\nnamespace ECS::Component {\n\n    /**\n    * Physics information for component\n    *\n    * @param gravityScale impact scale of the gravity\n    * @param mass mass of the object\n    * @param bounce defines if the entity acts like a wall for other entities\n    *\n    */\n    struct RigidBody {\n        double gravityScale, mass;\n        bool bounce;\n    };\n}\n\n#endif // RIGIDBODY_HPP_\n</code></pre>"},{"location":"coverage/ecs/src/Component/Script.hpp/","title":"Script.hpp","text":"<pre><code>#ifndef SCRIPT_HPP_\n#define SCRIPT_HPP_\n\n#include &lt;memory&gt;\n#include \"Script/IScript.hpp\"\n#include &lt;iostream&gt;\n\nnamespace ECS::Component {\n\n    /**\n    * Scripting on entity\n    *\n    * @param name Script name.\n    */\n    struct Script {\n        std::shared_ptr&lt;ECS::IScript&gt; content = nullptr;\n        bool hasStarted = false;\n    };\n}\n\n#endif // SCRIPT_HPP_\n</code></pre>"},{"location":"coverage/ecs/src/Component/SpriteSheet.hpp/","title":"SpriteSheet.hpp","text":"<pre><code>#ifndef SPRITESHEET_HPP_\n#define SPRITESHEET_HPP_\n\n#include &lt;iostream&gt;\n\nnamespace ECS::Component {\n\n    /**\n    * Spritesheet info for selecting Sprite part on One line\n    *\n    * @param nbrOfState nbr of different states avaliable.\n    * @param state state selected.\n    * \n    * @warning THIS COMPONENT IS NOT IMPLEMENTED OR FUNCTIONAL\n    */\n    struct SpriteSheet {\n        int nbrOfState;\n        int state;\n    };\n}\n\n#endif // SPRITESHEET_HPP_\n</code></pre>"},{"location":"coverage/ecs/src/Component/State.hpp/","title":"State.hpp","text":"<pre><code>#ifndef STATE_HPP_\n#define STATE_HPP_\n\n#include &lt;string&gt;\n\nnamespace ECS::Component {\n\n    /**\n    * State value usable for StateMachine or simply indicating a state\n    *\n    * @param name State name.\n    */\n    struct State {\n        std::string value = \"\";\n    };\n}\n\n#endif // STATE_HPP_\n</code></pre>"},{"location":"coverage/ecs/src/Component/Tag.hpp/","title":"Tag.hpp","text":"<pre><code>#ifndef TAG_HPP_\n#define TAG_HPP_\n\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n\nnamespace ECS::Component {\n\n    /**\n    * Tag value usable for entity labeling/categorisation\n    * Usefull for entity differentiation when colliding for example\n    *\n    * @param name State name.\n    */\n    struct Tag {\n        std::string value = \"\";\n    };\n}\n\n#endif // TAG_HPP_\n</code></pre>"},{"location":"coverage/ecs/src/Component/Velocity.hpp/","title":"Velocity.hpp","text":"<pre><code>#ifndef VELOCITY_HPP_\n#define VELOCITY_HPP_\n\n#include \"Types/Vector2D.hpp\"\n\nnamespace ECS::Component {\n\n    /**\n    * Velocity of entity\n    *\n    * @param x X speed.\n    * @param y Y speed.\n    */\n    struct Velocity {\n        ECS::Vector2Df vect;\n    };\n}\n\n#endif // VELOCITY_HPP_\n</code></pre>"},{"location":"coverage/ecs/src/Interfaces/","title":"Interfaces","text":"Name Lines Covered Uncovered Coverage IAudio.hpp 0 0 0 100.0% ICamera.hpp 0 0 0 100.0% IDrawable.hpp 0 0 0 100.0% IDrawableText.hpp 0 0 0 100.0% ISystem.hpp 0 0 0 100.0% IWindow.hpp 0 0 0 100.0% Summary 0 0 0 100.0%"},{"location":"coverage/ecs/src/Interfaces/IAudio.hpp/","title":"IAudio.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** ErrorException\n*/\n\n#ifndef ECS_I_AUDIO_H\n    #define ECS_I_AUDIO_H\n\n    #include \"Types/Vector2D.hpp\"\n\n    namespace ECS {\n\n        /**\n        * The interface for Audio assets used in the engine\n        *\n        * The abstraction has to use it's own methods to make the asset work.\n        *\n        */\n        class IAudio {\n        public:\n            virtual ~IAudio() = default;\n\n            /**\n            * Loads the audio from a filepath\n            * @param filepath filepath of the audio\n            *\n            * @return was the audio created properly.\n            *\n            */\n            virtual bool loadFromFile(std::string filepath) = 0;\n\n            /**\n            * Set the volume of the audio\n            * @param volume volume of the audio\n            *\n            */\n            virtual void setVolume(const float &amp;volume) = 0;\n\n            /**\n            * Get the volume of the audio\n            *\n            * @return volume of the audio\n            *\n            */\n            virtual const float &amp;getVolume() = 0;\n\n            /**\n            * Sets if the audio loops.\n            * @param loop audio loops\n            *\n            */\n            virtual void setLoop(bool loop) = 0;\n\n            /**\n            * Sets if the audio can be played while it's already playing\n            * @param spam audio can be played when playing\n            *\n            */\n            virtual void setSpamable(bool spam) = 0;\n\n            /**\n            * Play the audio\n            *\n            */\n            virtual void play() = 0;\n\n            /**\n            * Stops the audio\n            *\n            */\n            virtual void stop() = 0;\n        };\n\n    } // namespace ECS\n\n#endif // ECS_IDRAWABLE_H\n</code></pre>"},{"location":"coverage/ecs/src/Interfaces/ICamera.hpp/","title":"ICamera.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** ErrorException\n*/\n\n#ifndef I_CAMERA_H\n    #define I_CAMERA_H\n\n    #include \"Types/Vector2D.hpp\"\n    #include \"Types/Rect2D.hpp\"\n\n    namespace ECS {\n\n        /**\n        * The interface for the Camera used in the engine\n        *\n        * The abstraction has to use it's own methods to make the camera work.\n        * The abstraction of this interface will be managed by the Window abstraction.\n        *\n        */\n        class ICamera {\n        public:\n            virtual ~ICamera() = default;\n\n            /**\n            * Set the position of the camera\n            * @param pos New position\n            *\n            */\n            virtual void setPosition(const ECS::Vector2Df &amp;pos) = 0;\n\n            /**\n            * Get the position of the camera\n            * @return Position of the camera\n            *\n            */\n            virtual const ECS::Vector2Df &amp;getPosition() = 0;\n\n            /**\n            * Set the size of the camera\n            * @param size New size of the camera\n            *\n            */\n            virtual void setSize(const ECS::Vector2Du &amp; size) = 0;\n\n            /**\n            * Get the size of the camera\n            * @return Size of the camera\n            *\n            */\n            virtual const ECS::Vector2Du &amp;getSize() = 0;\n\n            /**\n            * Get the camera's hitbox bounds\n            * @return Bounds of the camera\n            *\n            */\n            virtual const ECS::Rect2Df &amp;getBounds() = 0;\n\n            /**\n            * Set the zoom of the camera\n            * @param zoom Zoom of the camera\n            *\n            */\n            virtual void setZoom(float zoom) = 0;\n\n            /**\n            * Get the zoom of the camera\n            * @return Zoom of the camera\n            *\n            */\n            virtual float getZoom() const = 0;\n\n            /**\n            * Set the rotation of the camera\n            * @param angle Rotation angle of the camera\n            *\n            */\n            virtual void setRotation(float angle) = 0;\n\n            /**\n            * Get the rotation of the camera\n            * @return Rotation angle of the camera\n            *\n            */\n            virtual float getRotation() const = 0;\n\n            /**\n            * Apply the camera's effect based on it's parameters if necessary\n            *\n            */\n            virtual void apply() const = 0;\n\n            /**\n            * Move the position of the camera by movement\n            * @param movement Movement vector\n            *\n            */\n            virtual void move(const ECS::Vector2Df &amp;movement) = 0;\n        };\n\n    } // namespace ECS\n\n#endif // ECS_ICAMERA_H\n</code></pre>"},{"location":"coverage/ecs/src/Interfaces/IDrawable.hpp/","title":"IDrawable.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** ErrorException\n*/\n\n#ifndef ECS_I_DRAWABLE_H\n    #define ECS_I_DRAWABLE_H\n\n    #include \"Types/Vector2D.hpp\"\n    #include \"Types/Rect2D.hpp\"\n    #include &lt;memory&gt;\n\n    namespace ECS {\n\n        /**\n        * The interface for Drawable assets used in the engine\n        *\n        * The abstraction has to use it's own methods to make the asset work.\n        *\n        */\n        class IDrawable {\n        public:\n            virtual ~IDrawable() = default;\n\n            /**\n            * Method to clone the shared_ptr of the drawable\n            * @return cloned drawable\n            *\n            */\n            virtual std::shared_ptr&lt;IDrawable&gt; clone() const = 0;\n\n            /**\n            * Loads the drawable from a filepath\n            * @param filepath filepath of the drawable\n            *\n            * @return was the drawable created properly.\n            *\n            */\n            virtual bool loadFromFile(std::string filepath) = 0;\n\n            /**\n            * Set the position of the drawable\n            * @param pos New position\n            *\n            */\n            virtual void setPosition(const ECS::Vector2Df &amp;pos) = 0;\n\n            /**\n            * Get the position of the drawable\n            * @return Position of the drawable\n            *\n            */\n            virtual const ECS::Vector2Df &amp;getPosition() = 0;\n\n            /**\n            * Set the texture rect of the Drawable\n            * @param rect New rect of the texture\n            *\n            */\n            virtual void setTextureRect(const ECS::Rect2Di &amp;rect) = 0;\n\n            /**\n            * Loads the audio from a filepath\n            * @return Texture rect of the Drawable\n            *\n            */\n            virtual const ECS::Rect2Di &amp;getTextureRect() = 0;\n\n            /**\n            * Set the origin point of the drawable on the texture\n            * @param pos Position on the texture.\n            *\n            */\n            virtual void setOrigin(const ECS::Vector2Df &amp;pos) = 0;\n\n            /**\n            * Get the origin point of the drawable on the texture\n            * @return Origin point of the drawable on the texture\n            *\n            */\n            virtual const ECS::Vector2Df &amp;getOrigin() = 0;\n\n            /**\n            * Get the size of the texture of the drawable\n            * @return Rect of the texture\n            *\n            */\n            virtual const ECS::Vector2Du &amp;getTextureSize() = 0;\n\n            /**\n            * Set the scale of the drawable\n            * @param pos New scale\n            *\n            */\n            virtual void setScale(const ECS::Vector2Df &amp;scale) = 0;\n\n            /**\n            * Get the scale of the drawable\n            * @return Scale of the drawable\n            *\n            */\n            virtual const ECS::Vector2Df &amp;getScale() = 0;\n        };\n\n    } // namespace ECS\n\n#endif // ECS_IDRAWABLE_H\n</code></pre>"},{"location":"coverage/ecs/src/Interfaces/IDrawableText.hpp/","title":"IDrawableText.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2025\n** Rtype\n** File description:\n** IDrawableText\n*/\n\n#ifndef ECS_I_DRAWABLE_TEXT_H\n    #define ECS_I_DRAWABLE_TEXT_H\n\n    #include &lt;memory&gt;\n    #include \"Types/Vector2D.hpp\"\n\n    namespace ECS {\n\n        /**\n        * The interface for Drawable text assets used in the engine\n        *\n        * The abstraction has to use its own methods to make the text work.\n        *\n        */\n        class IDrawableText {\n        public:\n            virtual ~IDrawableText() = default;\n\n            /**\n            * Set the string of the drawable text\n            * @param text New text string\n            *\n            */\n            virtual void setText(const std::string &amp;text) = 0;\n\n            /**\n            * Get the string of the drawable text\n            * @return Text string of the drawable\n            *\n            */\n            virtual const std::string &amp;getText() const = 0;\n\n            /**\n            * Set the position of the drawable text\n            * @param pos New position\n            *\n            */\n            virtual void setPosition(const ECS::Vector2Df &amp;pos) = 0;\n\n            /**\n            * Get the position of the drawable text\n            * @return Position of the drawable\n            *\n            */\n            virtual const ECS::Vector2Df &amp;getPosition() = 0;\n\n            /**\n            * Set the font of the drawable text\n            * @param font New font to use\n            *\n            */\n            virtual bool setFont(const std::string &amp;fontFilepath) = 0;\n\n            /**\n            * Set the character size of the drawable text\n            * @param size New character size\n            *\n            */\n            virtual void setCharacterSize(unsigned int size) = 0;\n\n            /**\n            * Get the character size of the drawable text\n            * @return Character size of the drawable\n            *\n            */\n            virtual const unsigned int getCharacterSize() const = 0;\n\n            /**\n            * Set the origin point of the drawable text\n            * @param origin Origin position on the text\n            *\n            */\n            virtual void setOrigin(const ECS::Vector2Df &amp;origin) = 0;\n\n            /**\n            * Get the origin point of the drawable text\n            * @return Origin point of the drawable text\n            *\n            */\n            virtual const ECS::Vector2Df &amp;getOrigin() = 0;\n\n        };\n\n    } // namespace ECS\n\n#endif // ECS_I_DRAWABLE_TEXT_H\n</code></pre>"},{"location":"coverage/ecs/src/Interfaces/ISystem.hpp/","title":"ISystem.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** ErrorException\n*/\n\n#ifndef I_SYSTEM_HPP\n    #define I_SYSTEM_HPP\n\n    #include \"Managers/Registry.hpp\"\n    #include \"Interfaces/IWindow.hpp\"\n\n    namespace ECS {\n\n        /**\n        * The interface for the Camera used in the engine\n        *\n        * The abstraction has to use it's own methods to make the camera work.\n        * The abstraction of this interface will be managed by the Window abstraction.\n        *\n        */\n        class ISystem {\n        public:\n            virtual ~ISystem() = default;\n\n            virtual void update(ECS::Registry &amp;R, double dt) = 0;\n            virtual bool doesNeedWindow() = 0;\n            virtual void setWindow(std::shared_ptr&lt;ECS::IWindow&gt;&amp; winPtr) = 0;\n        };\n\n    } // namespace ECS\n\n#endif // ECS_ICAMERA_H\n</code></pre>"},{"location":"coverage/ecs/src/Interfaces/IWindow.hpp/","title":"IWindow.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** ErrorException\n*/\n\n#ifndef I_WINDOW_HPP_\n    #define I_WINDOW_HPP_\n\n    #include \"Types/Vector2D.hpp\"\n    #include \"Types/Inputs.hpp\"\n    #include \"ICamera.hpp\"\n    #include \"IDrawable.hpp\"\n    #include \"IDrawableText.hpp\"\n\n    namespace ECS\n    {\n        /**\n        * The interface for the window used in the engine\n        * It is both responsible for window management as well as input management\n        *\n        * The abstraction has to use it's own methods to make the window work.\n        *\n        */\n        class IWindow\n        {\n            public:\n                virtual ~IWindow() = default;\n\n                /**\n                * Opens the window of a certain size\n                * @param title Name of the window\n                * \n                * @param size Size of the window\n                *\n                * @return True if open successfully, False if not\n                *\n                */\n                virtual bool open(const std::string&amp; title, ECS::Vector2Du size) = 0;\n\n                /**\n                * Close the window\n                *\n                */\n                virtual void close() = 0;\n\n                /**\n                * Clears the window's graphical content\n                *\n                */\n                virtual void clear() = 0;\n\n                /**\n                * Draws a IDrawable on the window\n                * @param drawable Drawable to draw on the window\n                *\n                */\n                virtual void draw(ECS::IDrawable &amp;drawable) = 0;\n\n                /**\n                * Draws a IDrawableText on the window\n                * @param drawable IDrawableText to draw on the window\n                *\n                */\n                virtual void drawText(std::string text, unsigned int size, ECS::Vector2Df pos) = 0;\n\n                /**\n                * Displays all the IDrawables that have been drawn using the draw method\n                *\n                */\n                virtual void display() = 0;\n\n                /**\n                * Checks if the window is open or not\n                * @return True if open, false is not\n                *\n                */\n                virtual bool isOpen() = 0;\n\n                /**\n                * Get the size of the window\n                * @return Window size\n                *\n                */\n                virtual const ECS::Vector2Du &amp;getSize() = 0;\n\n                /**\n                * Set the size of the window\n                * @param size New size of the window\n                *\n                */\n                virtual void setSize(const ECS::Vector2Du &amp;size) = 0;\n\n                /**\n                * Set the framerate of the window\n                * @param fps New framerate\n                *\n                */\n                virtual void setFramerate(unsigned int fps) = 0;\n\n                /**\n                * Set the ICamera abstraction that will be used by the window\n                * @param camera Shared pointer of the ICamera object\n                *\n                */\n                virtual void setCamera(std::shared_ptr&lt;ICamera&gt; camera) = 0;\n\n                /**\n                * Get the ICamera used by the window\n                * @return Shared pointer of the ICamera object\n                *\n                */\n                virtual std::shared_ptr&lt;ICamera&gt; getCamera() = 0;\n\n                /**\n                * Checks if a key is pressed or not\n                * @param key Key value to check\n                * \n                * @return True if pressed, False if not\n                *\n                */\n                virtual bool isKeyPressed(ECS::Key key) = 0;\n\n                /**\n                * Checks if a key was pressed this frame or not\n                * @param key Key value to check\n                * \n                * @return True if just pressed, False if not\n                *\n                */\n                virtual bool isKeyJustPressed(ECS::Key key) = 0;\n\n                /**\n                * Checks if the left mouse button is pressed or not\n                *\n                * @return True if pressed, False if not\n                *\n                */\n                virtual bool isLeftMousePressed() = 0;\n\n                /**\n                * Checks if the left mouse button was just released or not\n                *\n                * @return True if just released, False if not\n                *\n                */\n                virtual bool isLeftMouseJustReleased() = 0;\n\n                /**\n                * Checks if the left mouse button was just pressed or not\n                *\n                * @return True if just pressed, False if not\n                *\n                */\n                virtual bool isLeftMouseJustPressed() = 0;\n\n                /**\n                * Checks if the right mouse button is pressed or not\n                *\n                * @return True if pressed, False if not\n                *\n                */\n                virtual bool isRightMousePressed() = 0;\n\n                /**\n                * Checks if the right mouse button was just released or not\n                *\n                * @return True if just released, False if not\n                *\n                */\n                virtual bool isRightMouseJustReleased() = 0;\n\n                /**\n                * Checks if the right mouse button was just pressed or not\n                *\n                * @return True if pressed, False if not\n                *\n                */\n                virtual bool isRightMouseJustPressed() = 0;\n\n                /**\n                * Returns the position of the mouse in the game world\n                *\n                * @return Position of the mouse in the game world\n                *\n                */\n                virtual const ECS::Vector2Di &amp;getMousePosition() = 0;\n\n                /**\n                * Returns the translation of the mouse in the game world\n                *\n                * @return Translation vector of the mouse in the game world\n                *\n                */\n                virtual const ECS::Vector2Di &amp;getMouseTranslation() = 0;\n\n        };\n    }\n\n#endif\n</code></pre>"},{"location":"coverage/ecs/src/Managers/","title":"Managers","text":"Name Lines Covered Uncovered Coverage ComponentManager.cpp 0 0 0 100.0% ComponentManager.hpp 20 0 20 0.0% ComponentStorage.hpp 9 0 9 0.0% EntityManager.cpp 14 0 14 0.0% EntityManager.hpp 0 0 0 100.0% GlobalDataManager.cpp 0 0 0 100.0% GlobalDataManager.hpp 6 0 6 0.0% Registry.hpp 19 0 19 0.0% SystemManager.cpp 13 0 13 0.0% SystemManager.hpp 1 0 1 0.0% Systems.hpp 0 0 0 100.0% Summary 82 0 82 0.0%"},{"location":"coverage/ecs/src/Managers/ComponentManager.cpp/","title":"ComponentManager.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** ComponentManager\n** File description:\n** Component Manager\n*/\n\n#include \"ComponentManager.hpp\"\n\nECS::ComponentManager::ComponentManager()\n{\n\n}\n</code></pre>"},{"location":"coverage/ecs/src/Managers/ComponentManager.hpp/","title":"ComponentManager.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** RType\n** File description:\n** EntityManager Class\n*/\n\n#ifndef COMPONENT_MANAGER_HPP_\n    #define COMPONENT_MANAGER_HPP_\n\n    #include &lt;typeindex&gt;\n    #include &lt;any&gt;\n    #include &lt;iostream&gt;\n    #include &lt;optional&gt;\n    #include &lt;memory&gt;\n    #include &lt;queue&gt;\n    #include &lt;map&gt;\n    #include &lt;unordered_map&gt;\n    #include &lt;vector&gt;\n    #include &lt;algorithm&gt;\n\n    #include \"Entity.hpp\"\n    #include \"ComponentStorage.hpp\"\n\n    namespace ECS\n    {\n        /**\n        * Stores and Manages all of the components of all entities currently existing\n        * The template \"Component\" corresponds to all of the structs avaliable in Components.hpp\n        *\n        */\n        class ComponentManager {\n\n            public:\n                ComponentManager();\n\n                /**\n                * Add a component to an entity in the current world\n                * @param id Entity ID\n                * @tparam Component Component's struct which's values are setup or not\n                *\n                */\n                template &lt;typename Component&gt;\n                void addComponent(ECS::entity_id id, Component component) {\n                    std::type_index index = typeid(Component);\n                    if (this-&gt;_components.find(index) == this-&gt;_components.end()) {\n                        this-&gt;registerComponentStorage&lt;Component&gt;();\n                    }\n                    auto&amp; storage = getComponentStorage&lt;Component&gt;();\n                    storage.add(id, std::move(std::make_shared&lt;Component&gt;(component)));\n                    this-&gt;_entityWithComponent[index].push_back(id);\n                    // std::cout &lt;&lt; typeid(Component).name() &lt;&lt; std::endl;\n                }\n\n                /**\n                * Remove a component from an entity in the current world\n                * @param id Entity ID\n                * @tparam Component Component's struct\n                *\n                * @warning It should be called like this: removeComponent&lt;ComponentStructType&gt;(id)\n                *\n                */\n                template &lt;typename Component&gt;\n                void removeComponent(ECS::entity_id id) {\n                    std::type_index index = typeid(Component);\n                    auto&amp; storage = getComponentStorage&lt;Component&gt;();\n                    storage.remove(id);\n                    this-&gt;_entityWithComponent[index].erase(std::remove(this-&gt;_entityWithComponent[index].begin(), this-&gt;_entityWithComponent[index].end(), id), this-&gt;_entityWithComponent[index].end());\n                }\n\n                /**\n                * Remove all of the components from an entity\n                * @param id Entity ID\n                *\n                */\n                void removeAllComponents(ECS::entity_id id)\n                {\n                    for (auto &amp;e : this-&gt;_components) {\n                        this-&gt;_components[e.first]-&gt;remove(id);\n                        this-&gt;_entityWithComponent[e.first].erase(std::remove(this-&gt;_entityWithComponent[e.first].begin(), this-&gt;_entityWithComponent[e.first].end(), id), this-&gt;_entityWithComponent[e.first].end());\n                    }\n                }\n\n                /**\n                * Get a component from an entity in the current world, you can then modify the shared_ptr component\n                * to directly modify it's information inside the entity, no need to re-add it\n                * @param id Entity ID\n                * @tparam Component Component's struct\n                * \n                * @warning It should be called like this: getComponent&lt;ComponentStructType&gt;(id)\n                * \n                * @return Entity's component wrapped in a shared_ptr\n                *\n                */\n                template &lt;typename Component&gt;\n                std::optional&lt;std::shared_ptr&lt;Component&gt;&gt; getComponent(ECS::entity_id id) {\n                    return getComponentStorage&lt;Component&gt;().get(id);\n                }\n\n                template &lt;typename Component&gt;\n                std::shared_ptr&lt;ComponentStorage&lt;Component&gt;&gt; getComponents() {\n                    return getComponentStorage&lt;Component&gt;();\n                }\n\n                /**\n                * Returns a list of all the entities that have a component type, usefull when you create a System\n                * or want to know only certain entities to increase performance\n                * @tparam Component Component's struct\n                * \n                * @warning It should be called like this: getEntitiesWithComponent&lt;ComponentStructType&gt;()\n                *\n                */\n                template &lt;typename Component&gt;\n                std::vector&lt;ECS::entity_id&gt; getEntitiesWithComponent()\n                {\n                    return _entityWithComponent[typeid(Component)];\n                }\n\n                /**\n                * Returns the component storage of a component type\n                * @tparam Component Component's struct\n                * \n                * @warning It should be called like this: getComponentStorage&lt;ComponentStructType&gt;(id)\n                * \n                * @return Entity's component Storage\n                *\n                */\n                template &lt;typename Component&gt;\n                ComponentStorage&lt;Component&gt;&amp; getComponentStorage() {\n                    if (_components.count(typeid(Component)) == 0) {\n                        this-&gt;registerComponentStorage&lt;Component&gt;();\n                    }\n                    return *static_cast&lt;ComponentStorage&lt;Component&gt;*&gt;(_components[typeid(Component)].get());\n                }\n\n                template &lt;typename Component&gt;\n                void registerComponentStorage() {\n                    _components[typeid(Component)] = std::make_shared&lt;ComponentStorage&lt;Component&gt;&gt;();\n                }\n\n            private:\n                std::unordered_map&lt;std::type_index, std::vector&lt;ECS::entity_id&gt;&gt; _entityWithComponent;\n                std::unordered_map&lt;std::type_index, std::shared_ptr&lt;ComponentStorageBase&gt;&gt; _components;\n        };\n    }\n\n#endif\n</code></pre>"},{"location":"coverage/ecs/src/Managers/ComponentStorage.hpp/","title":"ComponentStorage.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** RType\n** File description:\n** EntityManager Class\n*/\n\n#ifndef COMPONENTSTORAGE_HPP_\n    #define COMPONENTSTORAGE_HPP_\n\n    #include \"../Entity.hpp\"\n\n    /**\n    * ComponentStorage Interface\n    *\n    */\n    class ComponentStorageBase {\n        public:\n            virtual ~ComponentStorageBase() = default;\n            virtual void remove(ECS::entity_id id) = 0;\n        };\n\n    /**\n    * Stores all of the components of a same type wrapped in a std::shared_ptr\n    *\n    * @tparam Component Struct of the component.\n    */\n    template &lt;typename Component&gt;\n    class ComponentStorage : public ComponentStorageBase {\n    public:\n        std::vector&lt;std::shared_ptr&lt;Component&gt;&gt; storage;\n\n        void resize(size_t entity_count) {\n            if (entity_count &gt;= storage.size()) {\n                storage.resize(entity_count + 1);\n            }\n        }\n\n        /**\n        * Get component wrapped in a std::optional\n        *\n        * @param id Entity ID.\n        */\n        std::optional&lt;std::shared_ptr&lt;Component&gt;&gt; get(ECS::entity_id id) {\n            if (id &gt;= storage.size()) {\n                return std::nullopt;\n            }\n            return storage[id];\n        }\n\n        /**\n        * Add a component for an entity\n        *\n        * @param id Entity ID.\n        */\n        void add(ECS::entity_id id, std::shared_ptr&lt;Component&gt; component) {\n            resize(id);\n            storage[id] = std::move(component);\n        }\n\n        /**\n        * Remove component from an entity\n        *\n        * @param id Entity ID.\n        */\n        void remove(ECS::entity_id id) {\n            if (id &lt; storage.size()) {\n                storage[id] = nullptr;\n            }\n        }\n    };\n\n#endif\n</code></pre>"},{"location":"coverage/ecs/src/Managers/EntityManager.cpp/","title":"EntityManager.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** RType\n** File description:\n** EntityManager Implementation\n*/\n\n#include \"EntityManager.hpp\"\n\nECS::EntityManager::EntityManager() : _livingEntityCount(0)\n{\n    for (entity_id id = 0; id &lt; ECS_MAX_ENTITY; id++) {\n        this-&gt;_availableIds[id] = ECS_MAX_ENTITY - 1 - id;\n    }\n}\n\nconst ECS::entity_id &amp;ECS::EntityManager::createEntity()\n{\n    const entity_id &amp;newID = this-&gt;_availableIds[this-&gt;_livingEntityCount];\n    this-&gt;_aliveEntities[newID] = true;\n    ++this-&gt;_livingEntityCount;\n    return newID;\n}\n\nvoid ECS::EntityManager::destroyEntity(const entity_id &amp;id)\n{\n    this-&gt;_aliveEntities[id] = false;\n    this-&gt;_availableIds[--this-&gt;_livingEntityCount] = id;\n}\n\nstd::vector&lt;ECS::entity_id&gt; ECS::EntityManager::getAllEntities()\n{\n    std::vector&lt;entity_id&gt; list;\n    list.reserve(this-&gt;_livingEntityCount);\n\n    for (entity_id i = 0; i &lt; ECS_MAX_ENTITY; ++i) {\n        if (this-&gt;_aliveEntities[i]) {\n            list.push_back(i);\n        }\n    }\n    return list;\n}\n</code></pre>"},{"location":"coverage/ecs/src/Managers/EntityManager.hpp/","title":"EntityManager.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** RType\n** File description:\n** EntityManager Class\n*/\n\n#ifndef ENTITY_MANAGER_HPP_\n    #define ENTITY_MANAGER_HPP_\n\n    #include &lt;vector&gt;\n    #include &lt;array&gt;\n    #include &lt;bitset&gt;\n    #include \"Entity.hpp\"\n\n    #define ECS_MAX_ENTITY 32000\n\n    namespace ECS {\n\n    class EntityManager {\n    public:\n        EntityManager();\n\n        /**\n        * Create an empty entity in the current world\n        *\n        * @return Created entity ID\n        */\n        const entity_id &amp;createEntity();\n\n        /**\n        * Destroy an entity in the current world\n        * @param id ID of the entity to destroy\n        *\n        */\n        void destroyEntity(const entity_id &amp;id);\n\n        /**\n        * Returns all of the entities in the registry\n        *\n        * @return List of all entities\n        */\n        std::vector&lt;entity_id&gt; getAllEntities();\n\n    private:\n        std::array&lt;entity_id, ECS_MAX_ENTITY&gt; _availableIds;  // Pool of entity IDs\n        std::bitset&lt;ECS_MAX_ENTITY&gt; _aliveEntities;           // Tracks which entities are alive\n        std::size_t _livingEntityCount;                       // Number of active entities\n    };\n\n    } // namespace ECS\n\n#endif // ENTITY_MANAGER_HPP_\n</code></pre>"},{"location":"coverage/ecs/src/Managers/GlobalDataManager.cpp/","title":"GlobalDataManager.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** ComponentManager\n** File description:\n** Component Manager\n*/\n\n#include \"GlobalDataManager.hpp\"\n\nECS::GlobalDataManager::GlobalDataManager()\n{\n\n}\n\nECS::GlobalDataManager::~GlobalDataManager()\n{\n\n}\n</code></pre>"},{"location":"coverage/ecs/src/Managers/GlobalDataManager.hpp/","title":"GlobalDataManager.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** RType\n** File description:\n** SystemManager Class\n*/\n\n#ifndef ECS_GLOBAL_DATA_MANAGER_HPP_\n    #define ECS_GLOBAL_DATA_MANAGER_HPP_\n\n    #include &lt;memory&gt;\n    #include &lt;string&gt;\n    #include &lt;functional&gt;\n    #include &lt;any&gt;\n\n    namespace ECS\n    {\n        /**\n        * Responsible for storing and sending global variables to allow communication between scripts\n        * \n        * The variables can be of any type\n        *\n        */\n        class GlobalDataManager {\n\n            public:\n                GlobalDataManager();\n                ~GlobalDataManager();\n\n                /**\n                * Sets a variable of any type at an index\n                * @tparam Variable type\n                * \n                * @warning It should be called like this: set&lt;VariableType&gt;(index, value)\n                *\n                */\n                template &lt;typename T&gt;\n                void set(const std::string &amp;index, const T&amp; value) {\n                    _globalVariables[index] = value;\n                }\n\n                /**\n                * Returns a variable of any type at an index\n                * @tparam Variable type\n                *\n                * @warning It should be called like this: get&lt;VariableType&gt;(index)\n                *\n                * @return Variable of type VariableType\n                *\n                */\n                template &lt;typename T&gt;\n                T get(const std::string &amp;index) {\n                    if (_globalVariables.find(index) != _globalVariables.end()) {\n                        const std::any &amp;value = _globalVariables[index];\n                        if (value.type() == typeid(T)) {\n                            return std::any_cast&lt;T&gt;(value); // Safe to cast if types match\n                        }\n                    }\n                    return T();\n                }\n\n            private:\n                std::unordered_map&lt;std::string, std::any&gt; _globalVariables;\n\n        };\n    }\n\n#endif\n</code></pre>"},{"location":"coverage/ecs/src/Managers/Registry.hpp/","title":"Registry.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** RType\n** File description:\n** EntityManager Class\n*/\n\n#ifndef REGISTRY_HPP_\n    #define REGISTRY_HPP_\n\n    #include &lt;memory&gt;\n\n    #include \"EntityManager.hpp\"\n    #include \"ComponentManager.hpp\"\n\n    namespace ECS\n    {\n        /**\n        * Mediator that wraps Component and Entity manager, this should be where you\n        * manipulate a world's content. It also contains all the entities of the world.\n        *\n        */\n        class Registry {\n\n            public:\n                Registry()\n                {\n                    this-&gt;_entityManager = std::make_unique&lt;ECS::EntityManager&gt;();\n                    this-&gt;_componentManager = std::make_unique&lt;ECS::ComponentManager&gt;();\n                }\n\n                ~Registry()\n                {\n                    std::vector&lt;ECS::entity_id&gt; allEntities = this-&gt;_entityManager-&gt;getAllEntities();\n                    for (auto &amp;e : allEntities) {\n                        this-&gt;removeAllComponents(e);\n                        this-&gt;destroyEntity(e);\n                    }\n                }\n\n                const ECS::entity_id &amp;createEntity()\n                {\n                    return this-&gt;_entityManager-&gt;createEntity();\n                }\n\n                void destroyEntity(const entity_id &amp;id)\n                {\n                    this-&gt;_entityManager-&gt;destroyEntity(id);\n                    this-&gt;removeAllComponents(id);\n                }\n\n                std::vector&lt;ECS::entity_id&gt; getAllEntities()\n                {\n                    return this-&gt;_entityManager-&gt;getAllEntities();\n                }\n\n                template &lt;typename Component&gt;\n                void addComponent(ECS::entity_id id, Component comp)\n                {\n                    this-&gt;_componentManager-&gt;addComponent(id, comp);\n                }\n\n                template &lt;typename Component&gt;\n                void removeComponent(ECS::entity_id id)\n                {\n                    this-&gt;_componentManager-&gt;removeComponent&lt;Component&gt;(id);\n                }\n\n                void removeAllComponents(ECS::entity_id id)\n                {\n                    this-&gt;_componentManager-&gt;removeAllComponents(id);\n                }\n\n                template &lt;typename Component&gt;\n                std::shared_ptr&lt;Component&gt; getComponent(ECS::entity_id id)\n                {\n                    std::optional&lt;std::shared_ptr&lt;Component&gt;&gt; comp = this-&gt;_componentManager-&gt;getComponent&lt;Component&gt;(id);\n                    if (comp == std::nullopt) {\n                        return nullptr;\n                    }\n                    return comp.value();\n                }\n\n                template &lt;typename Component&gt;\n                std::vector&lt;ECS::entity_id&gt; getEntitiesWithComponent()\n                {\n                    return this-&gt;_componentManager-&gt;getEntitiesWithComponent&lt;Component&gt;();\n                }\n\n                template &lt;typename Component&gt;\n                ComponentStorage&lt;Component&gt; getComponents() {\n                    // auto&amp; storage = getComponentStorage&lt;Component&gt;();\n                    return this-&gt;_componentManager-&gt;getComponentStorage&lt;Component&gt;();\n                }\n\n\n            private:\n                std::unique_ptr&lt;ECS::ComponentManager&gt; _componentManager;\n                std::unique_ptr&lt;ECS::EntityManager&gt; _entityManager;\n\n        };\n    }\n\n#endif\n</code></pre>"},{"location":"coverage/ecs/src/Managers/SystemManager.cpp/","title":"SystemManager.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** SystemManager\n** File description:\n** System Manager\n*/\n\n#include \"SystemManager.hpp\"\n\nECS::SystemManager::SystemManager(std::shared_ptr&lt;ECS::IWindow&gt;&amp; winPtr)\n{\n    this-&gt;_systemPluginManager = std::make_unique&lt;ECS::SystemPluginManager&gt;(\"./assets\");\n    this-&gt;_lastTime = std::chrono::steady_clock::now();\n    this-&gt;_systems = this-&gt;_systemPluginManager-&gt;getAllSystem(winPtr);\n    this-&gt;_winPtr = winPtr;\n}\n\nECS::SystemManager::~SystemManager()\n{\n\n}\n\nvoid ECS::SystemManager::runAllSystems(ECS::Registry &amp;R)\n{\n    auto currentTime = std::chrono::steady_clock::now();\n    std::chrono::duration&lt;float&gt; delta = currentTime - _lastTime;\n    _lastTime = currentTime;\n    this-&gt;_dt = delta.count();\n\n    if (this-&gt;_systemPluginManager-&gt;checkForFolderModifications()) {\n        this-&gt;_systems = this-&gt;_systemPluginManager-&gt;getAllSystem(this-&gt;_winPtr);\n    }\n\n    for (auto &amp;system : this-&gt;_systems) {\n        system-&gt;update(R, this-&gt;_dt);\n    }\n}\n\ndouble ECS::SystemManager::getDeltaTime()\n{\n    return this-&gt;_dt;\n}\n</code></pre>"},{"location":"coverage/ecs/src/Managers/SystemManager.hpp/","title":"SystemManager.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** RType\n** File description:\n** SystemManager Class\n*/\n\n#ifndef SYSTEM_MANAGER_HPP_\n    #define SYSTEM_MANAGER_HPP_\n\n    #include &lt;memory&gt;\n    #include &lt;functional&gt;\n    #include &lt;chrono&gt;\n    #include &lt;cmath&gt;\n\n    #include \"Interfaces/ISystem.hpp\"\n    #include \"Assets/SystemPluginManager.hpp\"\n\n    namespace ECS\n    {\n        /**\n        * Responsible for running and adding systems that are active during the execution\n        * It also keeps track of the deltaTime between frames\n        *\n        */\n        class SystemManager {\n\n            public:\n                SystemManager(std::shared_ptr&lt;ECS::IWindow&gt;&amp; winPtr);\n                ~SystemManager();\n\n                template &lt;typename System, typename... Args&gt;\n                void addSystem(Args&amp;&amp;... args)\n                {\n                    this-&gt;_systems.push_back(std::make_unique&lt;System&gt;(std::forward&lt;Args&gt;(args)...));\n                }\n\n                void runAllSystems(ECS::Registry &amp;R);\n                double getDeltaTime();\n\n\n            private:\n                std::unique_ptr&lt;ECS::SystemPluginManager&gt; _systemPluginManager;\n                std::vector&lt;std::shared_ptr&lt;ECS::ISystem&gt;&gt; _systems;\n                std::chrono::steady_clock::time_point _lastTime;\n                std::shared_ptr&lt;ECS::IWindow&gt; _winPtr;\n                double _dt = 0;\n\n        };\n    }\n\n#endif\n</code></pre>"},{"location":"coverage/ecs/src/Managers/Systems.hpp/","title":"Systems.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** RType\n** File description:\n** ECS Components\n*/\n\n#ifndef SYSTEMS_HPP_\n    #define SYSTEMS_HPP_\n\n    #include \"Systems/Acceleration.hpp\"\n    #include \"Systems/Animate.hpp\"\n    #include \"Systems/Collision.hpp\"\n    #include \"Systems/Draw.hpp\"\n    #include \"Systems/DrawText.hpp\"\n    #include \"Systems/Gravity.hpp\"\n    #include \"Systems/Movement.hpp\"\n    #include \"Systems/ParallaxSystem.hpp\"\n    #include \"Systems/Physics.hpp\"\n    #include \"Systems/ScriptOnCamera.hpp\"\n    #include \"Systems/ScriptOnClick.hpp\"\n    #include \"Systems/ScriptUpdate.hpp\"\n\n#endif\n</code></pre>"},{"location":"coverage/ecs/src/SFMLEncaps/","title":"SFMLEncaps","text":"Name Lines Covered Uncovered Coverage SFMLAudio.cpp 16 0 16 0.0% SFMLAudio.hpp 0 0 0 100.0% SFMLCamera.hpp 30 0 30 0.0% SFMLDrawable.cpp 29 0 29 0.0% SFMLDrawable.hpp 0 0 0 100.0% SFMLDrawableText.cpp 16 0 16 0.0% SFMLDrawableText.hpp 0 0 0 100.0% SFMLWindow.cpp 64 0 64 0.0% SFMLWindow.hpp 0 0 0 100.0% Summary 155 0 155 0.0%"},{"location":"coverage/ecs/src/SFMLEncaps/SFMLAudio.cpp/","title":"SFMLAudio.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** ErrorException\n*/\n\n#include \"SFMLAudio.hpp\"\n\nECS::SFMLAudio::SFMLAudio()\n    : _volume(100.0f), _loop(false), _spamable(false)\n{\n}\n\nECS::SFMLAudio::~SFMLAudio()\n{\n}\n\nbool ECS::SFMLAudio::loadFromFile(std::string filepath)\n{\n    if (!_buffer.loadFromFile(filepath)) {\n        return false;\n    }\n    this-&gt;_sound.setBuffer(_buffer);\n    this-&gt;_sound.setVolume(_volume);\n    this-&gt;_sound.setLoop(_loop);\n    return true;\n}\n\nvoid ECS::SFMLAudio::setVolume(const float &amp;volume)\n{\n    this-&gt;_volume = volume;\n    this-&gt;_sound.setVolume(volume);\n}\n\nconst float &amp;ECS::SFMLAudio::getVolume()\n{\n    return this-&gt;_volume;\n}\n\nvoid ECS::SFMLAudio::setLoop(bool loop)\n{\n    this-&gt;_loop = loop;\n    this-&gt;_sound.setLoop(_loop);\n}\n\nvoid ECS::SFMLAudio::setSpamable(bool spam)\n{\n    this-&gt;_spamable = spam;\n}\n\nvoid ECS::SFMLAudio::play()\n{\n    if (this-&gt;_spamable || this-&gt;_sound.getStatus() != sf::Sound::Playing) {\n        this-&gt;_sound.play();\n    }\n}\n\nvoid ECS::SFMLAudio::stop()\n{\n    this-&gt;_sound.stop();\n}\n</code></pre>"},{"location":"coverage/ecs/src/SFMLEncaps/SFMLAudio.hpp/","title":"SFMLAudio.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** ErrorException\n*/\n\n#ifndef ECS_SFML_AUDIO_HPP\n    #define ECS_SFML_AUDIO_HPP\n\n    #include \"Interfaces/IAudio.hpp\"\n    #include &lt;SFML/Audio.hpp&gt;\n\n    namespace ECS {\n\n        // SFMLAudio class that implements IAudio interface\n        class SFMLAudio : public ECS::IAudio {\n        public:\n            SFMLAudio();\n            ~SFMLAudio();\n\n            bool loadFromFile(std::string filepath) override;\n            void setVolume(const float &amp;volume) override;\n            const float &amp;getVolume() override;\n            void setLoop(bool loop) override;\n            void setSpamable(bool spam) override;\n            void play() override;\n            void stop() override;\n\n        private:\n            sf::SoundBuffer _buffer;\n            sf::Sound _sound;\n            float _volume;\n            bool _loop;\n            bool _spamable;\n        };\n\n    } // namespace ECS\n\n#endif // ECS_SFML_AUDIO_HPP\n</code></pre>"},{"location":"coverage/ecs/src/SFMLEncaps/SFMLCamera.hpp/","title":"SFMLCamera.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** ErrorException\n*/\n\n#ifndef ECS_SFML_CAMERA_H\n    #define ECS_SFML_CAMERA_H\n\n    #include \"Interfaces/ICamera.hpp\"\n    #include &lt;SFML/Graphics.hpp&gt;\n\n    namespace ECS {\n\n        class SFMLCamera : public ICamera {\n        public:\n            SFMLCamera() : _zoom(1.0f), _rotation(0.0f) {\n                _view.setCenter(0, 0);  // Default position at (0, 0)\n                _view.setSize(800, 600); // Default size\n            }\n\n            void setPosition(const ECS::Vector2Df &amp;pos) override {\n                this-&gt;_pos = pos;\n                _view.setCenter(pos.x, pos.y);\n                sf::FloatRect rect = _view.getViewport();\n\n                sf::Vector2f viewCenter = _view.getCenter();\n                sf::Vector2f viewSize = _view.getSize();\n\n                float left = viewCenter.x - viewSize.x / 2.0f;\n                float top = viewCenter.y - viewSize.y / 2.0f;\n                float right = left + viewSize.x;\n                float bottom = top + viewSize.y;\n\n                this-&gt;_bounds.x = left;\n                this-&gt;_bounds.y = top;\n                this-&gt;_bounds.w = right - left;\n                this-&gt;_bounds.h = bottom - top;\n            }\n\n            const ECS::Vector2Df &amp;getPosition() override {\n                return this-&gt;_pos;\n            }\n\n            const ECS::Rect2Df &amp;getBounds() override {\n                return this-&gt;_bounds;\n            }\n\n            void setSize(const ECS::Vector2Du &amp;size) override {\n                this-&gt;_size = size;\n                _view.setSize(size.x, size.y);\n            }\n\n            const ECS::Vector2Du &amp;getSize() override {\n                return this-&gt;_size;\n            }\n\n            void setZoom(float zoomLevel) override {\n                _zoom = zoomLevel;\n                _view.setSize(_view.getSize().x * _zoom, _view.getSize().y * _zoom);\n            }\n\n            float getZoom() const override {\n                return _zoom;\n            }\n\n            void setRotation(float angle) override {\n                _rotation = angle;\n                _view.setRotation(_rotation);\n            }\n\n            float getRotation() const override {\n                return _rotation;\n            }\n\n            void apply() const override {\n                // In SFML, the view needs to be applied to the window during drawing.\n            }\n\n            void move(const ECS::Vector2Df &amp;movement) {\n                this-&gt;_pos += movement;\n                this-&gt;setPosition(this-&gt;_pos);\n            }\n\n            const sf::View&amp; getView() const {\n                return _view;\n            }\n\n        private:\n            sf::View _view;\n            ECS::Vector2Df _pos;\n            ECS::Vector2Du _size;\n            ECS::Rect2Df _bounds;\n            float _zoom;\n            float _rotation;\n        };\n\n    } // namespace ECS\n\n#endif // ECS_SFML_CAMERA_H\n</code></pre>"},{"location":"coverage/ecs/src/SFMLEncaps/SFMLDrawable.cpp/","title":"SFMLDrawable.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** ErrorException\n*/\n\n#include \"SFMLDrawable.hpp\"\n\nECS::SFMLDrawable::SFMLDrawable()\n{\n\n}\n\nECS::SFMLDrawable::~SFMLDrawable()\n{\n\n}\n\nstd::shared_ptr&lt;ECS::IDrawable&gt; ECS::SFMLDrawable::clone() const\n{\n    auto clone = std::make_shared&lt;ECS::SFMLDrawable&gt;(*this);\n    return clone;\n}\n\nbool ECS::SFMLDrawable::loadFromFile(std::string filepath)\n{\n    if (!this-&gt;_texture.loadFromFile(filepath)) {\n        return false;\n    }\n    this-&gt;_texture.setRepeated(true);\n    this-&gt;_sprite.setTexture(this-&gt;_texture, true);\n    this-&gt;_textureSize.x = this-&gt;_texture.getSize().x;\n    this-&gt;_textureSize.y = this-&gt;_texture.getSize().y;\n    sf::IntRect rect = this-&gt;_sprite.getTextureRect();\n    this-&gt;_rect = ECS::Rect2Di{rect.left, rect.top, rect.width, rect.height};\n    return true;\n}\n\nvoid ECS::SFMLDrawable::setPosition(const ECS::Vector2Df &amp;pos)\n{\n    this-&gt;_sprite.setPosition(pos.x, pos.y);\n    this-&gt;_pos.x = pos.x;\n    this-&gt;_pos.y = pos.y;\n}\n\nconst ECS::Vector2Df &amp;ECS::SFMLDrawable::getPosition()\n{\n    return this-&gt;_pos;\n}\n\nvoid ECS::SFMLDrawable::setTextureRect(const ECS::Rect2Di &amp;rect)\n{\n    this-&gt;_rect = rect;\n    sf::IntRect intRect(rect.x, rect.y, rect.w, rect.h);\n    this-&gt;_sprite.setTextureRect(intRect);\n}\n\nconst ECS::Rect2Di &amp;ECS::SFMLDrawable::getTextureRect()\n{\n    return this-&gt;_rect;\n}\n\nvoid ECS::SFMLDrawable::setOrigin(const ECS::Vector2Df &amp;pos)\n{\n    this-&gt;_sprite.setOrigin(pos.x, pos.y);\n    this-&gt;_origin.x = pos.x;\n    this-&gt;_origin.y = pos.y;\n}\n\nconst ECS::Vector2Df &amp;ECS::SFMLDrawable::getOrigin()\n{\n    return this-&gt;_origin;\n}\n\nconst ECS::Vector2Du &amp;ECS::SFMLDrawable::getTextureSize()\n{\n    return this-&gt;_textureSize;\n}\n\nconst sf::Sprite &amp;ECS::SFMLDrawable::getSFMLSprite()\n{\n    return this-&gt;_sprite;\n}\n\nvoid ECS::SFMLDrawable::setScale(const ECS::Vector2Df &amp;scale)\n{\n    this-&gt;_sprite.setScale(scale.x, scale.y);\n    this-&gt;_scale.x = scale.x;\n    this-&gt;_scale.y = scale.y;\n}\n\nconst ECS::Vector2Df &amp;ECS::SFMLDrawable::getScale()\n{\n    return this-&gt;_scale;\n}\n</code></pre>"},{"location":"coverage/ecs/src/SFMLEncaps/SFMLDrawable.hpp/","title":"SFMLDrawable.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** ErrorException\n*/\n\n#ifndef ECS_SFML_DRAWABLE_HPP\n    #define ECS_SFML_DRAWABLE_HPP\n\n    #include \"Interfaces/IDrawable.hpp\"\n    #include \"GUI_SFML_Graphics.hpp\"\n\n    namespace ECS {\n\n        // Interface for Drawable objects (e.g., sprites, text)\n        class SFMLDrawable : public ECS::IDrawable {\n        public:\n            SFMLDrawable();\n            ~SFMLDrawable();\n            std::shared_ptr&lt;IDrawable&gt; clone() const override;\n\n            bool loadFromFile(std::string filepath) override;\n            void setPosition(const ECS::Vector2Df &amp;pos) override;\n            const ECS::Vector2Df &amp;getPosition() override;\n            void setTextureRect(const ECS::Rect2Di &amp;rect) override;\n            const ECS::Rect2Di &amp;getTextureRect() override;\n            void setOrigin(const ECS::Vector2Df &amp;pos) override;\n            const ECS::Vector2Df &amp;getOrigin() override;\n            const ECS::Vector2Du &amp;getTextureSize();\n            void setScale(const ECS::Vector2Df &amp;scale) override;\n            const ECS::Vector2Df &amp;getScale() override;\n\n            const sf::Sprite &amp;getSFMLSprite();\n\n        private:\n            sf::Sprite _sprite;\n            sf::Texture _texture;\n            ECS::Vector2Df _pos;\n            ECS::Vector2Du _textureSize;\n            ECS::Vector2Df _origin;\n            ECS::Vector2Df _scale;\n            ECS::Rect2Di _rect;\n\n        };\n\n    } // namespace ECS\n\n#endif // ECS_IDRAWABLE_H\n</code></pre>"},{"location":"coverage/ecs/src/SFMLEncaps/SFMLDrawableText.cpp/","title":"SFMLDrawableText.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2025\n** Rtype\n** File description:\n** SFMLDrawableText\n*/\n\n#include \"SFMLDrawableText.hpp\"\n\nECS::SFMLDrawableText::SFMLDrawableText() \n    : _pos{0, 0}, _origin{0, 0} // Initialize position and origin to zero\n{\n}\n\nECS::SFMLDrawableText::~SFMLDrawableText()\n{\n}\n\nvoid ECS::SFMLDrawableText::setText(const std::string &amp;text)\n{\n    this-&gt;_text.setString(text);\n}\n\nconst std::string &amp;ECS::SFMLDrawableText::getText() const\n{\n    return this-&gt;_text.getString();\n}\n\nvoid ECS::SFMLDrawableText::setPosition(const ECS::Vector2Df &amp;pos)\n{\n    this-&gt;_text.setPosition(pos.x, pos.y);\n    this-&gt;_pos = pos;\n}\n\nconst ECS::Vector2Df &amp;ECS::SFMLDrawableText::getPosition()\n{\n    return this-&gt;_pos;\n}\n\nbool ECS::SFMLDrawableText::setFont(const std::string &amp;fontFilepath)\n{\n    if (!this-&gt;_font.loadFromFile(fontFilepath)) {\n        return false;\n    }\n    this-&gt;_text.setFont(this-&gt;_font);\n    return true;\n}\n\nvoid ECS::SFMLDrawableText::setCharacterSize(unsigned int size)\n{\n    this-&gt;_text.setCharacterSize(size);\n}\n\nconst unsigned int ECS::SFMLDrawableText::getCharacterSize() const\n{\n    return this-&gt;_text.getCharacterSize();\n}\n\nvoid ECS::SFMLDrawableText::setOrigin(const ECS::Vector2Df &amp;origin)\n{\n    this-&gt;_text.setOrigin(origin.x, origin.y);\n    this-&gt;_origin = origin;\n}\n\nconst ECS::Vector2Df &amp;ECS::SFMLDrawableText::getOrigin()\n{\n    return this-&gt;_origin;\n}\n\nconst sf::Text &amp;ECS::SFMLDrawableText::getSFMLText()\n{\n    return this-&gt;_text;\n}\n</code></pre>"},{"location":"coverage/ecs/src/SFMLEncaps/SFMLDrawableText.hpp/","title":"SFMLDrawableText.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** ErrorException\n*/\n\n#ifndef ECS_SFML_DRAWABLE_TEXT_HPP\n    #define ECS_SFML_DRAWABLE_TEXT_HPP\n\n    #include \"Interfaces/IDrawableText.hpp\"\n    #include \"GUI_SFML_Graphics.hpp\"\n\n    namespace ECS {\n\n        // Interface for Drawable objects (e.g., sprites, text)\n        class SFMLDrawableText : public ECS::IDrawableText {\n        public:\n            SFMLDrawableText();\n            ~SFMLDrawableText();\n\n            void setText(const std::string &amp;text);\n            const std::string &amp;getText() const;\n            void setPosition(const ECS::Vector2Df &amp;pos);\n            const ECS::Vector2Df &amp;getPosition();\n            bool setFont(const std::string &amp;fontFilapath);\n            void setCharacterSize(unsigned int size);\n            const unsigned int getCharacterSize() const;\n            void setOrigin(const ECS::Vector2Df &amp;origin);\n            const ECS::Vector2Df &amp;getOrigin();\n\n            const sf::Text &amp;getSFMLText();\n\n        private:\n            sf::Font _font;\n            sf::Text _text;\n            ECS::Vector2Df _pos;\n            ECS::Vector2Df _origin;\n\n        };\n\n    } // namespace ECS\n\n#endif // ECS_IDRAWABLE_H\n</code></pre>"},{"location":"coverage/ecs/src/SFMLEncaps/SFMLWindow.cpp/","title":"SFMLWindow.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** ErrorException\n*/\n\n#include \"SFMLWindow.hpp\"\n\nECS::SFMLWindow::SFMLWindow(const std::string&amp; title, ECS::Vector2Du size)\n{\n    this-&gt;_camera = std::make_shared&lt;ECS::SFMLCamera&gt;();\n    this-&gt;_text = std::make_shared&lt;ECS::SFMLDrawableText&gt;();\n    std::filesystem::path base_path = std::filesystem::current_path();\n    std::filesystem::path font_path = base_path / \"../\" / \"../\" / \"../\" / \"ecs\" / \"assets\" / \"Monocraft.ttf\";\n    if (!this-&gt;_text-&gt;setFont(font_path.string())) {\n        this-&gt;_text-&gt;setFont(\"./assets/Monocraft.ttf\");\n    }\n\n    this-&gt;open(title, size);\n}\n\nECS::SFMLWindow::~SFMLWindow()\n{\n    this-&gt;_window.close();\n}\n\nbool ECS::SFMLWindow::open(const std::string&amp; title, ECS::Vector2Du size)\n{\n    _window.create(sf::VideoMode(size.x, size.y), title);\n    this-&gt;_window.setFramerateLimit(60);\n    ECS::Vector2Df cameraPos(size.x / 2, size.y / 2);\n\n    this-&gt;_camera-&gt;setPosition(cameraPos);\n    this-&gt;_camera-&gt;setSize(size);\n    this-&gt;setSize(size);\n    return _window.isOpen();\n}\n\nvoid ECS::SFMLWindow::close()\n{\n    _window.close();\n}\n\nvoid ECS::SFMLWindow::clear()\n{\n    _window.clear();\n    this-&gt;_lastKeyPressed = this-&gt;_keyPressed;\n    this-&gt;_leftMouse = MouseButton();\n    this-&gt;_rightMouse = MouseButton();\n    this-&gt;_leftMouse.hold = sf::Mouse::isButtonPressed(sf::Mouse::Button::Left);\n    this-&gt;_rightMouse.hold = sf::Mouse::isButtonPressed(sf::Mouse::Button::Right);\n    while (this-&gt;_window.pollEvent(this-&gt;_event)) {\n        switch (this-&gt;_event.type) {\n            case sf::Event::Closed: this-&gt;close(); break;\n            case sf::Event::KeyPressed:\n                this-&gt;_keyPressed[this-&gt;_event.key.code] = true;\n                break;\n            case sf::Event::KeyReleased:\n                this-&gt;_keyPressed[this-&gt;_event.key.code] = false;\n                break;\n            case sf::Event::MouseButtonReleased:\n                this-&gt;_leftMouse.released = (this-&gt;_event.mouseButton.button == sf::Mouse::Left);\n                this-&gt;_rightMouse.released = (this-&gt;_event.mouseButton.button == sf::Mouse::Right);\n                break;\n            case sf::Event::MouseButtonPressed:\n                this-&gt;_leftMouse.pressed = (this-&gt;_event.mouseButton.button == sf::Mouse::Left);\n                this-&gt;_rightMouse.pressed = (this-&gt;_event.mouseButton.button == sf::Mouse::Right);\n                break;\n        }\n    }\n}\n\nvoid ECS::SFMLWindow::draw(ECS::IDrawable &amp;drawable)\n{\n    ECS::SFMLDrawable &amp;sfmlDrawable = static_cast&lt;ECS::SFMLDrawable&amp;&gt;(drawable);\n    this-&gt;_window.draw(sfmlDrawable.getSFMLSprite());\n}\n\nvoid ECS::SFMLWindow::drawText(std::string text, unsigned int size, ECS::Vector2Df pos)\n{\n    this-&gt;_text-&gt;setCharacterSize(size);\n    this-&gt;_text-&gt;setText(text);\n    this-&gt;_text-&gt;setPosition(pos);\n    ECS::SFMLDrawableText &amp;sfmlDrawable = static_cast&lt;ECS::SFMLDrawableText&amp;&gt;(*this-&gt;_text);\n    this-&gt;_window.draw(sfmlDrawable.getSFMLText());\n}\n\nvoid ECS::SFMLWindow::display()\n{\n    this-&gt;_window.setView(std::static_pointer_cast&lt;SFMLCamera&gt;(this-&gt;_camera)-&gt;getView());\n    _window.display();\n}\n\nbool ECS::SFMLWindow::isOpen()\n{\n    return _window.isOpen();\n}\n\nconst ECS::Vector2Du&amp; ECS::SFMLWindow::getSize()\n{\n    return this-&gt;_size;\n}\n\nvoid ECS::SFMLWindow::setSize(const ECS::Vector2Du&amp; size)\n{\n    this-&gt;_size = size;\n    sf::Vector2u newSize(size.x, size.y);\n    this-&gt;_window.setSize(newSize);\n}\n\nvoid ECS::SFMLWindow::setFramerate(unsigned int fps)\n{\n    this-&gt;_window.setFramerateLimit(fps);\n}\n\nvoid ECS::SFMLWindow::setCamera(std::shared_ptr&lt;ICamera&gt; camera)\n{\n    this-&gt;_camera = camera;\n    // _window.setView(static_cast&lt;SFMLCamera*&gt;(_camera)-&gt;getView());\n}\n\nstd::shared_ptr&lt;ECS::ICamera&gt; ECS::SFMLWindow::getCamera()\n{\n    return _camera;\n}\n\nbool ECS::SFMLWindow::isKeyPressed(ECS::Key key)\n{\n    auto it = this-&gt;_keyPressed.find(static_cast&lt;sf::Keyboard::Key&gt;(key));\n    if (it != this-&gt;_keyPressed.end()) {\n        return it-&gt;second; // the value associated with the key\n    } else {\n        // Handle the case where the key is not found\n        return false; // or some other default value/error handling\n    }\n}\n\nbool ECS::SFMLWindow::isKeyJustPressed(ECS::Key key)\n{\n    sf::Keyboard::Key actualKey = static_cast&lt;sf::Keyboard::Key&gt;(key);\n    return this-&gt;_keyPressed[actualKey] == true &amp;&amp; this-&gt;_lastKeyPressed[actualKey] == false;\n}\n\nbool ECS::SFMLWindow::isLeftMousePressed()\n{\n    return this-&gt;_leftMouse.hold;\n}\n\nbool ECS::SFMLWindow::isLeftMouseJustReleased()\n{\n    return this-&gt;_leftMouse.released;\n}\n\nbool ECS::SFMLWindow::isLeftMouseJustPressed()\n{\n    return this-&gt;_leftMouse.pressed;\n}\n\nbool ECS::SFMLWindow::isRightMousePressed()\n{\n    return this-&gt;_rightMouse.hold;\n}\n\nbool ECS::SFMLWindow::isRightMouseJustReleased()\n{\n    return this-&gt;_rightMouse.released;\n}\n\nbool ECS::SFMLWindow::isRightMouseJustPressed()\n{\n    return this-&gt;_rightMouse.pressed;\n}\n\nconst ECS::Vector2Di&amp; ECS::SFMLWindow::getMousePosition()\n{\n    this-&gt;_mousePosition.x = this-&gt;_window.mapPixelToCoords(sf::Mouse::getPosition(this-&gt;_window)).x;\n    this-&gt;_mousePosition.y = this-&gt;_window.mapPixelToCoords(sf::Mouse::getPosition(this-&gt;_window)).y;\n    return this-&gt;_mousePosition;\n}\n\nconst ECS::Vector2Di&amp; ECS::SFMLWindow::getMouseTranslation()\n{\n    return this-&gt;_mouseTranslation;\n}\n</code></pre>"},{"location":"coverage/ecs/src/SFMLEncaps/SFMLWindow.hpp/","title":"SFMLWindow.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** ErrorException\n*/\n\n#ifndef ECS_SFML_WINDOW_H\n    #define ECS_SFML_WINDOW_H\n\n    #include \"Interfaces/IWindow.hpp\"\n    #include \"SFMLCamera.hpp\"\n    #include \"SFMLDrawable.hpp\"\n    #include \"SFMLDrawableText.hpp\"\n    #include &lt;filesystem&gt;\n    #include &lt;memory&gt;\n\n    namespace ECS {\n\n        class SFMLWindow : public IWindow {\n            public:\n                SFMLWindow(const std::string&amp; title, ECS::Vector2Du size);\n                ~SFMLWindow();\n                bool open(const std::string&amp; title, ECS::Vector2Du size) override;\n                void close() override;\n                void clear() override;\n                void draw(ECS::IDrawable &amp;drawable) override;\n                void drawText(std::string text, unsigned int size, ECS::Vector2Df pos) override;\n                void display() override;\n                bool isOpen() override;\n                const ECS::Vector2Du &amp;getSize() override;\n                void setSize(const ECS::Vector2Du &amp;size) override;\n                void setFramerate(unsigned int fps);\n\n                void setCamera(std::shared_ptr&lt;ICamera&gt; camera) override;\n                std::shared_ptr&lt;ECS::ICamera&gt; getCamera() override;\n\n                bool isKeyPressed(ECS::Key key) override;\n                bool isKeyJustPressed(ECS::Key key) override;\n                bool isLeftMousePressed() override;\n                bool isLeftMouseJustReleased() override;\n                bool isLeftMouseJustPressed() override;\n                bool isRightMousePressed() override;\n                bool isRightMouseJustReleased() override;\n                bool isRightMouseJustPressed() override;\n                const ECS::Vector2Di &amp;getMousePosition() override;\n                const ECS::Vector2Di &amp;getMouseTranslation() override;\n\n            private:\n                struct MouseButton {\n                    bool pressed, hold, released = false;\n                };\n\n                sf::Event _event;\n                sf::RenderWindow _window;\n                std::shared_ptr&lt;ICamera&gt; _camera = nullptr;\n                std::shared_ptr&lt;IDrawableText&gt; _text = nullptr;\n                ECS::Vector2Du _size;\n\n                ECS::Vector2Di _mousePosition;\n                ECS::Vector2Di _mouseTranslation;\n\n                MouseButton _leftMouse;\n                MouseButton _rightMouse;\n\n                std::map&lt;sf::Keyboard::Key, bool&gt; _keyPressed;\n                std::map&lt;sf::Keyboard::Key, bool&gt; _lastKeyPressed;\n        };\n\n    } // namespace ECS\n\n#endif // ECS_SFML_WINDOW_H\n</code></pre>"},{"location":"coverage/ecs/src/Script/","title":"Script","text":"Name Lines Covered Uncovered Coverage AScript.hpp 11 0 11 0.0% IScript.hpp 0 0 0 100.0% Summary 11 0 11 0.0%"},{"location":"coverage/ecs/src/Script/AScript.hpp/","title":"AScript.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** ErrorException\n*/\n\n#ifndef A_SCRIPT_H_\n    #define A_SCRIPT_H_\n\n    #include \"IScript.hpp\"\n    #include \"../ECSManager.hpp\"\n\n    namespace ECS\n    {\n        /**\n        * Default abstract of IScript, only global functions are defined.\n        *\n        * This script's methods will be called by the engine in specific moments, they cannot be called\n        * elsewhere\n        *\n        * Classes that inherit from this (the scripts you will create) can have their own private variables\n        * or component pointers (see example scripts in the ScriptSource folder for example)\n        *\n        * @param Game Pointer to access the engine class's content\n        * @param _selfID ID of the script's entity\n        *\n        */\n        class AScript : public ECS::IScript\n        {\n            public:\n                ~AScript() = default;\n\n                /**\n                * Called on Entity's first frame of existence, usefull for getting all components once\n                *\n                */\n                void onStart() {}\n\n                /**\n                * Called every frame\n                *\n                */\n                void onUpdate() {}\n\n                /**\n                * Called when an entity collides with another, they need a hitbox component to be activatable\n                * \n                * @param id ID of the entity who collided the script's owner\n                *\n                */\n                void onCollision(ECS::entity_id id) {}\n\n                /**\n                * Called when mouse clicks on the entity, they need to have an hitbox\n                *\n                */\n                void onClick() {}\n\n                /**\n                * Can be called by other scripts to do an action based on name of the event\n                *\n                */\n                void onEvent(std::string event) {};\n\n                /**\n                * Called when an entity enters the camera\n                *\n                */\n                void onEnterCamera() {}\n\n                /**\n                * Called when an entity exits the camera\n                *\n                */\n                void onExitCamera() {}\n\n                /**\n                * Called when Script is assigned to an entity so that they can manipulate the engine\n                *\n                * @param ecsManager Pointer to ECSManager Class (the engine).\n                */\n                bool setEcsManager(ECS::ECSManager* ecsManager) {\n                    if (ecsManager == nullptr) {\n                        return false;\n                    }\n                    Game = ecsManager;\n                    return true;\n                }\n\n                /**\n                * Defines the script's user ID\n                *\n                * @param id Entity ID.\n                */\n                void setEntityID(ECS::entity_id id) {\n                    _selfID = id;\n                }\n\n                /**\n                * Automatically spawn a prefab at (x, y), useful for spawning decor or temporary animation elements\n                *\n                * @warning NOT RECOMMENDED, MODIFYING ENTITIES CREATED BY THIS METHOD MAY CAUSE CRASH\n                * @param prefabName Prefab name.\n                * @param x X position\n                * @param y Y position\n                */\n                ECS::entity_id spawnPrefabAt(std::string prefabName, int x, int y) {\n                    ECS::entity_id id = Game-&gt;createEntityFromPrefab(prefabName);\n                    auto e = Game-&gt;getComponent&lt;ECS::Component::Position&gt;(id);\n                    if (e != nullptr) {\n                        e-&gt;vect.x = x;\n                        e-&gt;vect.y = y;\n                    }\n                    return id;\n                }\n\n            protected:\n                ECS::ECSManager *Game;\n                ECS::entity_id _selfID;\n\n        };\n    }\n\n#endif\n</code></pre>"},{"location":"coverage/ecs/src/Script/IScript.hpp/","title":"IScript.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Rtype\n** File description:\n** ErrorException\n*/\n\n#ifndef I_SCRIPT_H_\n    #define I_SCRIPT_H_\n\n    #include \"../Entity.hpp\"\n\n    namespace ECS\n    {\n        class ECSManager;\n\n        /**\n        * Interface for script classes\n        *\n        */\n        class IScript\n        {\n            public:\n                virtual ~IScript() = default;\n                virtual void onStart() = 0;\n                virtual void onUpdate() = 0;\n                virtual void onCollision(ECS::entity_id id) = 0;\n                virtual void onClick() = 0;\n                virtual void onEvent(std::string event) = 0;\n                virtual void onEnterCamera() = 0;\n                virtual void onExitCamera() = 0;\n                virtual bool setEcsManager(ECS::ECSManager* ecsManager) = 0;\n                virtual void setEntityID(ECS::entity_id id) = 0;\n        };\n    }\n\n#endif\n</code></pre>"},{"location":"coverage/ecs/src/Types/","title":"Types","text":"Name Lines Covered Uncovered Coverage Inputs.hpp 0 0 0 100.0% Rect2D.hpp 42 0 42 0.0% Vector2D.hpp 36 0 36 0.0% Summary 78 0 78 0.0%"},{"location":"coverage/ecs/src/Types/Inputs.hpp/","title":"Inputs.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** RType\n** File description:\n** Inputs enum\n*/\n\n#ifndef INPUTS_HPP_\n    #define INPUTS_HPP_\n\n    #include &lt;memory&gt;\n    #include &lt;queue&gt;\n    #include &lt;map&gt;\n    #include &lt;unordered_map&gt;\n\n    namespace ECS\n    {\n        /**\n        * This is the enumeration of all the key inputs scancodes used by the engine\n        * The input check is handled my the window abstraction\n        *\n        */\n        enum Key\n        {\n            Unknown = -1, //!&lt; Unhandled key\n            A = 0,        //!&lt; The A key\n            B,            //!&lt; The B key\n            C,            //!&lt; The C key\n            D,            //!&lt; The D key\n            E,            //!&lt; The E key\n            F,            //!&lt; The F key\n            G,            //!&lt; The G key\n            H,            //!&lt; The H key\n            I,            //!&lt; The I key\n            J,            //!&lt; The J key\n            K,            //!&lt; The K key\n            L,            //!&lt; The L key\n            M,            //!&lt; The M key\n            N,            //!&lt; The N key\n            O,            //!&lt; The O key\n            P,            //!&lt; The P key\n            Q,            //!&lt; The Q key\n            R,            //!&lt; The R key\n            S,            //!&lt; The S key\n            T,            //!&lt; The T key\n            U,            //!&lt; The U key\n            V,            //!&lt; The V key\n            W,            //!&lt; The W key\n            X,            //!&lt; The X key\n            Y,            //!&lt; The Y key\n            Z,            //!&lt; The Z key\n            Num0,         //!&lt; The 0 key\n            Num1,         //!&lt; The 1 key\n            Num2,         //!&lt; The 2 key\n            Num3,         //!&lt; The 3 key\n            Num4,         //!&lt; The 4 key\n            Num5,         //!&lt; The 5 key\n            Num6,         //!&lt; The 6 key\n            Num7,         //!&lt; The 7 key\n            Num8,         //!&lt; The 8 key\n            Num9,         //!&lt; The 9 key\n            Escape,       //!&lt; The Escape key\n            LControl,     //!&lt; The left Control key\n            LShift,       //!&lt; The left Shift key\n            LAlt,         //!&lt; The left Alt key\n            LSystem,      //!&lt; The left OS specific key: window (Windows and Linux), apple (macOS), ...\n            RControl,     //!&lt; The right Control key\n            RShift,       //!&lt; The right Shift key\n            RAlt,         //!&lt; The right Alt key\n            RSystem,      //!&lt; The right OS specific key: window (Windows and Linux), apple (macOS), ...\n            Menu,         //!&lt; The Menu key\n            LBracket,     //!&lt; The [ key\n            RBracket,     //!&lt; The ] key\n            Semicolon,    //!&lt; The ; key\n            Comma,        //!&lt; The , key\n            Period,       //!&lt; The . key\n            Apostrophe,   //!&lt; The ' key\n            Slash,        //!&lt; The / key\n            Backslash,    //!&lt; The \\ key\n            Grave,        //!&lt; The ` key\n            Equal,        //!&lt; The = key\n            Hyphen,       //!&lt; The - key (hyphen)\n            Space,        //!&lt; The Space key\n            Enter,        //!&lt; The Enter/Return keys\n            Backspace,    //!&lt; The Backspace key\n            Tab,          //!&lt; The Tabulation key\n            PageUp,       //!&lt; The Page up key\n            PageDown,     //!&lt; The Page down key\n            End,          //!&lt; The End key\n            Home,         //!&lt; The Home key\n            Insert,       //!&lt; The Insert key\n            Delete,       //!&lt; The Delete key\n            Add,          //!&lt; The + key\n            Subtract,     //!&lt; The - key (minus, usually from numpad)\n            Multiply,     //!&lt; The * key\n            Divide,       //!&lt; The / key\n            Left,         //!&lt; Left arrow\n            Right,        //!&lt; Right arrow\n            Up,           //!&lt; Up arrow\n            Down,         //!&lt; Down arrow\n            Numpad0,      //!&lt; The numpad 0 key\n            Numpad1,      //!&lt; The numpad 1 key\n            Numpad2,      //!&lt; The numpad 2 key\n            Numpad3,      //!&lt; The numpad 3 key\n            Numpad4,      //!&lt; The numpad 4 key\n            Numpad5,      //!&lt; The numpad 5 key\n            Numpad6,      //!&lt; The numpad 6 key\n            Numpad7,      //!&lt; The numpad 7 key\n            Numpad8,      //!&lt; The numpad 8 key\n            Numpad9,      //!&lt; The numpad 9 key\n            F1,           //!&lt; The F1 key\n            F2,           //!&lt; The F2 key\n            F3,           //!&lt; The F3 key\n            F4,           //!&lt; The F4 key\n            F5,           //!&lt; The F5 key\n            F6,           //!&lt; The F6 key\n            F7,           //!&lt; The F7 key\n            F8,           //!&lt; The F8 key\n            F9,           //!&lt; The F9 key\n            F10,          //!&lt; The F10 key\n            F11,          //!&lt; The F11 key\n            F12,          //!&lt; The F12 key\n            F13,          //!&lt; The F13 key\n            F14,          //!&lt; The F14 key\n            F15,          //!&lt; The F15 key\n            Pause,        //!&lt; The Pause key\n\n            KeyCount,     //!&lt; Keep last -- the total number of keyboard keys\n\n            // Deprecated values:\n\n            Tilde     = Grave,     //!&lt; \\deprecated Use Grave instead\n            Dash      = Hyphen,    //!&lt; \\deprecated Use Hyphen instead\n            BackSpace = Backspace, //!&lt; \\deprecated Use Backspace instead\n            BackSlash = Backslash, //!&lt; \\deprecated Use Backslash instead\n            SemiColon = Semicolon, //!&lt; \\deprecated Use Semicolon instead\n            Return    = Enter,     //!&lt; \\deprecated Use Enter instead\n            Quote     = Apostrophe //!&lt; \\deprecated Use Apostrophe instead\n        };\n\n    }\n\n#endif\n</code></pre>"},{"location":"coverage/ecs/src/Types/Rect2D.hpp/","title":"Rect2D.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** RType\n** File description:\n** EntityManager Class\n*/\n\n#ifndef RECT2D_HPP_\n    #define RECT2D_HPP_\n\n    #include &lt;iostream&gt;\n\n    namespace ECS {\n\n        /**\n        * This class defines a standardisation for rect in the game engine.\n        * The abstractions of the interfaces have to adapt their values to it\n        * \n        * @tparam type of the stored values\n        *\n        */\n        template &lt;typename T&gt;\n        class Rect2D {\n            public:\n                T x, y, w, h;\n\n                Rect2D() : x(0), y(0), w(0), h(0) {}\n\n                Rect2D(T x, T y, T w, T h) : x(x), y(y), w(w), h(h) {}\n\n                Rect2D(const Rect2D&amp; other) : x(other.x), y(other.y), w(other.w), h(other.h) {}\n\n                Rect2D&amp; operator=(const Rect2D&amp; other) {\n                    x = other.x;\n                    y = other.y;\n                    w = other.w;\n                    h = other.h;\n                    return *this;\n                }\n\n                Rect2D operator+(const Rect2D&amp; other) const {\n                    return Rect2D(x + other.x, y + other.y, w + other.w, h + other.h);\n                }\n\n                Rect2D operator-(const Rect2D&amp; other) const {\n                    return Rect2D(x - other.x, y - other.y, w - other.w, h - other.h);\n                }\n\n                Rect2D operator*(T scalar) const {\n                    return Rect2D(x * scalar, y * scalar, w * scalar, h * scalar);\n                }\n\n                Rect2D operator/(T scalar) const {\n                    if (scalar == 0) {\n                        throw std::invalid_argument(\"Division by zero!\");\n                    }\n                    return Rect2D(x / scalar, y / scalar, w / scalar, h / scalar);\n                }\n\n                Rect2D&amp; operator+=(const Rect2D&amp; other) {\n                    x += other.x;\n                    y += other.y;\n                    w += other.w;\n                    h += other.h;\n                    return *this;\n                }\n\n                Rect2D&amp; operator-=(const Rect2D&amp; other) {\n                    x -= other.x;\n                    y -= other.y;\n                    w -= other.w;\n                    h -= other.h;\n                    return *this;\n                }\n\n                Rect2D&amp; operator*=(T scalar) {\n                    x *= scalar;\n                    y *= scalar;\n                    w *= scalar;\n                    h *= scalar;\n                    return *this;\n                }\n\n                Rect2D&amp; operator/=(T scalar) {\n                    if (scalar == 0) {\n                        throw std::invalid_argument(\"Division by zero!\");\n                    }\n                    x /= scalar;\n                    y /= scalar;\n                    w /= scalar;\n                    h /= scalar;\n                    return *this;\n                }\n\n                bool operator==(const Rect2D&amp; other) const {\n                    return x == other.x &amp;&amp; y == other.y &amp;&amp; w == other.w &amp;&amp; h == other.h;\n                }\n\n                bool operator!=(const Rect2D&amp; other) const {\n                    return !(*this == other);\n                }\n\n                /**\n                * Checks if a point is inside the rect\n                * @param px X position\n                * @param py Y position\n                *\n                * @return True if there is a collision\n                *\n                */\n                bool contains(T px, T py) const {\n                    return px &gt;= x &amp;&amp; px &lt;= x + w &amp;&amp; py &gt;= y &amp;&amp; py &lt;= y + h;\n                }\n\n                /**\n                * Checks if a rect intersects with another rect\n                * @param other rect to check the intersection\n                *\n                * @return True if there is an intersection\n                *\n                */\n                bool intersects(const Rect2D&amp; other) const {\n                    return !(x + w &lt;= other.x || x &gt;= other.x + other.w || y + h &lt;= other.y || y &gt;= other.y + other.h);\n                }\n\n                friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Rect2D&amp; rect) {\n                    os &lt;&lt; \"(\" &lt;&lt; rect.x &lt;&lt; \", \" &lt;&lt; rect.y &lt;&lt; \", \" &lt;&lt; rect.w &lt;&lt; \", \" &lt;&lt; rect.h &lt;&lt; \")\";\n                    return os;\n                }\n        };\n\n        typedef Rect2D&lt;int&gt;          Rect2Di;\n        typedef Rect2D&lt;float&gt;          Rect2Df;\n\n    }\n\n#endif\n</code></pre>"},{"location":"coverage/ecs/src/Types/Vector2D.hpp/","title":"Vector2D.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** RType\n** File description:\n** EntityManager Class\n*/\n\n#ifndef VECTOR2D_HPP_\n    #define VECTOR2D_HPP_\n\n    #include &lt;iostream&gt;\n    #include &lt;cmath&gt;\n\n    namespace ECS {\n\n        /**\n        * This class defines a standardisation for vectors in the game engine.\n        * The abstractions of the interfaces have to adapt their values to it\n        *\n        */\n        template &lt;typename T&gt;\n        class Vector2D {\n            public:\n                T x, y;\n\n                Vector2D() : x(0), y(0) {}\n                Vector2D(T x, T y) : x(x), y(y) {}\n                Vector2D(const Vector2D&amp; other) : x(other.x), y(other.y) {}\n\n                // Assignment operator\n                Vector2D&amp; operator=(const Vector2D&amp; other) {\n                    x = other.x;\n                    y = other.y;\n                    return *this; // Return the current object for chained assignment\n                }\n\n                Vector2D operator+(const Vector2D&amp; other) const {\n                    return Vector2D(x + other.x, y + other.y);\n                }\n\n                Vector2D operator-(const Vector2D&amp; other) const {\n                    return Vector2D(x - other.x, y - other.y);\n                }\n\n                Vector2D operator*(T scalar) const {\n                    return Vector2D(x * scalar, y * scalar);\n                }\n\n                Vector2D operator/(T scalar) const {\n                    if (scalar == 0) {\n                        throw std::invalid_argument(\"Division by zero!\");\n                    }\n                    return Vector2D(x / scalar, y / scalar);\n                }\n\n                bool operator==(const Vector2D&amp; other) const {\n                    return x == other.x &amp;&amp; y == other.y;\n                }\n\n                bool operator!=(const Vector2D&amp; other) const {\n                    return !(*this == other);\n                }\n\n                Vector2D&amp; operator+=(const Vector2D&amp; other) {\n                    x += other.x;\n                    y += other.y;\n                    return *this;\n                }\n\n                Vector2D&amp; operator-=(const Vector2D&amp; other) {\n                    x -= other.x;\n                    y -= other.y;\n                    return *this;\n                }\n\n                Vector2D&amp; operator*=(T scalar) {\n                    x *= scalar;\n                    y *= scalar;\n                    return *this;\n                }\n\n                Vector2D&amp; operator/=(T scalar) {\n                    if (scalar == 0) {\n                        throw std::invalid_argument(\"Division by zero!\");\n                    }\n                    x /= scalar;\n                    y /= scalar;\n                    return *this;\n                }\n\n                /**\n                * Computes the dot of two vectors\n                * @param other vector to compute with\n                *\n                * @return The computed vector\n                *\n                */\n                T dot(const Vector2D&amp; other) const {\n                    return x * other.x + y * other.y;\n                }\n\n                /**\n                * Computes the magnitude of two vectors\n                * @param other vector to compute with\n                *\n                * @return The computed vector\n                *\n                */\n                T magnitude() const {\n                    return std::sqrt(x * x + y * y);\n                }\n\n                /**\n                * Returns the normalised vector\n                *\n                * @return The normalised vector\n                *\n                */\n                Vector2D normalize() const {\n                    T mag = magnitude();\n                    if (mag == 0) {\n                        throw std::invalid_argument(\"Cannot normalize a zero vector!\");\n                    }\n                    return *this / mag;\n                }\n\n                friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Vector2D&amp; vec) {\n                    os &lt;&lt; \"(\" &lt;&lt; vec.x &lt;&lt; \", \" &lt;&lt; vec.y &lt;&lt; \")\";\n                    return os;\n                }\n        };\n\n        typedef Vector2D&lt;int&gt;          Vector2Di;\n        typedef Vector2D&lt;float&gt;          Vector2Df;\n        typedef Vector2D&lt;unsigned int&gt;          Vector2Du;\n\n    }\n\n#endif\n</code></pre>"},{"location":"coverage/flint/","title":"flint","text":"Name Lines Covered Uncovered Coverage src 101 0 101 0.0% Colors 0 0 0 100.0% Colors.cpp 0 0 0 100.0% Colors.hpp 0 0 0 100.0% CxxABI 34 0 34 0.0% CxxABI.cpp 34 0 34 0.0% CxxABI.hpp 0 0 0 100.0% Exceptions 44 0 44 0.0% Exceptions.cpp 43 0 43 0.0% Exceptions.hpp 1 0 1 0.0% Init 6 0 6 0.0% Init.cpp 6 0 6 0.0% Init.hpp 0 0 0 100.0% Logging 9 0 9 0.0% Logging.cpp 8 0 8 0.0% Logging.hpp 1 0 1 0.0% hpp 8 0 8 0.0% Inspection.hpp 8 0 8 0.0% Preprocessor.hpp 0 0 0 100.0% Summary 0 0 0 100.0% Summary 34 0 34 0.0% Summary 44 0 44 0.0% Summary 6 0 6 0.0% Summary 9 0 9 0.0% Summary 8 0 8 0.0% Summary 101 0 101 0.0% Summary 101 0 101 0.0%"},{"location":"coverage/flint/src/","title":"src","text":"Name Lines Covered Uncovered Coverage Colors 0 0 0 100.0% Colors.cpp 0 0 0 100.0% Colors.hpp 0 0 0 100.0% CxxABI 34 0 34 0.0% CxxABI.cpp 34 0 34 0.0% CxxABI.hpp 0 0 0 100.0% Exceptions 44 0 44 0.0% Exceptions.cpp 43 0 43 0.0% Exceptions.hpp 1 0 1 0.0% Init 6 0 6 0.0% Init.cpp 6 0 6 0.0% Init.hpp 0 0 0 100.0% Logging 9 0 9 0.0% Logging.cpp 8 0 8 0.0% Logging.hpp 1 0 1 0.0% hpp 8 0 8 0.0% Inspection.hpp 8 0 8 0.0% Preprocessor.hpp 0 0 0 100.0% Summary 0 0 0 100.0% Summary 34 0 34 0.0% Summary 44 0 44 0.0% Summary 6 0 6 0.0% Summary 9 0 9 0.0% Summary 8 0 8 0.0% Summary 101 0 101 0.0%"},{"location":"coverage/flint/src/Colors/","title":"Colors","text":"Name Lines Covered Uncovered Coverage Colors.cpp 0 0 0 100.0% Colors.hpp 0 0 0 100.0% Summary 0 0 0 100.0%"},{"location":"coverage/flint/src/Colors/Colors.cpp/","title":"Colors.cpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Thu, May, 2024                                                     *\n * Title           - CppLib                                                             *\n * Description     -                                                                    *\n *     Colors                                                                           *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *         \u2591        \u2591       \u2591\u2591        \u2591        \u2591        \u2591\u2591      \u2591\u2591  \u2591\u2591\u2591\u2591  \u2591             *\n *         \u2592  \u2592\u2592\u2592\u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592  \u2592  \u2592\u2592\u2592\u2592  \u2592             *\n *         \u2593      \u2593\u2593\u2593       \u2593\u2593\u2593\u2593\u2593  \u2593\u2593\u2593\u2593\u2593\u2593\u2593  \u2593\u2593\u2593\u2593      \u2593\u2593\u2593  \u2593\u2593\u2593\u2593\u2593\u2593\u2593        \u2593             *\n *         \u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588  \u2588  \u2588\u2588\u2588\u2588  \u2588             *\n *         \u2588        \u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588        \u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588        \u2588\u2588      \u2588\u2588  \u2588\u2588\u2588\u2588  \u2588             *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#include \"Colors.hpp\"\n\nnamespace Flint\n{\n    const std::string Colors::RESET          = \"\\033[0m\";\n    const std::string Colors::BOLD           = \"\\033[1m\";\n    const std::string Colors::DISABLED       = \"\\033[2m\";\n    const std::string Colors::ITALIC         = \"\\033[3m\";\n    const std::string Colors::UNDERLINE      = \"\\033[4m\";\n    const std::string Colors::BLINK          = \"\\033[5m\";\n    const std::string Colors::HIGHLIGHTED    = \"\\033[7m\";\n    const std::string Colors::STRIPED        = \"\\033[9m\";\n    const std::string Colors::BLACK          = \"\\033[30m\";\n    const std::string Colors::RED            = \"\\033[31m\";\n    const std::string Colors::GREEN          = \"\\033[32m\";\n    const std::string Colors::YELLOW         = \"\\033[33m\";\n    const std::string Colors::BLUE           = \"\\033[34m\";\n    const std::string Colors::PURPLE         = \"\\033[35m\";\n    const std::string Colors::CYAN           = \"\\033[36m\";\n    const std::string Colors::GREY           = \"\\033[37m\";\n    const std::string Colors::F_BLACK        = \"\\033[90m\";\n    const std::string Colors::F_RED          = \"\\033[91m\";\n    const std::string Colors::F_GREEN        = \"\\033[92m\";\n    const std::string Colors::F_YELLOW       = \"\\033[93m\";\n    const std::string Colors::F_BLUE         = \"\\033[94m\";\n    const std::string Colors::F_PURPLE       = \"\\033[95m\";\n    const std::string Colors::F_CYAN         = \"\\033[96m\";\n    const std::string Colors::F_GREY         = \"\\033[97m\";\n}\n</code></pre>"},{"location":"coverage/flint/src/Colors/Colors.hpp/","title":"Colors.hpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Thu, May, 2024                                                     *\n * Title           - CppLib                                                             *\n * Description     -                                                                    *\n *     Colors                                                                           *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *       \u2584\u2580\u2580\u2588\u2584\u2584\u2584\u2584  \u2584\u2580\u2580\u2584\u2580\u2580\u2580\u2584  \u2584\u2580\u2580\u2588\u2580\u2584    \u2584\u2580\u2580\u2580\u2588\u2580\u2580\u2584  \u2584\u2580\u2580\u2588\u2584\u2584\u2584\u2584  \u2584\u2580\u2584\u2584\u2584\u2584   \u2584\u2580\u2580\u2584 \u2584\u2584             *\n *      \u2590  \u2584\u2580   \u2590 \u2588   \u2588   \u2588 \u2588   \u2588  \u2588  \u2588    \u2588  \u2590 \u2590  \u2584\u2580   \u2590 \u2588 \u2588    \u258c \u2588  \u2588   \u2584\u2580            *\n *        \u2588\u2584\u2584\u2584\u2584\u2584  \u2590  \u2588\u2580\u2580\u2580\u2580  \u2590   \u2588  \u2590  \u2590   \u2588       \u2588\u2584\u2584\u2584\u2584\u2584  \u2590 \u2588      \u2590  \u2588\u2584\u2584\u2584\u2588             *\n *        \u2588    \u258c     \u2588          \u2588        \u2588        \u2588    \u258c    \u2588         \u2588   \u2588             *\n *       \u2584\u2580\u2584\u2584\u2584\u2584    \u2584\u2580        \u2584\u2580\u2580\u2580\u2580\u2580\u2584   \u2584\u2580        \u2584\u2580\u2584\u2584\u2584\u2584    \u2584\u2580\u2584\u2584\u2584\u2584\u2580   \u2584\u2580  \u2584\u2580             *\n *       \u2588    \u2590   \u2588         \u2588       \u2588 \u2588          \u2588    \u2590   \u2588     \u2590   \u2588   \u2588               *\n *       \u2590        \u2590         \u2590       \u2590 \u2590          \u2590        \u2590         \u2590   \u2590               *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#ifndef INCLUDED_COLORS_HPP\n    #define INCLUDED_COLORS_HPP\n\n    #include \"../Headers.hpp\"\n\nnamespace Flint\n{\n    /**\n      * This class defined a good set of ANSI colors.\n      *\n      * @ingroup flint\n      *\n      * @tip\n      * It is recomended to use those through streams :\n      * std::cout &lt;&lt; Flint::Colors::GREEN &lt;&lt; \"Hacker time\" &lt;&lt; Flint::Colors::RESET &lt;&lt; std::endl;\n      *\n      * @info\n      * Please ALWAYS remember to close your colors with Flint::Colors::RESET.\n      * Failure to do si might result in broken displays, with weird colors everywhere\n    */\n    class Colors\n    {\n        public:\n            static const std::string RESET;\n            static const std::string BOLD;\n            static const std::string DISABLED;\n            static const std::string ITALIC;\n            static const std::string UNDERLINE;\n            static const std::string BLINK;\n            static const std::string HIGHLIGHTED;\n            static const std::string STRIPED;\n            static const std::string BLACK;\n            static const std::string RED;\n            static const std::string GREEN;\n            static const std::string YELLOW;\n            static const std::string BLUE;\n            static const std::string PURPLE;\n            static const std::string CYAN;\n            static const std::string GREY;\n            static const std::string F_BLACK;\n            static const std::string F_RED;\n            static const std::string F_GREEN;\n            static const std::string F_YELLOW;\n            static const std::string F_BLUE;\n            static const std::string F_PURPLE;\n            static const std::string F_CYAN;\n            static const std::string F_GREY;\n    };\n}\n\n#endif\n</code></pre>"},{"location":"coverage/flint/src/CxxABI/","title":"CxxABI","text":"Name Lines Covered Uncovered Coverage CxxABI.cpp 34 0 34 0.0% CxxABI.hpp 0 0 0 100.0% Summary 34 0 34 0.0%"},{"location":"coverage/flint/src/CxxABI/CxxABI.cpp/","title":"CxxABI.cpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Thu, May, 2024                                                     *\n * Title           - CppLib                                                             *\n * Description     -                                                                    *\n *     CxxABI                                                                           *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *       _|_|_|_|  _|_|_|    _|_|_|  _|_|_|_|_|  _|_|_|_|    _|_|_|  _|    _|           *\n *       _|        _|    _|    _|        _|      _|        _|        _|    _|           *\n *       _|_|_|    _|_|_|      _|        _|      _|_|_|    _|        _|_|_|_|           *\n *       _|        _|          _|        _|      _|        _|        _|    _|           *\n *       _|_|_|_|  _|        _|_|_|      _|      _|_|_|_|    _|_|_|  _|    _|           *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#include \"CxxABI.hpp\"\n\nnamespace Flint\n{\n    std::string CxxABI::demangle(const char* name)\n    {\n        int status = -4;\n        char* _out = abi::__cxa_demangle(name, nullptr, nullptr, &amp;status);\n        if (status != 0 &amp;&amp; _out)\n            free(_out);\n        if (status != 0)\n            return std::string(name);\n        std::string result(_out);\n        free(_out);\n        return result;\n    }\n\n    std::pair&lt;std::string, std::size_t&gt; CxxABI::getFuncInfos(const char* symbolInfos)\n    {\n        std::pair&lt;std::string, std::size_t&gt; output;\n        std::string entry(symbolInfos);\n\n        std::size_t openP  = entry.find('(');\n        std::size_t closeP = entry.find(')');\n\n        if (openP == std::string::npos ||\n            closeP == std::string::npos)\n            return output;\n\n        std::string functionAndOffset = entry.substr(openP + 1, closeP);\n        std::size_t plusP  = functionAndOffset.find('+');\n\n        if (functionAndOffset.empty() ||\n            plusP == std::string::npos)\n            return output;\n\n        output.first  = CxxABI::demangle(functionAndOffset.substr(0, plusP).c_str());\n        std::stringstream ss;\n        ss &lt;&lt; std::hex &lt;&lt; functionAndOffset.substr(plusP + 1);\n        ss &gt;&gt; output.second;\n\n        return output;\n    }\n\n    // std::vector&lt;std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt;&gt; CxxABI::getBacktrace()\n    std::vector&lt;std::pair&lt;std::string, std::size_t&gt;&gt; CxxABI::getBacktrace()\n    {\n        std::vector&lt;std::pair&lt;std::string, std::size_t&gt;&gt; out;\n        int TRACE_CHUNCK = 128;\n\n        int size = 0, out_size = 0;\n        do {\n            size += TRACE_CHUNCK;\n            void* trace[size + 1];\n            out_size = (int)backtrace(trace, size);\n        } while (out_size == size);\n        void* trace[out_size + 1];\n\n        backtrace(trace, out_size);\n        char** symbols = backtrace_symbols(trace, out_size);\n        if (symbols) {\n            for (int i = 0; i &lt; out_size; ++i) {\n                std::pair&lt;std::string, std::size_t&gt; symbol = CxxABI::getFuncInfos(symbols[i]);\n                if (symbol.first.empty())\n                    break;\n                out.push_back(symbol);\n            }\n            free(symbols);\n        }\n\n        return out;\n    }\n}\n</code></pre>"},{"location":"coverage/flint/src/CxxABI/CxxABI.hpp/","title":"CxxABI.hpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Thu, May, 2024                                                     *\n * Title           - CppLib                                                             *\n * Description     -                                                                    *\n *     CxxABI                                                                           *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *       \u2584\u2580\u2580\u2588\u2584\u2584\u2584\u2584  \u2584\u2580\u2580\u2584\u2580\u2580\u2580\u2584  \u2584\u2580\u2580\u2588\u2580\u2584    \u2584\u2580\u2580\u2580\u2588\u2580\u2580\u2584  \u2584\u2580\u2580\u2588\u2584\u2584\u2584\u2584  \u2584\u2580\u2584\u2584\u2584\u2584   \u2584\u2580\u2580\u2584 \u2584\u2584             *\n *      \u2590  \u2584\u2580   \u2590 \u2588   \u2588   \u2588 \u2588   \u2588  \u2588  \u2588    \u2588  \u2590 \u2590  \u2584\u2580   \u2590 \u2588 \u2588    \u258c \u2588  \u2588   \u2584\u2580            *\n *        \u2588\u2584\u2584\u2584\u2584\u2584  \u2590  \u2588\u2580\u2580\u2580\u2580  \u2590   \u2588  \u2590  \u2590   \u2588       \u2588\u2584\u2584\u2584\u2584\u2584  \u2590 \u2588      \u2590  \u2588\u2584\u2584\u2584\u2588             *\n *        \u2588    \u258c     \u2588          \u2588        \u2588        \u2588    \u258c    \u2588         \u2588   \u2588             *\n *       \u2584\u2580\u2584\u2584\u2584\u2584    \u2584\u2580        \u2584\u2580\u2580\u2580\u2580\u2580\u2584   \u2584\u2580        \u2584\u2580\u2584\u2584\u2584\u2584    \u2584\u2580\u2584\u2584\u2584\u2584\u2580   \u2584\u2580  \u2584\u2580             *\n *       \u2588    \u2590   \u2588         \u2588       \u2588 \u2588          \u2588    \u2590   \u2588     \u2590   \u2588   \u2588               *\n *       \u2590        \u2590         \u2590       \u2590 \u2590          \u2590        \u2590         \u2590   \u2590               *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#ifndef INCLUDED_CXXABI_HPP\n    #define INCLUDED_CXXABI_HPP\n\n    #include \"../Headers.hpp\"\n\nnamespace Flint\n{\n    /**\n      * Wrapper around usefull C++/C low level functions\n      *\n      * @ingroup flint\n      *\n      * Got demangle, backtrace...\n      *\n      * @tip\n      * This class is only made of static functions. It does not contain constructor, nor destructor\n      * This means that you don't need to instanciate it, and only use it as if it was a namespace.\n    */\n    class CxxABI\n    {\n        public:\n            CxxABI() = delete;\n\n            /**\n              * Demangle a C++ name.\n              *\n              * This is usefull for : Class names, backtrace...\n              *\n              * @return string containing : demangled name, or original name, if demangle did not work\n            */\n            static std::string demangle(const char* name);\n\n            /**\n              * Get functions infos from symbol extraction\n              *\n              * @return A pair with the function names demangled, and the offset from the function\n              *\n              * @warning\n              * The function name is not EXACTLY the real name of the function.\n              * Also, the offset DOES NOT correspond to the line number, but the offset of asm instructions\n            */\n            static std::pair&lt;std::string, std::size_t&gt; getFuncInfos(const char* symbolInfos);\n\n            /**\n              * Retreive the execution trace\n              *\n              * @return Vector of pair&lt;pair&lt;string, size_t&gt;, string&gt;. I'll explain\n              *\n              * The idea is to retrieive the file, line, and function. So that's what we do :\n              * pair or : (file, line), function\n              *\n              * @warning\n              * To correctly grab function names, you will need to add compilation flag \"-rdynamic\"\n              * See this lib's CMakeLists.txt for implementation.\n              * This will export ALL symbols.\n              * If NOT done, you will get offsets from binary. It's ok, but quite disgusting on output.\n            */\n            static std::vector&lt;std::pair&lt;std::string, std::size_t&gt;&gt; getBacktrace();\n    };\n}\n\n#endif\n</code></pre>"},{"location":"coverage/flint/src/Exceptions/","title":"Exceptions","text":"Name Lines Covered Uncovered Coverage Exceptions.cpp 43 0 43 0.0% Exceptions.hpp 1 0 1 0.0% Summary 44 0 44 0.0%"},{"location":"coverage/flint/src/Exceptions/Exceptions.cpp/","title":"Exceptions.cpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Sun, Apr, 2024                                                     *\n * Title           - CppLib                                                             *\n * Description     -                                                                    *\n *     Exceptions                                                                       *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *       _|_|_|_|  _|_|_|    _|_|_|  _|_|_|_|_|  _|_|_|_|    _|_|_|  _|    _|           *\n *       _|        _|    _|    _|        _|      _|        _|        _|    _|           *\n *       _|_|_|    _|_|_|      _|        _|      _|_|_|    _|        _|_|_|_|           *\n *       _|        _|          _|        _|      _|        _|        _|    _|           *\n *       _|_|_|_|  _|        _|_|_|      _|      _|_|_|_|    _|_|_|  _|    _|           *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#include \"Exceptions.hpp\"\n\nnamespace Flint::Exceptions\n{\n    Exception::Exception(const std::string&amp; what, std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; infos):\n        _infos(infos)\n    {\n        std::vector&lt;std::pair&lt;std::string, std::size_t&gt;&gt; stackTrace = CxxABI::getBacktrace();\n        std::stringstream ss;\n\n        ss &lt;&lt; \"[\" &lt;&lt; Flint::Colors::F_PURPLE &lt;&lt; this-&gt;getClassNameFromStackTrace(stackTrace) &lt;&lt; Flint::Colors::RESET;\n\n        if (!infos.first.first.empty() &amp;&amp; !infos.second.empty()) {\n            ss &lt;&lt; \" in \" &lt;&lt;\n                Flint::Colors::F_YELLOW &lt;&lt; infos.second &lt;&lt; Flint::Colors::RESET &lt;&lt;\n                \" at \" &lt;&lt;\n                Flint::Colors::F_BLUE &lt;&lt; infos.first.first.substr(infos.first.first.find_last_of(\"/\\\\\") + 1) &lt;&lt; Flint::Colors::RESET &lt;&lt;\n                \":\" &lt;&lt;\n                Flint::Colors::F_RED &lt;&lt; infos.first.second &lt;&lt; Flint::Colors::RESET;\n        }\n        ss &lt;&lt; \"] \" &lt;&lt; what;\n\n        for (std::size_t i = 2; i &lt; stackTrace.size(); i++) {\n            std::string funcName = stackTrace[i].first;\n            std::size_t openP    = funcName.find('(');\n            if (openP == std::string::npos)\n                funcName += \"()\";\n            funcName = funcName.substr(0, funcName.find(\"(\") + 1) + \"[...])\";\n            ss &lt;&lt; std::endl &lt;&lt; \" -&gt; \" &lt;&lt;\n            Flint::Colors::CYAN &lt;&lt; funcName &lt;&lt; Flint::Colors::RESET &lt;&lt;\n            \":\" &lt;&lt;\n            Flint::Colors::YELLOW &lt;&lt; \"0x\" &lt;&lt; std::hex &lt;&lt; stackTrace[i].second &lt;&lt; Flint::Colors::RESET;\n        }\n\n        this-&gt;_what = ss.str();\n    }\n\n    std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; Exception::getInfos() const\n    {\n        return this-&gt;_infos;\n    }\n\n    std::string Exception::getClassNameFromStackTrace(const std::vector&lt;std::pair&lt;std::string, std::size_t&gt;&gt;&amp; stackTrace) const\n    {\n        if (stackTrace.size() &lt;= 2)\n            return \"[Class name undefined]\";\n\n        std::string classNameSymbol = stackTrace[2].first.substr();\n        std::size_t openP           = classNameSymbol.find('(');\n        if (openP == std::string::npos)\n            return \"[Class name undefined]\";\n\n        std::string functionName = classNameSymbol.substr(0, openP);\n        std::size_t lastColon    = functionName.rfind(\"::\");\n        if (lastColon == std::string::npos)\n            return \"[Class name undefined]\";\n        // Remove duplicate\n        return functionName.substr(0, lastColon);\n    }\n\n    std::string Exception::show(std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; fileInfos) const\n    {\n        std::stringstream ss;\n        ss &lt;&lt; \"Exception caught on \" &lt;&lt;\n              Flint::Colors::F_GREEN &lt;&lt; fileInfos.second       &lt;&lt; Flint::Colors::RESET &lt;&lt; \" at \" &lt;&lt;\n              Flint::Colors::F_BLUE  &lt;&lt; fileInfos.first.first  &lt;&lt; Flint::Colors::RESET &lt;&lt; \":\" &lt;&lt;\n              Flint::Colors::F_RED   &lt;&lt; fileInfos.first.second &lt;&lt; Flint::Colors::RESET &lt;&lt; std::endl &lt;&lt; std::endl;\n\n        ss &lt;&lt; this-&gt;_what;\n        return ss.str();\n    }\n\n    const char* Exception::what() const noexcept\n    {\n        return this-&gt;_what.c_str();\n    }\n\n    std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Exceptions::Exception&amp; obj)\n    {\n        os &lt;&lt; obj.what();\n        return os;\n    }\n}\n</code></pre>"},{"location":"coverage/flint/src/Exceptions/Exceptions.hpp/","title":"Exceptions.hpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Sun, Apr, 2024                                                     *\n * Title           - CppLib                                                             *\n * Description     -                                                                    *\n *     Exceptions                                                                       *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557  \u2588\u2588\u2557                     *\n *             \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551  \u2588\u2588\u2551                     *\n *             \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551                     *\n *             \u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551                     *\n *             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551                     *\n *             \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d     \u255a\u2550\u255d   \u255a\u2550\u255d   \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d                     *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#ifndef INCLUDED_EXCEPTIONS_HPP\n    #define INCLUDED_EXCEPTIONS_HPP\n\n    #include \"../Headers.hpp\"\n    #include \"../CxxABI/CxxABI.hpp\"\n    #include \"../Colors/Colors.hpp\"\n    #include \"../hpp/Preprocessor.hpp\"\n\nnamespace Flint::Exceptions\n{\n    /**\n      * Wrapper arround default [std::exception](https://en.cppreference.com/w/cpp/error/exception)\n      *\n      * @ingroup flint\n      *\n      * Store the the exception description as [std::string](https://en.cppreference.com/w/cpp/string/basic_string),\n      * and store some usefull localisation informations: Filename, Line, and Function Name.\n      * This is automated using the throw_exception preprocessor directive.\n      *\n      * @tip\n      * Take a look at the NotImplementedError to see how easy it is to implmeent your own Flint::Exception.\n    */\n    class Exception: public std::exception\n    {\n        protected:\n            std::string _what;\n            std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; _infos;\n        public:\n            /**\n              * Exception constructor. This need to be called, even on child classes.\n              *\n              * @param what Define the exception's description\n              * @param infos Might contain positional infos\n              *\n              * @warning\n              * You should **NOT** use any excpetion constructor manually.\n              * While they might work, the prefered way is to use the throw_exception preprocessor directive.\n              * Using it will only require you to register what type of excpetion you want to throw, and what message you want to add, and will take care of putting file name, line, and function name\n            */\n            Exception(const std::string&amp; what = \"An exception occured !\",\n                      std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; infos = {{\"\", 0}, \"\"});\n\n            /**\n              * Retreive given infos (filename, line, and function name)\n              *\n              * @return The actual infos\n            */\n            std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; getInfos() const;\n\n            /**\n              * Try to retreive the Exception class name from the StackTrace.\n              *\n              * @param stackTrace A stack trace, formated like CxxABI::getBacktrace()\n              *\n              * @warning\n              * This function **DOES NOT WORK 100% OF THE TIME**.\n              * It is really dependant on the environement, and can return undefined without aparent reason.\n              * It should **NOT** be used for anything else than debug or display.\n              *\n              * @return The actual class name or \"[Class name undefined]\"\n            */\n            std::string getClassNameFromStackTrace(const std::vector&lt;std::pair&lt;std::string, std::size_t&gt;&gt;&amp; stackTrace) const;\n\n            /**\n              * Display the error, given specific positional infos (like the constructor).\n              *\n              * @param infos Positional informations, like the constructor, used to display the infos.\n              *\n              * @note\n              * This function, while being usable without, should be used through the catch_exception preprocessor directive.\n              * This preprocessor directive let you display Python like excpetion trace.\n              *\n              * @return The formated exception, ready to be displayed.\n            */\n            std::string show(std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; infos) const;\n\n            /**\n              * Required override, deprecated by show and catch_exception.\n              *\n              * @info\n              * This is the required std::exception override.\n              * It'll return the _what as a const char*.\n              * While this will work, prefer using the show function or the catch_excpetion preprocessor directive :\n              *\n              * @example\n              * ```cpp\n              * try {\n              *     throw_exception(Flint::Exceptions::Exception, \"Sample testing exception\");\n              * } catch (const Flint::Exceptions::Exception&amp; e) {\n              *     std::cerr &lt;&lt; catch_exception(e) &lt;&lt; std::endl;\n              * }\n              * ```\n              *\n              * @return The _what as a C string\n            */\n            const char* what() const noexcept override;\n\n            /**\n              * operator&lt;&lt; override\n              *\n              * @abstract\n              * This will simply append the _what to the ostream\n            */\n            friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Exceptions::Exception&amp; obj);\n    };\n\n    /**\n      * Sample Flint::Exceptions::Exception to register NotImplemented features\n      *\n      * @ingroup flint\n      *\n      * @tip\n      * You should use that Exception as a C++ Implementation of the Rust todo!() macro.\n      *\n      * @example\n      * ```cpp\n      * throw_exception(Flint::Exceptions::NotImplementedError, \"This function haven't been implemented as of today !\");\n      * ```\n    */\n    class NotImplementedError:\n        public Flint::Exceptions::Exception\n    {\n        public:\n            NotImplementedError(const std::string&amp; what = \"Asked action haven't been implemented yet.\",\n                                std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; infos = {{\"\", 0}, \"\"}):\n                Exception(what, infos)\n            {}\n    };\n}\n\n#endif\n</code></pre>"},{"location":"coverage/flint/src/Init/","title":"Init","text":"Name Lines Covered Uncovered Coverage Init.cpp 6 0 6 0.0% Init.hpp 0 0 0 100.0% Summary 6 0 6 0.0%"},{"location":"coverage/flint/src/Init/Init.cpp/","title":"Init.cpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Thu, May, 2024                                                     *\n * Title           - Flint                                                              *\n * Description     -                                                                    *\n *     Init                                                                             *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *       \u2584\u2580\u2580\u2588\u2584\u2584\u2584\u2584  \u2584\u2580\u2580\u2584\u2580\u2580\u2580\u2584  \u2584\u2580\u2580\u2588\u2580\u2584    \u2584\u2580\u2580\u2580\u2588\u2580\u2580\u2584  \u2584\u2580\u2580\u2588\u2584\u2584\u2584\u2584  \u2584\u2580\u2584\u2584\u2584\u2584   \u2584\u2580\u2580\u2584 \u2584\u2584             *\n *      \u2590  \u2584\u2580   \u2590 \u2588   \u2588   \u2588 \u2588   \u2588  \u2588  \u2588    \u2588  \u2590 \u2590  \u2584\u2580   \u2590 \u2588 \u2588    \u258c \u2588  \u2588   \u2584\u2580            *\n *        \u2588\u2584\u2584\u2584\u2584\u2584  \u2590  \u2588\u2580\u2580\u2580\u2580  \u2590   \u2588  \u2590  \u2590   \u2588       \u2588\u2584\u2584\u2584\u2584\u2584  \u2590 \u2588      \u2590  \u2588\u2584\u2584\u2584\u2588             *\n *        \u2588    \u258c     \u2588          \u2588        \u2588        \u2588    \u258c    \u2588         \u2588   \u2588             *\n *       \u2584\u2580\u2584\u2584\u2584\u2584    \u2584\u2580        \u2584\u2580\u2580\u2580\u2580\u2580\u2584   \u2584\u2580        \u2584\u2580\u2584\u2584\u2584\u2584    \u2584\u2580\u2584\u2584\u2584\u2584\u2580   \u2584\u2580  \u2584\u2580             *\n *       \u2588    \u2590   \u2588         \u2588       \u2588 \u2588          \u2588    \u2590   \u2588     \u2590   \u2588   \u2588               *\n *       \u2590        \u2590         \u2590       \u2590 \u2590          \u2590        \u2590         \u2590   \u2590               *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#include \"Init.hpp\"\n\nnamespace Flint\n{\n    static void unhandeled_exception()\n    {\n        try {\n            std::rethrow_exception(std::current_exception());\n        } catch (const std::exception&amp; e) {\n            const Flint::Exceptions::Exception* exception = dynamic_cast&lt;const Flint::Exceptions::Exception*&gt;(&amp;e);\n            if (exception != nullptr) {\n                std::cerr &lt;&lt; Flint::Colors::RED &lt;&lt; \"/!\\\\\" &lt;&lt; Flint::Colors::RESET &lt;&lt; \" Uncaught Flint exception \" &lt;&lt; Flint::Colors::RED &lt;&lt; \"/!\\\\\" &lt;&lt; Flint::Colors::RESET &lt;&lt; std::endl &lt;&lt; std::endl &lt;&lt; *exception &lt;&lt; std::endl;\n            } else {\n                std::cerr &lt;&lt; Flint::Colors::RED &lt;&lt; \"/!\\\\\" &lt;&lt; Flint::Colors::RESET &lt;&lt; \" Uncaught exception \" &lt;&lt; Flint::Colors::RED &lt;&lt; \"/!\\\\\" &lt;&lt; Flint::Colors::RESET &lt;&lt; std::endl &lt;&lt; std::endl &lt;&lt; e.what() &lt;&lt; std::endl;\n            }\n        }\n    }\n\n    void Init()\n    {\n        std::set_terminate(unhandeled_exception);\n    }\n}\n</code></pre>"},{"location":"coverage/flint/src/Init/Init.hpp/","title":"Init.hpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Thu, May, 2024                                                     *\n * Title           - Flint                                                              *\n * Description     -                                                                    *\n *     Init                                                                             *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557  \u2588\u2588\u2557                     *\n *             \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551  \u2588\u2588\u2551                     *\n *             \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551                     *\n *             \u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551                     *\n *             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551                     *\n *             \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d     \u255a\u2550\u255d   \u255a\u2550\u255d   \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d                     *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#ifndef INCLUDED_INIT_HPP\n    #define INCLUDED_INIT_HPP\n\n    #include \"../Exceptions/Exceptions.hpp\"\n\nnamespace Flint\n{\n    [[gnu::constructor]] void Init();\n}\n\n#endif\n</code></pre>"},{"location":"coverage/flint/src/Logging/","title":"Logging","text":"Name Lines Covered Uncovered Coverage Logging.cpp 8 0 8 0.0% Logging.hpp 1 0 1 0.0% Summary 9 0 9 0.0%"},{"location":"coverage/flint/src/Logging/Logging.cpp/","title":"Logging.cpp","text":"<pre><code>#include \"Logging.hpp\"\n\nnamespace Flint\n{\n    Logging&amp; Logging::get()\n    {\n        static Logging instance;\n        return instance;\n    }\n\n    void Logging::set_log_on_stderr(bool log_on_stderr)\n    {\n        Logging::get().log_on_stderr = log_on_stderr;\n    }\n\n    void Logging::set_log_level(LogLevel level)\n    {\n        Logging::get().display_level = level;\n    }\n\n    void Logging::set_error_level(LogLevel level)\n    {\n        Logging::get().error_level = level;\n    }\n\n    void Logging::debug(const std::string&amp; message)\n    {\n        auto some_data = Flint::CxxABI::getBacktrace();\n        std::cout &lt;&lt; some_data.size() &lt;&lt; std::endl;\n        for (auto entry: some_data)\n            std::cout &lt;&lt; entry.first &lt;&lt; \" - \" &lt;&lt; entry.second &lt;&lt; std::endl;\n    }\n\n    void Logging::info(const std::string&amp; message)\n    {\n\n    }\n\n    void Logging::warning(const std::string&amp; message)\n    {\n\n    }\n\n    void Logging::error(const std::string&amp; message)\n    {\n\n    }\n\n    void Logging::critical(const std::string&amp; message)\n    {\n\n    }\n}\n</code></pre>"},{"location":"coverage/flint/src/Logging/Logging.hpp/","title":"Logging.hpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Sun, Apr, 2024                                                     *\n * Title           - CppLib                                                             *\n * Description     -                                                                    *\n *     Exceptions                                                                       *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557  \u2588\u2588\u2557                     *\n *             \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551  \u2588\u2588\u2551                     *\n *             \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551                     *\n *             \u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551                     *\n *             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551                     *\n *             \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d     \u255a\u2550\u255d   \u255a\u2550\u255d   \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d                     *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#ifndef INCLUDED_LOGGING_HPP\n    #define INCLUDED_LOGGING_HPP\n\n    #include \"../Headers.hpp\"\n    #include \"../CxxABI/CxxABI.hpp\"\n    #include \"../Colors/Colors.hpp\"\n    #include \"../Exceptions/Exceptions.hpp\"\n\nnamespace Flint\n{\n    enum LogLevel\n    {\n        Debug       = 0,\n        Info        = 1,\n        Warning     = 2,\n        Error       = 3,\n        Critical    = 4,\n    };\n\n    class TooHighLevelLoggingError:\n        public Flint::Exceptions::Exception\n    {\n        public:\n            TooHighLevelLoggingError(const std::string&amp; what = \"The message logged is of criticly high level.\",\n                                     std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; infos = {{\"\", 0}, \"\"}):\n                Exception(what, infos)\n            {}\n    };\n\n    class Logging\n    {\n        private:\n            Logging() {}\n\n            bool log_on_stderr      = false;\n            LogLevel display_level  = LogLevel::Info;\n            LogLevel error_level    = LogLevel::Critical;\n\n            static Logging&amp; get();\n\n        public:\n            Logging(const Logging&amp;)         = delete;\n            void operator=(const Logging&amp;)  = delete;\n\n            static void set_log_on_stderr(bool log_on_stderr);\n            static void set_log_level(LogLevel level);\n            static void set_error_level(LogLevel level);\n\n            static void debug(const std::string&amp; message);\n            static void info(const std::string&amp; message);\n            static void warning(const std::string&amp; message);\n            static void error(const std::string&amp; message);\n            static void critical(const std::string&amp; message);\n    };\n}\n\n#endif\n</code></pre>"},{"location":"coverage/flint/src/hpp/","title":"hpp","text":"Name Lines Covered Uncovered Coverage Inspection.hpp 8 0 8 0.0% Preprocessor.hpp 0 0 0 100.0% Summary 8 0 8 0.0%"},{"location":"coverage/flint/src/hpp/Inspection.hpp/","title":"Inspection.hpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Thu, May, 2024                                                     *\n * Title           - CppLib                                                             *\n * Description     -                                                                    *\n *     Inspection                                                                       *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *         \u2591        \u2591       \u2591\u2591        \u2591        \u2591        \u2591\u2591      \u2591\u2591  \u2591\u2591\u2591\u2591  \u2591             *\n *         \u2592  \u2592\u2592\u2592\u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592  \u2592  \u2592\u2592\u2592\u2592  \u2592             *\n *         \u2593      \u2593\u2593\u2593       \u2593\u2593\u2593\u2593\u2593  \u2593\u2593\u2593\u2593\u2593\u2593\u2593  \u2593\u2593\u2593\u2593      \u2593\u2593\u2593  \u2593\u2593\u2593\u2593\u2593\u2593\u2593        \u2593             *\n *         \u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588  \u2588  \u2588\u2588\u2588\u2588  \u2588             *\n *         \u2588        \u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588        \u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588        \u2588\u2588      \u2588\u2588  \u2588\u2588\u2588\u2588  \u2588             *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#ifndef INCLUDED_INSPECTION_HPP\n    #define INCLUDED_INSPECTION_HPP\n\n    #include \"../Headers.hpp\"\n    #include \"../CxxABI/CxxABI.hpp\"\n\nnamespace Flint\n{\n    /**\n      * Base class to implement simplet self-reflexion in C++\n      *\n      * @ingroup flint\n      *\n      * @tparam T Child class itself\n      *\n      * @tip\n      * When creating a child class, define as follow :\n      * ```cpp\n      * class ChildClass: public Inspection&lt;ChildClass&gt;\n      * ```\n      * This will extand the ChildClass with the self-reflexion class Inspection\n      *\n      * @warning\n      * If the class you want to extand as a reflected class will be a parent class\n      * (I.E. You will create childs of this \"target\" class), you might want to\n      * mark inheritence as **virtual**.\n      * This is needed if your child class _also_ need to be reflected.\n      * This way, there is no confilict between the parent reflexion, and the child reflexion.\n    */\n    template &lt;typename T&gt;\n    class Inspection\n    {\n        public:\n            /**\n              * Return the name of the reflected class\n              *\n              * @return The demangled name of the class, or just the name, if demangleing failed\n            */\n            virtual std::string getClassName() const final\n            {\n                return CxxABI::demangle(typeid(T).name());\n            }\n\n            // virtual std::unordered_set&lt;std::pair&lt;std::string, std::string&gt;&gt; getAttributes();\n\n            /**\n              * Return a string representation of the class\n              *\n              * @tip\n              * This function is not intended to be used.\n              * This is because this functions display the reflection.\n              * You might prefer to override this function in yout child\n              * class to display informations that are more relevant to\n              * your specific class.\n              *\n              * @example\n              * You have a Macro available to make the str function really\n              * easilly :\n              * ```cpp\n              * display_attr(attribute)\n              * ```\n              * Which will automaticly translate to\n              * ```cpp\n              * Flint::Colors::F_BLUE &lt;&lt; \"attribute\" &lt;&lt; Flint::Colors::RESET &lt;&lt; \"=\" &lt;&lt; Flint::Colors::RED &lt;&lt; this-&gt;attribute &lt;&lt; Flint::Colors::RESET\n              * ```\n              * There is also a `make_str` macro, which you can use as follow :\n              * ```cpp\n              * return make_str(\"a=12\" &lt;&lt; \", \" &lt;&lt; \"b=5\");\n              * ```\n              * that becomes\n              * ```cpp\n              * return ({std::stringstream ss; ss &lt;&lt; \"&lt;\" &lt;&lt; this-&gt;getClassName() &lt;&lt; \" at \" &lt;&lt; std::hex &lt;&lt; this &lt;&lt; \": \" &lt;&lt; \"a=12\" &lt;&lt; \", \" &lt;&lt; \"b=5\" &lt;&lt; \"&gt;\"; ss.str()})\n              * ```\n              * It means you can define the str function of your class as like that :\n              * ```cpp\n              * // Provided you have 3 attributes called a, b and c\n              * return make_str(display_attr(a) &lt;&lt; \", \" &lt;&lt; display_attr(b) &lt;&lt; \", \" &lt;&lt; display_attr(c));\n              * ```\n              *\n              * @return The string representation of the class\n            */\n            virtual std::string str() const\n            {\n                std::stringstream ss;\n\n                ss &lt;&lt; \"&lt;\" &lt;&lt;\n                    Flint::Colors::F_PURPLE &lt;&lt; this-&gt;getClassName() &lt;&lt; Flint::Colors::RESET &lt;&lt;\n                    \" at \" &lt;&lt;\n                    Flint::Colors::YELLOW   &lt;&lt; std::hex &lt;&lt; this     &lt;&lt; Flint::Colors::RESET &lt;&lt;\n                    \"&gt;\";\n\n                return ss.str();\n            }\n\n            /** Overload the operator &lt;&lt; to use the str method of the object\n              *\n              * @tparam T Reflected class\n              *\n              * @param os Reference of ostream (I.E. std::cout, std::cerr...)\n              *\n              * @param obj Object reference to be displayed\n              *\n              * @return Param os\n            */\n            friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Inspection&lt;T&gt;&amp; obj)\n            {\n                os &lt;&lt; obj.str();\n                return os;\n            }\n    };\n}\n\n\n#endif\n</code></pre>"},{"location":"coverage/flint/src/hpp/Preprocessor.hpp/","title":"Preprocessor.hpp","text":"<pre><code>/* ------------------------------------------------------------------------------------ *\n *                                                                                      *\n * EPITECH PROJECT - Thu, May, 2024                                                     *\n * Title           - CppLib                                                             *\n * Description     -                                                                    *\n *     Preprocessor                                                                     *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ *\n *                                                                                      *\n *       \u2584\u2580\u2580\u2588\u2584\u2584\u2584\u2584  \u2584\u2580\u2580\u2584\u2580\u2580\u2580\u2584  \u2584\u2580\u2580\u2588\u2580\u2584    \u2584\u2580\u2580\u2580\u2588\u2580\u2580\u2584  \u2584\u2580\u2580\u2588\u2584\u2584\u2584\u2584  \u2584\u2580\u2584\u2584\u2584\u2584   \u2584\u2580\u2580\u2584 \u2584\u2584             *\n *      \u2590  \u2584\u2580   \u2590 \u2588   \u2588   \u2588 \u2588   \u2588  \u2588  \u2588    \u2588  \u2590 \u2590  \u2584\u2580   \u2590 \u2588 \u2588    \u258c \u2588  \u2588   \u2584\u2580            *\n *        \u2588\u2584\u2584\u2584\u2584\u2584  \u2590  \u2588\u2580\u2580\u2580\u2580  \u2590   \u2588  \u2590  \u2590   \u2588       \u2588\u2584\u2584\u2584\u2584\u2584  \u2590 \u2588      \u2590  \u2588\u2584\u2584\u2584\u2588             *\n *        \u2588    \u258c     \u2588          \u2588        \u2588        \u2588    \u258c    \u2588         \u2588   \u2588             *\n *       \u2584\u2580\u2584\u2584\u2584\u2584    \u2584\u2580        \u2584\u2580\u2580\u2580\u2580\u2580\u2584   \u2584\u2580        \u2584\u2580\u2584\u2584\u2584\u2584    \u2584\u2580\u2584\u2584\u2584\u2584\u2580   \u2584\u2580  \u2584\u2580             *\n *       \u2588    \u2590   \u2588         \u2588       \u2588 \u2588          \u2588    \u2590   \u2588     \u2590   \u2588   \u2588               *\n *       \u2590        \u2590         \u2590       \u2590 \u2590          \u2590        \u2590         \u2590   \u2590               *\n *                                                                                      *\n * ------------------------------------------------------------------------------------ */\n\n#ifndef INCLUDED_PREPROCESSOR_HPP\n    #define INCLUDED_PREPROCESSOR_HPP\n\n#if defined(__GNUC__)\n    #define __FUNCTION__ __PRETTY_FUNCTION__\n#elif defined(_MSC_VER)\n    #define __FUNCTION__ __FUNCSIG__\n#else\n    #define __FUNCTION__ __func__\n#endif\n\n    #define __POSITION_INFOS__ {{std::string(__FILE__), __LINE__}, std::string(__FUNCTION__)}\n    #define throw_exception(exception, message) throw(exception(message, __POSITION_INFOS__))\n    #define catch_exception(exception) exception.show(__POSITION_INFOS__)\n\n// Inspection\n    #define display_attr(attribute) Flint::Colors::F_BLUE &lt;&lt; #attribute &lt;&lt; Flint::Colors::RESET &lt;&lt; \"=\" &lt;&lt; Flint::Colors::RED &lt;&lt; this-&gt;attribute &lt;&lt; Flint::Colors::RESET\n    #define make_str(display) ({std::stringstream ss; ss &lt;&lt; Flint::Colors::RESET &lt;&lt; \"&lt;\" &lt;&lt; Flint::Colors::F_PURPLE &lt;&lt; this-&gt;getClassName() &lt;&lt; Flint::Colors::RESET &lt;&lt; \" at \" &lt;&lt; Flint::Colors::YELLOW &lt;&lt; std::hex &lt;&lt; this &lt;&lt; std::dec &lt;&lt; Flint::Colors::RESET &lt;&lt; \": \" &lt;&lt; display &lt;&lt; \"&gt;\"; ss.str();})\n\n#endif\n</code></pre>"},{"location":"coverage/network/","title":"network","text":"Name Lines Covered Uncovered Coverage src 101 0 101 0.0% Security 71 0 71 0.0% DecodeError.hpp 3 0 3 0.0% GaloisField.cpp 8 0 8 0.0% GaloisField.hpp 1 0 1 0.0% HammingCodes.cpp 55 0 55 0.0% HammingCodes.hpp 1 0 1 0.0% ReedSolomon.cpp 2 0 2 0.0% ReedSolomon.hpp 1 0 1 0.0% Serialized 3 0 3 0.0% PlayerPosition.cpp 3 0 3 0.0% PlayerPosition.hpp 0 0 0 100.0% Server 27 0 27 0.0% UDP 27 0 27 0.0% UDPServer.cpp 27 0 27 0.0% UDPServer.hpp 0 0 0 100.0% Summary 71 0 71 0.0% Summary 3 0 3 0.0% Summary 27 0 27 0.0% Summary 27 0 27 0.0% Summary 101 0 101 0.0% Summary 101 0 101 0.0%"},{"location":"coverage/network/src/","title":"src","text":"Name Lines Covered Uncovered Coverage Security 71 0 71 0.0% DecodeError.hpp 3 0 3 0.0% GaloisField.cpp 8 0 8 0.0% GaloisField.hpp 1 0 1 0.0% HammingCodes.cpp 55 0 55 0.0% HammingCodes.hpp 1 0 1 0.0% ReedSolomon.cpp 2 0 2 0.0% ReedSolomon.hpp 1 0 1 0.0% Serialized 3 0 3 0.0% PlayerPosition.cpp 3 0 3 0.0% PlayerPosition.hpp 0 0 0 100.0% Server 27 0 27 0.0% UDP 27 0 27 0.0% UDPServer.cpp 27 0 27 0.0% UDPServer.hpp 0 0 0 100.0% Summary 71 0 71 0.0% Summary 3 0 3 0.0% Summary 27 0 27 0.0% Summary 27 0 27 0.0% Summary 101 0 101 0.0%"},{"location":"coverage/network/src/Security/","title":"Security","text":"Name Lines Covered Uncovered Coverage DecodeError.hpp 3 0 3 0.0% GaloisField.cpp 8 0 8 0.0% GaloisField.hpp 1 0 1 0.0% HammingCodes.cpp 55 0 55 0.0% HammingCodes.hpp 1 0 1 0.0% ReedSolomon.cpp 2 0 2 0.0% ReedSolomon.hpp 1 0 1 0.0% Summary 71 0 71 0.0%"},{"location":"coverage/network/src/Security/DecodeError.hpp/","title":"DecodeError.hpp","text":"<pre><code>#ifndef INCLUDED_NETWORK_DECODE_ERROR_HPP\n    #define INCLUDED_NETWORK_DECODE_ERROR_HPP\n\n    #include \"Flint.hpp\"\n    #include \"../export.hpp\"\n\nnamespace Network::Security\n{\n    class NETWORK_API DecodingError:\n        public Flint::Exceptions::Exception\n    {\n        public:\n            DecodingError(const std::string&amp; what = \"Could not decode/verify received data.\",\n                          std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; infos = {{\"\", 0}, \"\"}):\n                Exception(what, infos)\n            {}\n    };\n}\n\n#endif\n</code></pre>"},{"location":"coverage/network/src/Security/GaloisField.cpp/","title":"GaloisField.cpp","text":"<pre><code>#include \"GaloisField.hpp\"\n\nnamespace Network::Security\n{\n    GaloisField::GaloisField(int primitive, int field_size):\n        primitive(primitive), field_size(field_size)\n    {\n        throw_exception(Flint::Exceptions::NotImplementedError, \"GaloisField haven't been implemented yet !\");\n        this-&gt;exp_table.resize(this-&gt;field_size);\n        this-&gt;log_table.resize(this-&gt;field_size);\n\n        unsigned char x = 1;\n        for (unsigned char i = 0; i &lt; this-&gt;field_size; ++i) {\n            this-&gt;exp_table[i] = x;\n            this-&gt;log_table[x] = i;\n            x = (x * 2) % field_size;\n        }\n    }\n}\n</code></pre>"},{"location":"coverage/network/src/Security/GaloisField.hpp/","title":"GaloisField.hpp","text":"<pre><code>#ifndef INCLUDED_NETWORK_GALOIS_FIELD_HPP\n    #define INCLUDED_NETWORK_GALOIS_FIELD_HPP\n\n    #include \"Flint.hpp\"\n    #include \"DecodeError.hpp\"\n    #include \"../export.hpp\"\n\nnamespace Network::Security\n{\n    class NETWORK_API GaloisField\n    {\n        private:\n            unsigned char primitive;\n            unsigned char field_size;\n            std::string exp_table;\n            std::string log_table;\n\n        public:\n            GaloisField(int primitive, int field_size);\n            void generate_field(int primitive);\n            int add(int a, int b);\n            int multiply(int a, int b);\n            int inverse(int a);\n            int divide(int a, int b);\n    };\n}\n\n#endif\n</code></pre>"},{"location":"coverage/network/src/Security/HammingCodes.cpp/","title":"HammingCodes.cpp","text":"<pre><code>#include \"HammingCodes.hpp\"\n\nnamespace Network::Security\n{\n    unsigned HammingCodes::get_nb_parity(unsigned size)\n    {\n        int p = 0;\n        while (pow(2, p) &lt; size + p + 1)\n            ++p;\n        return p;\n    }\n\n    unsigned HammingCodes::get_nb_parity_from_final_size(unsigned size)\n    {\n        int p = 0;\n        while (pow(2, p) &lt;= size)\n            ++p;\n        return p - 1;\n    }\n\n    void HammingCodes::setBit(std::string&amp; data, std::size_t pos, bool value)\n    {\n        size_t indx = pos / 8;\n        size_t ofst = pos % 8;\n        if (indx &gt;= data.size())\n            throw_exception(Network::Security::DecodingError, \"Position is outsize of the data !\");\n        if (value)\n            data[indx] |= (1 &lt;&lt; ofst);\n        else\n            data[indx] &amp;= ~(1 &lt;&lt; ofst);\n    }\n\n    bool HammingCodes::getBit(const std::string&amp; data, std::size_t pos)\n    {\n        size_t indx = pos / 8;\n        size_t ofst = pos % 8;\n        if (indx &gt;= data.size())\n            throw_exception(Network::Security::DecodingError, \"Position is outsize of the data !\");\n        return (data[indx] &gt;&gt; ofst) &amp; 1;\n    }\n\n    void HammingCodes::setParityBits(std::string&amp; data, unsigned size)\n    {\n        unsigned p = get_nb_parity(size);\n        for (unsigned i = 0; i &lt; p; ++i) {\n            unsigned p_pos = (1 &lt;&lt; i) - 1;\n            bool parity = false;\n\n            for (unsigned j = p_pos; j &lt; size; j += 2 * (p_pos + 1))\n                for (unsigned k = j; k &lt; j + (p_pos + 1) &amp;&amp; k &lt; size; ++k)\n                    if (k != p_pos)\n                        parity ^= HammingCodes::getBit(data, k);\n\n            HammingCodes::setBit(data, p_pos, parity);\n        }\n    }\n\n    std::string HammingCodes::encode(const std::string&amp; data)\n    {\n        unsigned dataBits = data.size() * 8;\n        unsigned parityBits = get_nb_parity(dataBits);\n        unsigned totalBits = dataBits + parityBits;\n\n        std::string coded_data((totalBits + 7) / 8, 0);\n\n        unsigned dataIndex = 0;\n        for (unsigned i = 0; i &lt; totalBits; ++i) {\n            if ((i &amp; (i + 1)) == 0)\n                continue;\n            setBit(coded_data, i, getBit(data, dataIndex));\n            ++dataIndex;\n        }\n\n        setParityBits(coded_data, totalBits);\n\n        return coded_data;\n    }\n\n    std::string HammingCodes::decode(const std::string&amp; data)\n    {\n        std::string output = data;\n        unsigned totalBits = output.size() * 8;\n        unsigned parityBits = get_nb_parity_from_final_size(totalBits);\n        unsigned dataBits = totalBits - parityBits;\n\n        unsigned errorPos = 0;\n        for (unsigned i = 0; i &lt; parityBits; ++i) {\n            unsigned parityPos = (1 &lt;&lt; i) - 1;\n            bool parity = false;\n\n            for (unsigned j = parityPos; j &lt; totalBits; j += 2 * (parityPos + 1))\n                for (unsigned k = j; k &lt; j + (parityPos + 1) &amp;&amp; k &lt; totalBits; ++k)\n                    parity ^= getBit(output, k);\n\n            if (parity)\n                errorPos |= (1 &lt;&lt; i);\n        }\n\n        if (errorPos)\n            HammingCodes::setBit(output, errorPos, !getBit(output, errorPos));\n\n        std::string decoded_data((dataBits + 7) / 8, 0);\n        unsigned dataIndex = 0;\n        for (unsigned i = 0; i &lt; totalBits; ++i) {\n            if ((i &amp; (i + 1)) == 0)\n                continue;\n            setBit(decoded_data, dataIndex, getBit(output, i));\n            ++dataIndex;\n        }\n\n        size_t last_non_null = decoded_data.find_last_not_of('\\0');\n        if (last_non_null != std::string::npos)\n            decoded_data.resize(last_non_null + 1);\n        else\n            decoded_data.clear();\n\n        return decoded_data;\n    }\n}\n</code></pre>"},{"location":"coverage/network/src/Security/HammingCodes.hpp/","title":"HammingCodes.hpp","text":"<pre><code>#ifndef INCLUDED_NETWORK_HAMMING_CODE_HPP\n    #define INCLUDED_NETWORK_HAMMING_CODE_HPP\n\n    #include \"Flint.hpp\"\n    #include \"DecodeError.hpp\"\n    #include \"../export.hpp\"\n\nnamespace Network::Security\n{\n    const int PRIMITIVE = 0x11d;\n    const int FIELD_SIZE = 256;\n    const int N = 255;\n    const int K = 223;\n\n    class NETWORK_API HammingCodes\n    {\n        private:\n            static unsigned get_nb_parity(unsigned size);\n            static unsigned get_nb_parity_from_final_size(unsigned size);\n            static void setBit(std::string&amp; byte, std::size_t pos, bool value);\n            static bool getBit(const std::string&amp; byte, std::size_t pos);\n            static void setParityBits(std::string&amp; data, unsigned size);\n        public:\n            static std::string encode(const std::string&amp; data);\n            static std::string decode(const std::string&amp; data);\n    };\n}\n\n\n#endif\n</code></pre>"},{"location":"coverage/network/src/Security/ReedSolomon.cpp/","title":"ReedSolomon.cpp","text":"<pre><code>#include \"ReedSolomon.hpp\"\n\nnamespace Network::Security\n{\n    ReedSolomon::ReedSolomon(int primitive, int field_size, int n, int k):\n        gf(primitive, field_size), primitive(primitive), field_size(field_size), n(n), k(k)\n    {\n        throw_exception(Flint::Exceptions::NotImplementedError, \"ReedSolomon haven't been implemented yet !\");\n    }\n}\n</code></pre>"},{"location":"coverage/network/src/Security/ReedSolomon.hpp/","title":"ReedSolomon.hpp","text":"<pre><code>#ifndef INCLUDED_NETWORK_REED_SOLOMON_HPP\n    #define INCLUDED_NETWORK_REED_SOLOMON_HPP\n\n    #include \"Flint.hpp\"\n    #include \"DecodeError.hpp\"\n    #include \"GaloisField.hpp\"\n    #include \"../export.hpp\"\n\nnamespace Network::Security\n{\n    class NETWORK_API ReedSolomon\n    {\n        private:\n            GaloisField gf;\n            int primitive;\n            int field_size;\n            int n, k;\n\n        public:\n            ReedSolomon(int primitive, int field_size, int n, int k);\n            std::string encode(const std::string&amp; message);\n    };\n}\n#endif\n</code></pre>"},{"location":"coverage/network/src/Serialized/","title":"Serialized","text":"Name Lines Covered Uncovered Coverage PlayerPosition.cpp 3 0 3 0.0% PlayerPosition.hpp 0 0 0 100.0% Summary 3 0 3 0.0%"},{"location":"coverage/network/src/Serialized/PlayerPosition.cpp/","title":"PlayerPosition.cpp","text":"<pre><code>#include \"PlayerPosition.hpp\"\n\nnamespace Network::Serialized\n{\n    PlayerPosition::PlayerPosition(unsigned user_id, Direction player_direction):\n        user_id(user_id), player_direction(player_direction)\n    {}\n\n    std::string PlayerPosition::str() const\n    {\n        return make_str(display_attr(user_id) &lt;&lt; \", \" &lt;&lt; display_attr(player_direction));\n    }\n\n    template&lt;typename Archive&gt;\n    void PlayerPosition::serialize(Archive&amp; ar)\n    {\n        ar(this-&gt;user_id, this-&gt;player_direction);\n    }\n}\n</code></pre>"},{"location":"coverage/network/src/Serialized/PlayerPosition.hpp/","title":"PlayerPosition.hpp","text":"<pre><code>#ifndef INCLUDED_NETWORK_PLAYER_POSITION_HPP\n    #define INCLUDED_NETWORK_PLAYER_POSITION_HPP\n\n    #include \"Flint.hpp\"\n\nnamespace Network::Serialized\n{\n    enum Direction\n    {\n        NONE    = 0,\n        UP      = 1,\n        RIGHT   = 2,\n        DOWN    = 3,\n        LEFT    = 4,\n    };\n\n    /*\n     * This class contains a serialized version of the player's position.\n     *\n     * This is used as temporary \"hard coded\" version of transmitting informations within the network.\n     *\n     * @note\n     * When the network will get updated, this will get thanos snaped in order to be replaced by the actual components:\n     *\n     * The goal is to be able to send direct components, to ease the network and integration process.\n     *\n     * @warning\n     * This class does NOT contain every parts of the actual game !\n     * It only contains the position.\n    */\n    class PlayerPosition:\n        public Flint::Inspection&lt;PlayerPosition&gt;\n    {\n        // private:\n        public:\n            unsigned user_id;\n            Direction player_direction;\n            // float x;\n            // float y;\n\n        public:\n            PlayerPosition(unsigned user_id, Direction player_direction);\n\n            /**\n              * This class being a child of Flint::Inspection, overriding the str function also override the operator&lt;&lt;.\n              * This is done for debugging purposes.\n            */\n            std::string str() const override;\n\n            template&lt;typename Archive&gt;\n            void serialize(Archive&amp; ar);\n    };\n}\n\n#endif\n</code></pre>"},{"location":"coverage/network/src/Server/","title":"Server","text":"Name Lines Covered Uncovered Coverage UDP 27 0 27 0.0% UDPServer.cpp 27 0 27 0.0% UDPServer.hpp 0 0 0 100.0% Summary 27 0 27 0.0% Summary 27 0 27 0.0%"},{"location":"coverage/network/src/Server/UDP/","title":"UDP","text":"Name Lines Covered Uncovered Coverage UDPServer.cpp 27 0 27 0.0% UDPServer.hpp 0 0 0 100.0% Summary 27 0 27 0.0%"},{"location":"coverage/network/src/Server/UDP/UDPServer.cpp/","title":"UDPServer.cpp","text":"<pre><code>#include \"UDPServer.hpp\"\n\nnamespace Network::Server::UDP\n{\n    UDPServer::UDPServer(unsigned short port):\n        port(port), loop(uv_default_loop())\n    {\n        uv_udp_init(this-&gt;loop, &amp;this-&gt;server);\n    }\n\n    void UDPServer::set_callback(Network::HandlerFunction function)\n    {\n        this-&gt;handler = function;\n    }\n\n    void UDPServer::start()\n    {\n        sockaddr_in addr;\n        uv_ip4_addr(\"0.0.0.0\", port, &amp;addr);\n        uv_udp_bind(&amp;this-&gt;server, (const struct sockaddr*)&amp;addr, 0);\n        uv_udp_recv_start(&amp;this-&gt;server, on_alloc,\n            *std::function&lt;void(uv_udp_t*, ssize_t, const uv_buf_t*, const struct sockaddr*, unsigned)&gt;(\n                [this](uv_udp_t* handle, ssize_t nread, const uv_buf_t* buf, const struct sockaddr* addr, unsigned flags)\n                {\n                    UDPServer::on_receive(*this, handle, nread, buf, addr, flags);\n                }\n            ).target&lt;uv_udp_recv_cb&gt;()\n        );\n\n        flint_info(\"UDP Server listening on 0.0.0.0:\" + this-&gt;port);\n\n        uv_run(this-&gt;loop, UV_RUN_DEFAULT);\n    }\n\n    void UDPServer::stop()\n    {\n        uv_loop_close(this-&gt;loop);\n    }\n\n    void UDPServer::on_alloc(uv_handle_t* handle, size_t size, uv_buf_t* buf)\n    {\n        buf-&gt;base = new char[size];\n        buf-&gt;len = size;\n    }\n\n    void UDPServer::on_receive(const Network::Server::UDP::UDPServer&amp; self, uv_udp_t* handle, ssize_t nread, const uv_buf_t* buf, const struct sockaddr* addr, unsigned flags)\n    {\n        if (nread &lt; 0) {\n            if (nread != UV_EOF) {\n                std::cerr &lt;&lt; \"Error reading UDP message.\" &lt;&lt; std::endl;\n            }\n            return;\n        }\n\n        std::string serialized_data(buf-&gt;base, nread);\n        Network::Serialized::PlayerPosition data = UDPServer::deserialize_from_string(serialized_data);\n        delete[] buf-&gt;base;\n\n        if (self.handler)\n            self.handler(data);\n    }\n\n    Network::Serialized::PlayerPosition UDPServer::deserialize_from_string(const std::string&amp; str)\n    {\n        std::istringstream is(str);\n        cereal::BinaryInputArchive archive(is);\n        Network::Serialized::PlayerPosition data(0, Network::Serialized::Direction::NONE);\n        archive(data);\n        return data;\n    }\n\n    std::string UDPServer::serialize_to_string(const Network::Serialized::PlayerPosition&amp; data)\n    {\n        std::ostringstream os;\n        cereal::BinaryOutputArchive archive(os);\n        archive(data);\n        return os.str();\n    }\n}\n</code></pre>"},{"location":"coverage/network/src/Server/UDP/UDPServer.hpp/","title":"UDPServer.hpp","text":"<pre><code>#ifndef INCLUDED_NETWORK_UDP_SERVER_HPP\n    #define INCLUDED_NETWORK_UDP_SERVER_HPP\n\n    #include &lt;cstring&gt;\n    #include &lt;uv.h&gt;\n    #include &lt;cereal/archives/binary.hpp&gt;\n    #include &lt;cereal/types/string.hpp&gt;\n    #include &lt;sstream&gt;\n    #include &lt;functional&gt;\n\n    #include \"../../Exceptions.hpp\"\n    #include \"../../Serialized/PlayerPosition.hpp\"\n    #include \"../../HandlerFunction.hpp\"\n    #include \"Flint.hpp\"\n\nnamespace Network::Server::UDP\n{\n    class UDPServer\n    {\n        private:\n            uv_loop_t* loop = NULL;\n            uv_udp_t server;\n            unsigned short port;\n\n            Network::HandlerFunction handler = nullptr;\n\n        private:\n            static void on_alloc(uv_handle_t* handle, size_t size, uv_buf_t* buf);\n            static void on_receive(const Network::Server::UDP::UDPServer&amp; self, uv_udp_t* handle, ssize_t nread, const uv_buf_t* buf, const struct sockaddr* addr, unsigned flags);\n\n            static Network::Serialized::PlayerPosition deserialize_from_string(const std::string&amp; str);\n            static std::string serialize_to_string(const Network::Serialized::PlayerPosition&amp; data);\n\n        public:\n            UDPServer(unsigned short port);\n\n            void set_callback(HandlerFunction function);\n            void start();\n            void stop();\n    };\n}\n\n#endif\n</code></pre>"},{"location":"coverage/server/","title":"server","text":"Name Lines Covered Uncovered Coverage src 183 0 183 0.0% Network 40 0 40 0.0% Socket.cpp 40 0 40 0.0% Socket.hpp 0 0 0 100.0% Server 143 0 143 0.0% Client.cpp 28 0 28 0.0% Client.hpp 0 0 0 100.0% Core.cpp 98 0 98 0.0% Core.hpp 0 0 0 100.0% PlayerInfo.cpp 9 0 9 0.0% PlayerInfo.hpp 0 0 0 100.0% ThreadSafeQueue.hpp 8 0 8 0.0% Summary 40 0 40 0.0% Summary 143 0 143 0.0% Summary 183 0 183 0.0% Summary 183 0 183 0.0%"},{"location":"coverage/server/src/","title":"src","text":"Name Lines Covered Uncovered Coverage Network 40 0 40 0.0% Socket.cpp 40 0 40 0.0% Socket.hpp 0 0 0 100.0% Server 143 0 143 0.0% Client.cpp 28 0 28 0.0% Client.hpp 0 0 0 100.0% Core.cpp 98 0 98 0.0% Core.hpp 0 0 0 100.0% PlayerInfo.cpp 9 0 9 0.0% PlayerInfo.hpp 0 0 0 100.0% ThreadSafeQueue.hpp 8 0 8 0.0% Summary 40 0 40 0.0% Summary 143 0 143 0.0% Summary 183 0 183 0.0%"},{"location":"coverage/server/src/Network/","title":"Network","text":"Name Lines Covered Uncovered Coverage Socket.cpp 40 0 40 0.0% Socket.hpp 0 0 0 100.0% Summary 40 0 40 0.0%"},{"location":"coverage/server/src/Network/Socket.cpp/","title":"Socket.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Server\n** File description:\n** Core\n*/\n\n#include \"Socket.hpp\"\n\n#ifdef _WIN32\n    using socklen_t = int; // For compatibility\n#endif\n\nSocket::Socket() : serverSocket(-1) {\n#ifdef _WIN32\n    if (!initializeWinsock()) {\n        std::cerr &lt;&lt; \"Error: Winsock initialization failed!\" &lt;&lt; std::endl;\n    }\n#endif\n}\n\nSocket::~Socket() {\n    if (serverSocket != -1) {\n#ifdef _WIN32\n        closesocket(serverSocket);\n        cleanupWinsock();\n#else\n        close(serverSocket);\n#endif\n    }\n}\n\nbool Socket::initializeWinsock() {\n#ifdef _WIN32\n    WSADATA wsaData;\n    return (WSAStartup(MAKEWORD(2, 2), &amp;wsaData) == 0);\n#else\n    return true;\n#endif\n}\n\nvoid Socket::cleanupWinsock() {\n#ifdef _WIN32\n    WSACleanup();\n#endif\n}\n\nbool Socket::bindSocket(int port, const std::string&amp; ip) {\n    serverSocket = socket(AF_INET, SOCK_STREAM, 0);\n    if (serverSocket == -1) {\n        std::cerr &lt;&lt; \"Error: Failed to create socket!\" &lt;&lt; std::endl;\n        return false;\n    }\n\n    memset(&amp;serverAddr, 0, sizeof(serverAddr));\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_addr.s_addr = INADDR_ANY;\n    serverAddr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, ip.c_str(), &amp;serverAddr.sin_addr) &lt;= 0) {\n        std::cerr &lt;&lt; \"Error: Invalid address or address not supported!\" &lt;&lt; std::endl;\n        return false;\n    }\n\n    if (bind(serverSocket, (struct sockaddr*)&amp;serverAddr, sizeof(serverAddr)) == -1) {\n        std::cerr &lt;&lt; \"Error: Failed to bind socket!\" &lt;&lt; std::endl;\n        return false;\n    }\n\n    return true;\n}\n\nbool Socket::listenForClients() {\n    if (listen(serverSocket, 100) == -1) {\n        std::cerr &lt;&lt; \"Error: Failed to listen on socket!\" &lt;&lt; std::endl;\n        return false;\n    }\n    return true;\n}\n\nint Socket::acceptClient() {\n    int clientSocket = accept(serverSocket, nullptr, nullptr);\n    if (clientSocket == -1) {\n        std::cerr &lt;&lt; \"Error: Failed to accept client connection!\" &lt;&lt; std::endl;\n    }\n    return clientSocket;\n}\n\nbool Socket::sendData(int clientSocket, const std::string&amp; data) {\n    int bytesSent = send(clientSocket, data.c_str(), data.length(), 0);\n    return bytesSent != -1;\n}\n\nstd::string Socket::receiveData(int clientSocket) {\n    char buffer[1024];\n    int bytesReceived = recv(clientSocket, buffer, sizeof(buffer), 0);\n    if (bytesReceived &lt;= 0) {\n        return \"\";\n    }\n    buffer[bytesReceived] = '\\0';\n    return std::string(buffer);\n}\n</code></pre>"},{"location":"coverage/server/src/Network/Socket.hpp/","title":"Socket.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Server\n** File description:\n** Core\n*/\n\n\n#ifndef SOCKET_HPP_\n    #define SOCKET_HPP_\n\n    #include &lt;string&gt;\n    #include &lt;iostream&gt;\n\n    #ifdef _WIN32\n        #include &lt;winsock2.h&gt;\n        #include &lt;ws2tcpip.h&gt;\n        #pragma comment(lib, \"ws2_32.lib\") // Link with Winsock library\n    #else\n        #include &lt;sys/socket.h&gt;\n        #include &lt;netinet/in.h&gt;\n        #include &lt;arpa/inet.h&gt;\n        #include &lt;unistd.h&gt;\n        #include &lt;cstring&gt; // For memset\n    #endif\n\n    class Socket {\n    public:\n        Socket();\n        ~Socket();\n\n        bool bindSocket(int port, const std::string&amp; ip);\n        bool listenForClients();\n        int acceptClient();\n        bool sendData(int clientSocket, const std::string&amp; data);\n        std::string receiveData(int clientSocket);\n\n    private:\n        int serverSocket;\n        sockaddr_in serverAddr;\n\n        bool initializeWinsock();\n        void cleanupWinsock();\n    };\n\n#endif // SOCKET_HPP_\n</code></pre>"},{"location":"coverage/server/src/Server/","title":"Server","text":"Name Lines Covered Uncovered Coverage Client.cpp 28 0 28 0.0% Client.hpp 0 0 0 100.0% Core.cpp 98 0 98 0.0% Core.hpp 0 0 0 100.0% PlayerInfo.cpp 9 0 9 0.0% PlayerInfo.hpp 0 0 0 100.0% ThreadSafeQueue.hpp 8 0 8 0.0% Summary 143 0 143 0.0%"},{"location":"coverage/server/src/Server/Client.cpp/","title":"Client.cpp","text":"<pre><code>#include \"Client.hpp\"\n#include &lt;iostream&gt;\n#include &lt;unistd.h&gt; // For close()\n\nServer::Client::Client(int socket)\n    : _clientSocket(socket), _running(false)\n{\n}\n\nServer::Client::~Client()\n{\n    stop();\n    if (_clientSocket != -1) {\n        close(_clientSocket); // Close the socket when the client is destroyed\n    }\n}\n\nvoid Server::Client::start()\n{\n    _running = true;\n\n    // Make sure that the thread is detached or joined properly\n    try {\n        _clientThread = std::thread(&amp;Client::handleClient, this);\n\n        // Check if the thread was created successfully\n        if (!_clientThread.joinable()) {\n            throw std::runtime_error(\"Failed to create thread.\");\n        }\n\n        _clientThread.detach(); // Detach the thread to run independently\n    } catch (const std::exception&amp; e) {\n        std::cerr &lt;&lt; \"Error starting client thread: \" &lt;&lt; e.what() &lt;&lt; std::endl;\n        // Handle the exception appropriately\n    }\n}\n\nvoid Server::Client::stop()\n{\n    if (_running) {\n        _running = false;\n        if (_clientThread.joinable()) {\n            _clientThread.join();\n        }\n    }\n}\n\nvoid Server::Client::handleClient()\n{\n    // Handle communication with the client\n    this-&gt;sendMessage(\"connect\");\n    while (_running) {\n        // Receive message from the client\n        std::string message = _socket.receiveData(_clientSocket);\n        if (message.empty()) {\n            std::cout &lt;&lt; \"Client disconnected from socket \" &lt;&lt; _clientSocket &lt;&lt; \" !\\n\";\n            break; // Exit if client disconnects\n        }\n\n        if (message != \"\") {\n            // Add received message to the message queue for the server to process\n            _messageQueue.push(message);\n        }\n    }\n}\n\nvoid Server::Client::receiveMessage()\n{\n    std::string message = _socket.receiveData(_clientSocket);\n    if (message.empty()) {\n        std::cout &lt;&lt; \"Client disconnected from socket \" &lt;&lt; _clientSocket &lt;&lt; \" !\\n\";\n        return; // Exit if client disconnects or sends empty data\n    }\n\n    // Add received message to the message queue for the server to process\n    _messageQueue.push(message);\n\n    // Optionally, send an acknowledgment to the client\n    sendMessage(\"Message received\");\n}\n\nvoid Server::Client::sendMessage(const std::string&amp; message)\n{\n    if (!_socket.sendData(_clientSocket, message + \"\\n\")) {\n        std::cerr &lt;&lt; \"Failed to send message to client!\" &lt;&lt; std::endl;\n    }\n}\n\nThreadSafeQueue&lt;std::string&gt;&amp; Server::Client::getMessageQueue()\n{\n    return _messageQueue;\n}\n</code></pre>"},{"location":"coverage/server/src/Server/Client.hpp/","title":"Client.hpp","text":"<pre><code>#ifndef CLIENT_HPP_\n    #define CLIENT_HPP_\n\n    #include \"ThreadSafeQueue.hpp\"\n    #include \"Network/Socket.hpp\"\n    #include &lt;thread&gt;\n    #include &lt;string&gt;\n\n    namespace Server\n    {\n\n        /**\n        * Threaded class that handles communication between the server and the client.\n        * It uses the encapsulated socket.\n        */\n        class Client\n        {\n        public:\n            Client(int socket);\n            ~Client();\n\n            /**\n            * Starts the client thread and socket\n            */\n            void start();\n\n            /**\n            * Starts the client thread\n            */\n            void stop();\n\n            /**\n            * Send message to the client\n            * @param message Message to send\n            */\n            void sendMessage(const std::string&amp; message);\n\n            /**\n            * Check if the client sent data to the server and stores them in the queue, closes the thread if there is no message or is disconnected\n            */\n            void receiveMessage();\n\n            /**\n            * Returns the message queue that contains the messages sent by the client\n            */\n            ThreadSafeQueue&lt;std::string&gt;&amp; getMessageQueue();\n\n        private:\n            int _clientSocket;\n            std::thread _clientThread;\n            ThreadSafeQueue&lt;std::string&gt; _messageQueue;\n            bool _running;\n            Socket _socket;\n\n            void handleClient();\n        };\n\n    }\n\n#endif // CLIENT_HPP_\n</code></pre>"},{"location":"coverage/server/src/Server/Core.cpp/","title":"Core.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** EpiGimp\n** File description:\n** main\n*/\n\n#include \"Core.hpp\"\n#include \"ErrorException.hpp\"\n#include &lt;iostream&gt;\n#include &lt;thread&gt;\n\nServer::Core::Core(int port, std::string ip)\n    : _port(port), _ip(ip)\n{\n    this-&gt;_ecsManager = std::make_shared&lt;ECS::ECSManager&gt;(\"RType\", \"assets\");\n    this-&gt;_ecsManager-&gt;createWorld(\"Waiting\");\n}\n\nServer::Core::~Core()\n{\n    for (auto&amp; client : _clients) {\n        client.second-&gt;stop();\n    }\n}\n\nvoid Server::Core::run()\n{\n    if (!_socket.bindSocket(_port, _ip)) {\n        throw ErrorException(\"Error: Server failed to initialize!\");\n    }\n    if (!_socket.listenForClients()) {\n        throw ErrorException(\"Error: Server failed to listen for clients!\");\n    }\n    std::cout &lt;&lt; \"Server is running on \" &lt;&lt; _ip &lt;&lt; \":\" &lt;&lt; _port &lt;&lt; std::endl;\n\n    // Start accepting clients in a separate thread\n    std::thread acceptThread(&amp;Server::Core::acceptClients, this);\n    acceptThread.detach(); // Detach so it runs independently\n\n    while (true) {\n        processClientMessages();\n        std::cout &lt;&lt; \"\";\n        if (!this-&gt;_gameStarted) {\n            continue;\n        }\n        this-&gt;checkPlayersCapabilities();\n        this-&gt;_ecsManager-&gt;update();\n        this-&gt;checkEvent();\n        this-&gt;sendGameUpdate();\n        if (this-&gt;_playerInfos.size() &lt;= 0) {\n            this-&gt;sendToAll(\"end\");\n            this-&gt;_gameStarted = false;\n        }\n        std::this_thread::sleep_for(std::chrono::duration&lt;float&gt;(0.016f));\n    }\n    this-&gt;sendToAll(\"end\");\n}\n\nvoid Server::Core::acceptClients()\n{\n    int nbrClients = 0;\n    while (true) {\n        if (nbrClients &gt;= 4) {\n            break;\n        }\n        int clientSocket = _socket.acceptClient();\n        if (clientSocket != -1) {\n            std::cout &lt;&lt; \"Client connected!\\n\";\n            this-&gt;_clients[nbrClients] = std::make_unique&lt;Client&gt;(clientSocket);\n            this-&gt;_clients[nbrClients]-&gt;start();\n            nbrClients++;\n        }\n    }\n}\n\nvoid Server::Core::processClientMessages()\n{\n    for (auto&amp; client : _clients) {\n        if (client.second == nullptr) continue;\n        std::string message = client.second-&gt;getMessageQueue().pop();\n        if (!message.empty()) {\n            this-&gt;handleCommand(message, client.first + 1);\n        }\n    }\n}\n\nvoid Server::Core::handleCommand(std::string message, int clientNbr)\n{\n    if (message == \"\") {\n        return;\n    }\n    ECS::entity_id id;\n    std::regex reg(\"[\\\\ \\\\n]\");\n    auto begin = std::sregex_token_iterator(message.begin(), message.end(), reg, -1);\n    auto end = std::sregex_token_iterator();\n    std::vector&lt;std::string&gt; command(begin, end);\n    if (command[0] == \"start\") {\n        this-&gt;sendToAll(\"start \" + std::to_string(this-&gt;_clients.size()));\n        this-&gt;_ecsManager-&gt;loadWorld(\"test\");\n        int nbrPlayers = 1;\n        while (nbrPlayers &lt;= this-&gt;_clients.size()) {\n            id = this-&gt;_ecsManager-&gt;createEntityFromPrefab(\"player\" + std::to_string(nbrPlayers));\n            this-&gt;_ecsManager-&gt;getComponent&lt;ECS::Component::Position&gt;(id)-&gt;vect.x = 100;\n            this-&gt;_ecsManager-&gt;getComponent&lt;ECS::Component::Position&gt;(id)-&gt;vect.y = 300 + (100 * nbrPlayers);\n            this-&gt;_playerInfos[nbrPlayers] = std::make_unique&lt;Server::PlayerInfo&gt;(id);\n            nbrPlayers++;\n        }\n        this-&gt;_gameStarted = true;\n        return;\n    }\n    if (!_gameStarted) {\n        return;\n    }\n    if (this-&gt;_playerInfos.count(clientNbr) == 0) {\n        return;\n    }\n    auto vel = this-&gt;_ecsManager-&gt;getComponent&lt;ECS::Component::Velocity&gt;(this-&gt;_playerInfos[clientNbr]-&gt;getEntityID());\n    if (command[0] == \"up\") {\n        vel-&gt;vect.y = -300 * (command[1] == \"1\"); return;\n    }\n    if (command[0] == \"down\") {\n        vel-&gt;vect.y = 300 * (command[1] == \"1\"); return;\n    }\n    if (command[0] == \"left\") {\n        vel-&gt;vect.x = -300 * (command[1] == \"1\"); return;\n    }\n    if (command[0] == \"right\") {\n        vel-&gt;vect.x = 300 * (command[1] == \"1\"); return;\n    }\n    if (command[0] == \"action\") {\n        this-&gt;_playerInfos[clientNbr]-&gt;setIsShooting(command[1] == \"1\");\n    }\n    return;\n}\n\nvoid Server::Core::sendToAll(std::string message)\n{\n    for (auto&amp; client : _clients) {\n        client.second-&gt;sendMessage(message);\n    }\n}\n\nvoid Server::Core::checkPlayersCapabilities()\n{\n    for (auto&amp; player : _playerInfos) {\n        auto pos = this-&gt;_ecsManager-&gt;getComponent&lt;ECS::Component::Position&gt;(player.second-&gt;getEntityID());\n        if (pos == nullptr) {\n            this-&gt;sendToAll(\"playerDead \" + std::to_string(player.first));\n            this-&gt;_playerInfos.erase(player.first);\n            break;\n        }\n        pos-&gt;vect.x = pos-&gt;vect.x &lt; 20 ? 20 : pos-&gt;vect.x;\n        pos-&gt;vect.x = pos-&gt;vect.x &gt; 1580 ? 1580 : pos-&gt;vect.x;\n        pos-&gt;vect.y = pos-&gt;vect.y &lt; 20 ? 20 : pos-&gt;vect.y;\n        pos-&gt;vect.y = pos-&gt;vect.y &gt; 880 ? 880 : pos-&gt;vect.y;\n        player.second-&gt;reduceShootCooldown(0.016f);\n        if (player.second-&gt;getIsShooting() &amp;&amp; player.second-&gt;getShootCooldown() &lt;= 0) {\n            ECS::entity_id id = this-&gt;_ecsManager-&gt;createEntityFromPrefab(\"bullet\");\n            this-&gt;_ecsManager-&gt;getComponent&lt;ECS::Component::Position&gt;(id)-&gt;vect.x = pos-&gt;vect.x + 20;\n            this-&gt;_ecsManager-&gt;getComponent&lt;ECS::Component::Position&gt;(id)-&gt;vect.y = pos-&gt;vect.y;\n            player.second-&gt;setShootCooldown(0.3f);\n        }\n    }\n}\n\nvoid Server::Core::sendGameUpdate()\n{\n    std::ostringstream update;\n\n    std::vector&lt;ECS::entity_id&gt; entities = this-&gt;_ecsManager-&gt;getCurrentRegistry().getEntitiesWithComponent&lt;ECS::Component::Tag&gt;();\n    for (auto &amp;entity : entities) {\n        auto tag = this-&gt;_ecsManager-&gt;getComponent&lt;ECS::Component::Tag&gt;(entity);\n        if (tag-&gt;value == \"player\") {\n            continue;\n        }\n        auto pos = this-&gt;_ecsManager-&gt;getComponent&lt;ECS::Component::Position&gt;(entity);\n        if (pos-&gt;vect.x &gt; -10 &amp;&amp; pos-&gt;vect.x &lt; 1700) {\n            update &lt;&lt; \"place \" &lt;&lt; tag-&gt;value &lt;&lt; \" \" &lt;&lt; pos-&gt;vect.x &lt;&lt; \" \" &lt;&lt; pos-&gt;vect.y &lt;&lt; std::endl;\n        }\n    }\n    for (auto &amp;player : this-&gt;_playerInfos) {\n        auto pos = this-&gt;_ecsManager-&gt;getComponent&lt;ECS::Component::Position&gt;(player.second-&gt;getEntityID());\n        if (pos != nullptr) {\n            update &lt;&lt; \"player \" &lt;&lt; player.first &lt;&lt; \" \" &lt;&lt; pos-&gt;vect.x &lt;&lt; \" \" &lt;&lt; pos-&gt;vect.y &lt;&lt; std::endl;\n        }\n    }\n    this-&gt;sendToAll(update.str());\n    update.clear();\n}\n\nvoid Server::Core::checkEvent()\n{\n    for (auto &amp;e : this-&gt;_ecsManager-&gt;getAllEventsThisFrame()) {\n        this-&gt;sendToAll(e);\n    }\n}\n</code></pre>"},{"location":"coverage/server/src/Server/Core.hpp/","title":"Core.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2024\n** Server\n** File description:\n** Core\n*/\n\n#ifndef CORE_HPP_\n    #define CORE_HPP_\n\n    #include \"ECSManager.hpp\"\n    #include \"Client.hpp\"\n    #include \"PlayerInfo.hpp\"\n    #include &lt;string&gt;\n    #include &lt;memory&gt;\n    #include &lt;thread&gt;\n    #include &lt;unordered_map&gt;\n\n    namespace Server\n    {\n\n        class Core\n        {\n        public:\n            Core(int port, std::string ip);\n            ~Core();\n\n            /**\n            * Run the server's loop and threads\n            */\n            void run();\n\n            /**\n            * Checks if any client sent a message to process with the handleCommand() method\n            */\n            void processClientMessages();\n\n            /**\n            * Handles the client's command\n            * @param message Client message containing the command\n            * @param clientNbr Number of the client\n            *\n            */\n            void handleCommand(std::string message, int clientNbr);\n\n            /**\n            * Sends a message to all the clients at once\n            * @param message Message to send\n            *\n            */\n            void sendToAll(std::string message);\n\n            /**\n            * Checks player positiona and cooldown to prevent cheating or out of bounds\n            *\n            */\n            void checkPlayersCapabilities();\n\n            /**\n            * Sends the player and all element positions.\n            *\n            */\n            void sendGameUpdate();\n\n            /**\n            * Check if the ECSManager has any events this frame and sends them to clients.\n            * The events are defined in the .so scripts\n            *\n            */\n            void checkEvent();\n\n        private:\n            std::shared_ptr&lt;ECS::ECSManager&gt; _ecsManager;\n            Socket _socket;\n            int _port;\n            std::string _ip;\n            std::unordered_map&lt;int, std::unique_ptr&lt;Server::Client&gt;&gt; _clients;\n\n            bool _gameStarted = false;\n            double _sendInfoCooldown = 0.1f;\n            std::unordered_map&lt;int, std::unique_ptr&lt;PlayerInfo&gt;&gt; _playerInfos;\n\n            double _ennemySpawnCountdown = 0.5f;\n\n            void acceptClients();\n        };\n\n    }\n\n#endif // CORE_HPP_\n</code></pre>"},{"location":"coverage/server/src/Server/PlayerInfo.cpp/","title":"PlayerInfo.cpp","text":"<pre><code>#include \"PlayerInfo.hpp\"\n\nServer::PlayerInfo::PlayerInfo(ECS::entity_id id)\n{\n    this-&gt;_entityID = id;\n    this-&gt;_shootCooldown = 0.3f;\n}\n\nServer::PlayerInfo::~PlayerInfo()\n{\n\n}\n\nECS::entity_id Server::PlayerInfo::getEntityID() const\n{\n    return this-&gt;_entityID;\n}\n\nvoid Server::PlayerInfo::setEntityID(ECS::entity_id id)\n{\n    this-&gt;_entityID = id;\n}\n\ndouble Server::PlayerInfo::getShootCooldown() const\n{\n    return this-&gt;_shootCooldown;\n}\n\nvoid Server::PlayerInfo::setShootCooldown(double cooldown)\n{\n    this-&gt;_shootCooldown = cooldown;\n}\n\nbool Server::PlayerInfo::getIsShooting() const\n{\n    return this-&gt;_isShooting;\n}\n\nvoid Server::PlayerInfo::setIsShooting(bool isShooting)\n{\n    this-&gt;_isShooting = isShooting;\n}\n\nvoid Server::PlayerInfo::reduceShootCooldown(double f)\n{\n    this-&gt;_shootCooldown -= f;\n}\n</code></pre>"},{"location":"coverage/server/src/Server/PlayerInfo.hpp/","title":"PlayerInfo.hpp","text":"<pre><code>#ifndef PLAYER_INFO_HPP_\n    #define PLAYER_INFO_HPP_\n\n    #include \"Entity.hpp\"\n    #include &lt;thread&gt;\n    #include &lt;string&gt;\n\n    namespace Server\n    {\n\n        /**\n        * Contains all gameplay information of the player in game\n        *\n        */\n        class PlayerInfo\n        {\n        public:\n            PlayerInfo(ECS::entity_id id);\n            ~PlayerInfo();\n\n            ECS::entity_id getEntityID() const;\n            void setEntityID(ECS::entity_id id);\n\n            double getShootCooldown() const;\n            void setShootCooldown(double cooldown);\n            void reduceShootCooldown(double f);\n\n            bool getIsShooting() const;\n            void setIsShooting(bool isShooting);\n\n\n\n        private:\n            ECS::entity_id _entityID;\n            double _shootCooldown = 0.3f;\n            bool _isShooting;\n\n        };\n\n    }\n\n#endif // CLIENT_HPP_\n</code></pre>"},{"location":"coverage/server/src/Server/ThreadSafeQueue.hpp/","title":"ThreadSafeQueue.hpp","text":"<pre><code>#ifndef THREADSAFEQUEUE_HPP_\n    #define THREADSAFEQUEUE_HPP_\n\n    #include &lt;queue&gt;\n    #include &lt;mutex&gt;\n    #include &lt;condition_variable&gt;\n\n    template &lt;typename T&gt;\n    class ThreadSafeQueue {\n        public:\n            void push(const T&amp; item) {\n                std::lock_guard&lt;std::mutex&gt; lock(mtx_);\n                queue_.push(item);\n                cv_.notify_one();\n            }\n\n            T pop() {\n                std::lock_guard&lt;std::mutex&gt; lock(mtx_);\n                if (queue_.empty()) {\n                    return T();\n                }\n                T item = queue_.front();\n                queue_.pop();\n                return item;\n            }\n\n            bool empty() const {\n                std::lock_guard&lt;std::mutex&gt; lock(mtx_);\n                return queue_.empty();\n            }\n\n        private:\n            std::queue&lt;T&gt; queue_;\n            mutable std::mutex mtx_;\n            std::condition_variable cv_;\n    };\n\n#endif\n</code></pre>"},{"location":"ecs/","title":"Entity Component System","text":"<p>While not a required part of the project, the Entity Component System (or ECS) is quite important. That is why it is built as a separate library</p>"},{"location":"flint/","title":"Flint","text":"<p>A custom implementation of the Flint library</p>"},{"location":"flint/#types","title":"Types","text":"Name Description Colors This class defined a good set of ANSI colors. CxxABI Wrapper around usefull C++/C low level functions Got demangle, backtrace... !!! tip This class is only made of static functions. It does not contain constructor, nor destructor This means that you don't need to instanciate it, and only use it as if it was a namespace. Exception Wrapper arround default std::exception Store the the exception description as std::string, and store some usefull localisation informations: Filename, Line, and Function Name. This is automated using the throw_exception preprocessor directive. !!! tip Take a look at the NotImplementedError to see how easy it is to implmeent your own Flint::Exception. Inspection Base class to implement simplet self-reflexion in C++  <code>T</code> :    Child class itself !!! tip When creating a child class, define as follow : <code>cpp class ChildClass: public Inspection&lt;ChildClass&gt;</code> This will extand the ChildClass with the self-reflexion class Inspection !!! warning If the class you want to extand as a reflected class will be a parent class (I.E. You will create childs of this \"target\" class), you might want to mark inheritence as virtual. This is needed if your child class also need to be reflected. This way, there is no confilict between the parent reflexion, and the child reflexion. NotImplementedError Sample Flint::Exceptions::Exception to register NotImplemented features !!! tip You should use that Exception as a C++ Implementation of the Rust todo!() macro. !!! example <code>cpp throw_exception(Flint::Exceptions::NotImplementedError, \"This function haven't been implemented as of today !\");</code>"},{"location":"flint/Colors/","title":"Colors","text":"<p>class Colors</p> <p>This class defined a good set of ANSI colors.</p> <p>Tip</p> <p>It is recomended to use those through streams : std::cout &lt;&lt; Flint::Colors::GREEN &lt;&lt; \"Hacker time\" &lt;&lt; Flint::Colors::RESET &lt;&lt; std::endl;</p> <p>Info</p> <p>Please ALWAYS remember to close your colors with Flint::Colors::RESET. Failure to do si might result in broken displays, with weird colors everywhere</p>"},{"location":"flint/CxxABI/","title":"CxxABI","text":"<p>class CxxABI</p> <p>Wrapper around usefull C++/C low level functions</p> <p>Got demangle, backtrace...</p> <p>Tip</p> <p>This class is only made of static functions. It does not contain constructor, nor destructor This means that you don't need to instanciate it, and only use it as if it was a namespace.</p>"},{"location":"flint/CxxABI/#functions","title":"Functions","text":"Name Description demangle Demangle a C++ name. getFuncInfos Get functions infos from symbol extraction  Return :    A pair with the function names demangled, and the offset from the function !!! warning The function name is not EXACTLY the real name of the function. Also, the offset DOES NOT correspond to the line number, but the offset of asm instructions getBacktrace Retreive the execution trace  Return :    Vector of pair, string&gt;. I'll explain The idea is to retrieive the file, line, and function. So that's what we do : pair or : (file, line), function !!! warning To correctly grab function names, you will need to add compilation flag \"-rdynamic\" See this lib's CMakeLists.txt for implementation. This will export ALL symbols. If NOT done, you will get offsets from binary. It's ok, but quite disgusting on output."},{"location":"flint/CxxABI/#function-details","title":"Function Details","text":""},{"location":"flint/CxxABI/#demangle","title":"demangle","text":"<p>static std::string demangle(const char* name)</p> <p>Demangle a C++ name.</p> <p>This is usefull for : Class names, backtrace...</p> Return string containing : demangled name, or original name, if demangle did not work"},{"location":"flint/CxxABI/#getbacktrace","title":"getBacktrace","text":"<p>static std::vector&lt;std::pair&lt;std::string, std::size_t&gt;&gt; getBacktrace()</p> <p>Retreive the execution trace</p> Return Vector of pair, string&gt;. I'll explain <p>The idea is to retrieive the file, line, and function. So that's what we do : pair or : (file, line), function</p> <p>Warning</p> <p>To correctly grab function names, you will need to add compilation flag \"-rdynamic\" See this lib's CMakeLists.txt for implementation. This will export ALL symbols. If NOT done, you will get offsets from binary. It's ok, but quite disgusting on output.</p>"},{"location":"flint/CxxABI/#getfuncinfos","title":"getFuncInfos","text":"<p>static std::pair&lt;std::string, std::size_t&gt; getFuncInfos(const char* symbolInfos)</p> <p>Get functions infos from symbol extraction</p> Return A pair with the function names demangled, and the offset from the function <p>Warning</p> <p>The function name is not EXACTLY the real name of the function. Also, the offset DOES NOT correspond to the line number, but the offset of asm instructions</p>"},{"location":"flint/Exception/","title":"Exception","text":"<p>class Exception: public std::exception</p> <p>Wrapper arround default std::exception</p> <p>Store the the exception description as std::string, and store some usefull localisation informations: Filename, Line, and Function Name. This is automated using the throw_exception preprocessor directive.</p> <p>Tip</p> <p>Take a look at the NotImplementedError to see how easy it is to implmeent your own Flint::Exception.</p>"},{"location":"flint/Exception/#operators","title":"Operators","text":"Name Description operator&lt;&lt; operator&lt;&lt; override !!! abstract This will simply append the _what to the ostream"},{"location":"flint/Exception/#functions","title":"Functions","text":"Name Description Exception Exception constructor. getInfos Retreive given infos (filename, line, and function name)  Return :    The actual infos getClassNameFromStackTrace Try to retreive the Exception class name from the StackTrace. show Display the error, given specific positional infos (like the constructor). what Required override, deprecated by show and catch_exception."},{"location":"flint/Exception/#operator-details","title":"Operator Details","text":""},{"location":"flint/Exception/#operator","title":"operator&lt;&lt;","text":"<p>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Exceptions::Exception&amp; obj)</p> <p>operator&lt;&lt; override</p> <p>Abstract</p> <p>This will simply append the _what to the ostream</p>"},{"location":"flint/Exception/#function-details","title":"Function Details","text":""},{"location":"flint/Exception/#exception_1","title":"Exception","text":"<p>Exception(const std::string&amp; what = \"An exception occured !\", std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; infos = {{\"\", 0}, \"\"})</p> <p>Exception constructor. This need to be called, even on child classes.</p> <code>what</code> Define the exception's description <code>infos</code> Might contain positional infos <p>Warning</p> <p>You should NOT use any excpetion constructor manually. While they might work, the prefered way is to use the throw_exception preprocessor directive. Using it will only require you to register what type of excpetion you want to throw, and what message you want to add, and will take care of putting file name, line, and function name</p>"},{"location":"flint/Exception/#getclassnamefromstacktrace","title":"getClassNameFromStackTrace","text":"<p>std::string getClassNameFromStackTrace(const std::vector&lt;std::pair&lt;std::string, std::size_t&gt;&gt;&amp; stackTrace) const</p> <p>Try to retreive the Exception class name from the StackTrace.</p> <code>stackTrace</code> A stack trace, formated like CxxABI::getBacktrace() <p>Warning</p> <p>This function DOES NOT WORK 100% OF THE TIME. It is really dependant on the environement, and can return undefined without aparent reason. It should NOT be used for anything else than debug or display.</p> Return The actual class name or \"[Class name undefined]\""},{"location":"flint/Exception/#getinfos","title":"getInfos","text":"<p>std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; getInfos() const</p> <p>Retreive given infos (filename, line, and function name)</p> Return The actual infos"},{"location":"flint/Exception/#show","title":"show","text":"<p>std::string show(std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; infos) const</p> <p>Display the error, given specific positional infos (like the constructor).</p> <code>infos</code> Positional informations, like the constructor, used to display the infos. <p>Note</p> <p>This function, while being usable without, should be used through the catch_exception preprocessor directive. This preprocessor directive let you display Python like excpetion trace.</p> Return The formated exception, ready to be displayed."},{"location":"flint/Exception/#what","title":"what","text":"<p>const char* what() const noexcept override</p> <p>Required override, deprecated by show and catch_exception.</p> <p>Info</p> <p>This is the required std::exception override. It'll return the _what as a const char*. While this will work, prefer using the show function or the catch_excpetion preprocessor directive :</p> <p>Example</p> <pre><code>try {\n    throw_exception(Flint::Exceptions::Exception, \"Sample testing exception\");\n} catch (const Flint::Exceptions::Exception&amp; e) {\n    std::cerr &lt;&lt; catch_exception(e) &lt;&lt; std::endl;\n}\n</code></pre> Return The _what as a C string"},{"location":"flint/Inspection/","title":"Inspection","text":"<p>template &lt;typename T&gt; class Inspection</p> <p>Base class to implement simplet self-reflexion in C++</p> <code>T</code> Child class itself <p>Tip</p> <p>When creating a child class, define as follow : <pre><code>class ChildClass: public Inspection&lt;ChildClass&gt;\n</code></pre> This will extand the ChildClass with the self-reflexion class Inspection</p> <p>Warning</p> <p>If the class you want to extand as a reflected class will be a parent class (I.E. You will create childs of this \"target\" class), you might want to mark inheritence as virtual. This is needed if your child class also need to be reflected. This way, there is no confilict between the parent reflexion, and the child reflexion.</p>"},{"location":"flint/Inspection/#operators","title":"Operators","text":"Name Description operator&lt;&lt; Overload the operator &lt;&lt; to use the str method of the object  <code>T</code> :    Reflected class  <code>os</code> :    Reference of ostream (I.E. std::cout, std::cerr...)  <code>obj</code> :    Object reference to be displayed  Return :    Param os"},{"location":"flint/Inspection/#functions","title":"Functions","text":"Name Description getClassName Return the name of the reflected class  Return :    The demangled name of the class, or just the name, if demangleing failed str Return a string representation of the class !!! tip This function is not intended to be used. This is because this functions display the reflection. You might prefer to override this function in yout child class to display informations that are more relevant to your specific class. !!! example You have a Macro available to make the str function really easilly : <code>cpp display_attr(attribute)</code> Which will automaticly translate to <code>cpp Flint::Colors::F_BLUE &lt;&lt; \"attribute\" &lt;&lt; Flint::Colors::RESET &lt;&lt; \"=\" &lt;&lt; Flint::Colors::RED &lt;&lt; this-&gt;attribute &lt;&lt; Flint::Colors::RESET</code> There is also a <code>make_str</code> macro, which you can use as follow : <code>cpp return make_str(\"a=12\" &lt;&lt; \", \" &lt;&lt; \"b=5\");</code> that becomes <code>cpp return ({std::stringstream ss; ss &lt;&lt; \"&lt;\" &lt;&lt; this-&gt;getClassName() &lt;&lt; \" at \" &lt;&lt; std::hex &lt;&lt; this &lt;&lt; \": \" &lt;&lt; \"a=12\" &lt;&lt; \", \" &lt;&lt; \"b=5\" &lt;&lt; \"&gt;\"; ss.str()})</code> It means you can define the str function of your class as like that : <code>cpp // Provided you have 3 attributes called a, b and c return make_str(display_attr(a) &lt;&lt; \", \" &lt;&lt; display_attr(b) &lt;&lt; \", \" &lt;&lt; display_attr(c));</code> Return :    The string representation of the class"},{"location":"flint/Inspection/#operator-details","title":"Operator Details","text":""},{"location":"flint/Inspection/#operator","title":"operator&lt;&lt;","text":"<p>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Inspection&lt;T&gt;&amp; obj)</p> <p>Overload the operator &lt;&lt; to use the str method of the object</p> <code>T</code> Reflected class <code>os</code> Reference of ostream (I.E. std::cout, std::cerr...) <code>obj</code> Object reference to be displayed Return Param os"},{"location":"flint/Inspection/#function-details","title":"Function Details","text":""},{"location":"flint/Inspection/#getclassname","title":"getClassName","text":"<p>virtual std::string getClassName() const final</p> <p>Return the name of the reflected class</p> Return The demangled name of the class, or just the name, if demangleing failed"},{"location":"flint/Inspection/#str","title":"str","text":"<p>virtual std::string str() const</p> <p>Return a string representation of the class</p> <p>Tip</p> <p>This function is not intended to be used. This is because this functions display the reflection. You might prefer to override this function in yout child class to display informations that are more relevant to your specific class.</p> <p>Example</p> <p>You have a Macro available to make the str function really easilly : <pre><code>display_attr(attribute)\n</code></pre> Which will automaticly translate to <pre><code>Flint::Colors::F_BLUE &lt;&lt; \"attribute\" &lt;&lt; Flint::Colors::RESET &lt;&lt; \"=\" &lt;&lt; Flint::Colors::RED &lt;&lt; this-&gt;attribute &lt;&lt; Flint::Colors::RESET\n</code></pre> There is also a <code>make_str</code> macro, which you can use as follow : <pre><code>return make_str(\"a=12\" &lt;&lt; \", \" &lt;&lt; \"b=5\");\n</code></pre> that becomes <pre><code>return ({std::stringstream ss; ss &lt;&lt; \"&lt;\" &lt;&lt; this-&gt;getClassName() &lt;&lt; \" at \" &lt;&lt; std::hex &lt;&lt; this &lt;&lt; \": \" &lt;&lt; \"a=12\" &lt;&lt; \", \" &lt;&lt; \"b=5\" &lt;&lt; \"&gt;\"; ss.str()})\n</code></pre> It means you can define the str function of your class as like that : <pre><code>// Provided you have 3 attributes called a, b and c\nreturn make_str(display_attr(a) &lt;&lt; \", \" &lt;&lt; display_attr(b) &lt;&lt; \", \" &lt;&lt; display_attr(c));\n</code></pre></p> Return The string representation of the class"},{"location":"flint/NotImplementedError/","title":"NotImplementedError","text":"<p>class NotImplementedError: public Flint::Exceptions::Exception</p> <p>Sample Flint::Exceptions::Exception to register NotImplemented features</p> <p>Tip</p> <p>You should use that Exception as a C++ Implementation of the Rust todo!() macro.</p> <p>Example</p> <pre><code>throw_exception(Flint::Exceptions::NotImplementedError, \"This function haven't been implemented as of today !\");\n</code></pre>"},{"location":"network/","title":"Network","text":"<p>Custom classes handeling all the networking. This allows you to create your own network wrapper (Hell, you could play through HTTP WebSockets if you want ! (Don't do that please)).</p>"},{"location":"server/","title":"Server","text":"<p>As important as all of the other parts (if not more), the server is the masterchief of the orchestra. It connect all players, and handle all the game logic.</p>"}]}